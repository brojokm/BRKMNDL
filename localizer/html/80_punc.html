<html>
<body>
In the last class we looked at the union find data structure. That was a data structure to maintain a collection of disjoint sets, under the operations of union. That was the operations we were doing in the sets, that was the operation which were modifying the sets or modifying the collection and the find operation was just to identify, given an element, which set it belongs to. We used this, we needed this data structure to implement the Kruskal is algorithm. Kruskal is algorithm was the first algorithm we looked at for computing a minimum spanning tree in a graph. It was an example of the greedy algorithm. Today, we are going to look at another algorithm for computing the minimum spanning tree in a graph. This one is due to Prim and that is what we are going to discuss today. So, let me define the notion of a cut in a graph first, for you. So, recall that we are talking of undirected graph. A spanning tree, the notion of a spanning tree is defined only for an undirected graph. For a directed graph, there are different notions. We do not say spanning tree in a directed graph. It is only an undirected graph we are talking about here. So, give you an undirected graph, a cut let say, this is graph G and a cut in graph G is a partition of the vertex set into two parts. What does it mean? Let me partition, break vertex into two pieces. So let say, one piece is this and the other is remaining because, it is the partition. This way of splitting would define a cut. So, if for an instance, I had vertices, a, b, c, d, e. So, then the first cut I am considering is a, b one side and c, d, e on the other side. There could be many other cuts possible, I could have a, c and d on one side and b and e on the other side or I could have only one vertex let say, c an one side and the other four on the, the remaining four on the other side. These are all examples of cuts in the graph. How many cuts can there be in the graph? two to the power n? two to the n or something? two to the power n minus one. because, this partition is the same as saying, c d e and a b. How did you come out with the number two to the n? Every element, for every element, there are two choices, either left or right. So, there are two to the n possibilities but then, but then, we are repeating. Each possibility is repeated twice. Once we will say, a b go on the left side, c d e go on the right side and the other time we will say, c d e go on the left side, a b goes the right side. But the partition is the same. So, that is why number of different cuts, two to the n minus 1, minus one also. Okay, then null? You are talking of the null Sometimes, what we do is when we say a cut, so cut is really a partition of vertex a. But I sometimes would also say, these edges which are going from one side to the other side are called the edges in the cut. So, these edges could be called the edges in the cut, edges in the cut or edges of the cut, whatever. You understand which edges I am talking about? Edges which have one end point in one side of the partition and the other end point in the other side of the partition. So, you understand what a cut is. You need this notion and how to we use this notion? Suppose, I take a cut of my graph, some cut in the graph, S and I will denote other point, other side by S complement or V minus S where V is the vertex set. So, I have a graph G S V, the vertex set and e is the set of edges. So, S is the set on one side and the remaining is the set on other side. Now, let me look at all the edges which are in the cut. Recall, we are trying to compute the minimum spanning tree. So, I am now going to be taking of a particular property of the minimum spanning tree. So let me take this cut and let me look at the edges in the cut and let us look at their lengths of these edges. So, may be, this edge is length 2, this edge is 4, this is length 3, this is length seven point I am going to be assuming that all the edge lengths are distinct. This is just to ease all my arguments, to simplify my arguments. All the algorithms, everything works even when edge lengths are not necessarily distinct. So, just to simplify my presentation here that I am going to assume edge lengths are distinct. Now, the claim is that, so recall, when the edge lengths are distinct, there is a unique minimum spanning tree. We have discussed this before there is one and only one minimum spanning tree. Now, the claim is that this edge which has length two will be a part of that minimum spanning tree. Let me write down the claim more formally, for any cut, any cut S, S complement the minimum edge in the cut belongs to the MST two to the n minus one different cuts. 1? for instance let us make a tree such that there will be both of these edges will be part of the minimum spanning tree or part of the minimum spanning tree. both the edges are part of the minimum spanning tree. I could have my edge length so that this was my minimum spanning tree. I could choose my edge length so that this is the minimum spanning tree. So, it is not necessary that only, for any cut, there is only one edge which is the part of minimum spanning tree, there could be more than one edge which could be a part of minimum spanning tree. But, all we are claiming is that the minimum edge in the cut will belong to the minimum spanning tree why? What is the proof? So, proof is by contradiction you are saying that this is the minimum spanning tree but, that tree does not contain this edge. So, let T be a MST. MST is short for minimum spanning tree. T is an MST which does not contain edge does not contain edge which does not contain edge e. So, what now? What will I do? I will add e to the tree, add e to T. What will happen? Cycle will be formed. Why will a cycle be formed? Because, these two vertices are already connected, these two vertices are already connected in the tree. So, there is some path going from this vertex to this vertex. Any path that goes from this vertex to this vertex, from u to v which connects u and v has to use one of the edges of the cut. Think of this as, this is the river in between, this is one end, this is the other end. If you have to go from this end to other end, you have to use one of these bridges, no other alternative. So, it has to use one of these edges which means that the cycle that gets formed has to use one of these edges at least. But, all these edges has length more than two. So, what will I do? Same thing, I will remove this edge from the cycle and at that, this will reduce the length of the tree. So, let me write that down. So, we add e to T, let me continue. So, after you add e to T, so let me addition of e to T forms a cycle. Say, capital C. C contains at least one edge of the cut. Yes or no? At least, one edge of the cut, this implies C contains at least 2? It will contain an odd number of edges. Added C, at least one edge, let me write down other than e, good. e will have to be part of the cycle. It is because of the addition of e that cycle got formed. There was no cycle earlier, e has to be part of the cycle. So, C contains at least one edge of the cut other than edge e. So, this implies C contains on edge of length more than the length of e. C contains an edge of length more than the length of e. They can be greater than I just have to show that there is some edge in the cycle which has length more than e. No, we created the cycle, we brought in e, now how do we want to reduce the cost of the tree? By removing some other edge whose length is larger than e. By removing this edge from T union e, we get a smaller tree. That is a contradiction, because we assumed that T was a minimum spanning tree. This we have discussed before that, from a cycle I can remove the any edge and it will remain a spanning tree. We can also remove that, I just have to show you that there is some edge in the cycle which can be removed. To just, I have to just eye with a contradiction. I am just arriving at a contradiction here, this is a mind game. We are not actually removing any thing, I am just proving a structural property. I am saying, in any cut the minimum edge has to be a part of minimum spanning tree. I do not ever sit down and remove any thing. There is no algorithm does that. This is just a proof, proving this statement. How do know that one of the edges of the cycle has length more than e? Because, we can only argue for the edges of the cut, for then we know for sure that they are all more than e. That is all, nothing more. Now, how are we going to use this claim? So, Prim is algorithm exploits this simple fact that, if you take any cut, the minimum edge in the cut will be part of the minimum spanning tree, always. Prim is algorithm is an algorithm which essentially is built around this simple fact. So, let us understand what Prim is algorithm is. Let say this were my, this were my, what? Graph and let us give every edge length. So, I will just rapidly put down edge lengths, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, say, I missed out one, thirteen. Now, how does Prim is algorithm work? First, we start from some vertex and we call this the root vertex. Now, the first partition that I am considering, the first cut I am considering is the root verses everyone else. Root of one side and everyone else on the other side. So, which edge has to be part of the cut? The edge of length 1, so, I will include this into my cut, into my which edge has to be part of the minimum spanning tree, edge of length of length1 and I will include it into my three. Now, what is the cut I am going to consider? This and this, so I am going to, this is going to one side of the cut, this is going to be one side of the cut and the other side of the cut is going to be all the other vertices. So, which are the edges which are part of the cut? 9, 8, 2, 3, 11, so which is the smallest? 2, so we know for a fact that this has to be there in the minimum spanning tree, this included What is the cut I am going to consider? These three vertices on one side and all the other on other side, so side let me extend it like that can everyone see this? This is one side of the cut and all the other vertices are on the other side of the cut. So now, which are the edges in the cut? 9, 8, 7, 5, 13, 11 three is not in the cut, because both end points of three are on the same side. So, the smallest of these is five. So, this gets included. Now, I am going to, you can now understand how I am going to extend it. This becomes my, one side of the cut and the remaining becomes the other side of the cut, four is in edge, three is some kind of a gone, so 9, 8, 6, four minus no, not ten thirteen and eleven four Which are the edges in the cut? 11, 13, 10, 6, 7, 8, 9 so, six is the smallest, eight gets included and now, my set becomes this. It is time, we finish, because it is getting very messy. So, which are the edges in the cut now? Is eight in the cut? No, it looks like it is in the cut, but it is not because, both its end points are in the same side. So, it is 9, 10, 11, thirteen also 12, of course. So, 9, 10, 11, 12, thirteen point So, 9 twelve is not in the cut any more. So, it is only 10, 11, and thirteen are the options, ten is the smallest and we that we are done. Because, all the vertices are now included. Everyone understands the procedure, it is very simple. We have done the proof effectively. Not effectively, we have done the proof. Because, what did we say? We proved this claim that the minimum edge across the cut has to be part of the minimum spanning tree and that is the edge we are picking at every point. So, this is the minimum spanning tree. You will get the same tree, since this is unique, I assumed edge lengths are distinct, you will get the same tree when if you were to run the Kruskal is algorithm. Everyone follows this? So, I am not going to write down the pseudo code for this, but you understand how the algorithm works. Very simple, so the key idea is that we have, so let us try and see how you would implement this algorithm? So, what is it that you have to maintain? Of course, you have a data structure for the graph. Now, what it, what is the operation you have to do at each step? Add a vertex to a set? So at some, at any point you have the following this is one side of the cut, your root is here. Let me call this set as S. So, the set is, this is going to be the set on one side of the cut, as in the vertices we have already reached, so to say, from the root. So, the root is always the part of the set S and the remaining vertices, S complement of V minus S. I have to maintain this collection of vertices which are on one side. This can be done very easily by keeping one bit with every vertex. If the bit is one then that means, let say it is on the S side, if it is 0, it is on the S complement side. That is very simple. Now, what is it that I have to do at each step? I have to find out, I have to look at all of these edges and to find the minimum. How and I am going to do this? you look at all of this vertices, you look at their adjacent edges, for each edge you see whether the other end point is in S or not. If it is not in S then you look at its length and you look at all these edges and find the minimum. So, how much does the time take? How much time does it take? Order, you are going to each vertex, looking at all its adjacent edges looking at all its adjacent edges, going to each vertex in S, looking at all its adjacent edges. What is the maximum time it could take? Order m at each step and you have n such steps. So, order m in time I am not even writing it down because it is a very. So let us do, look at something clever. What could be a clever way? Maintain a minimum? Let see, this is some idea so, you are saying I have this set s, I have s complement and there is this vertex V, let us call it V. I have a single this vertex out because this is the vertex which is now going to go from right to left. hndi You have figure out minimum of all of these edges, you know the minimum of these edges in the cut. Now, what is going to happen? V, let me draw it this way now. Some edges are going to go from v to S, some edges go from V to S complement, there are of course, some edges which go from S to S complement. Now, right now, I know the minimum of these edges because V is the same. This picture is the same as knowing the minimum of the edges. When I move V from here to here, I want to find out the minimum of these edges. What will I do? Compare the? So I just, suppose I have kept track of the minimum of these, noting else. Let say that the minimum was 1, the minimum has to be an edge incident to this one that you understand? So, that is why we pick this one. This is 1, this is 2, this is 5, this is six and this is seven and then these are 8, 9, three let say. Now, the new minimum, earlier the minimum was one and now the new minimum is two. If I just know the minimum, it is not going to useful. So, you want me to keep the track of the second minimum also? Which does not go to? But, what do I know about V as in, V something that I find out. So, we know the minimum that is coming to this vertex. So suppose, we keep the track of the minimum to each of the vertices in s complement. Insert V? So, what he is saying is, but how to, what data structure should I use to keep these edges? A heap? Min heap? So, that could be one possibility. I have a heap, does everyone know what a heap is? So, heap is the data structure which will and which I can put some elements, each one of them has certain priority or certain key and it will give me, I can use an operation called delete min which will remove the minimum element, I can find out what the minimum element is in the heap in constant time, I can insert element into the heap, I can also remove element from the heap. I can do all of these operations and except for find min, all operation take in log n time. Find min takes constant time. Everyone remembers at least this much. So suppose, I were to keep a heap here, a heap which contains these edges, 2, 1, 6, 5, seven. Then, using find min I can find out what is the minimum edge. That will, once I know the edge, I know the other end point of vertex, I know both the end points of the edge, I know which vertex I have to bring in. When I have to bring in this vertex, I look at all the edges incident at this vertex. The edges which are going in S, I have to remove them from this heap and the edges which are going from this vertex to vertices not in S, I have to add them into the heap. But, let us keep it clean. Like, when we say that our heap is going to contain the edges of the cut, let it contain only the edges of the cut, because you are going to spend the same amount of time in any case. We do not search in a heap, please remember, heap is a very bad data structure for searching. So, how do you find out where the edge is in the heap? Once again the same thing, when you put some information related to the edge into the heap, you do not just put it and forget it, you keep a track of where the information is, where the particular node is. We do not need to delete, but there is no harm in deleting also. No, you can also delete from a heap. Why cannot you delete from a heap? So, there is some confusion here. Let me back up a little bit. We need to, I think I need to show this delete operation to you again. When we do or the other class we will do delete operation once again but take it from me, you can also delete from the heap in the same log n time. Of course, to delete you need to know where the element is, you are not searching for the element, you know where the element is and then you can delete from the heap in log n time. So, that is what we are going to do. When this element comes in, I am going to insert 3, 9, and eight and I am going to delete 1, six and five and I know exactly where 1, six and five are and this is how I will do the implementation. So at any point, what does the heap contain? Exactly the edges of the cut exactly those edges and noting else. It is best to keep it clean so that you know what is happening. Now, how many operation are required on the heap? what kind how many? So, let us look at the heap operations. Let me draw the picture again for you. This is vertex V, it is coming in on this side. So, these edges have to be removed. These edges have to be added. Each remove and add takes log n time. How much time am I spending? Degree times log n for ever vertex that I process. So, degree of V times log n and then this has to be summed over all the vertices, because I will processes each vertex exactly once. Log n, number of elements in the heap, which could be m. So, I should write log m. Number of elements in the heap which is the number of edges in the cut, could be as much as the number of edges. All that it will ever may be that but it could be as large as then in the worst case. We are decreasing, but you know those are so small, that it will not going even if you do a careful analysis, you will still get the some order. This is what the total running time will be. These are not the only operations I also what have to do one find min. How many times do I have to do find min? Number of vertices time n times. So, n into order 1, constant time, that is a small order time in this one. What else we have to do? What are the other operations you might have to do in the heap? Just insert and delete and this operation, find mine. So, everyone understands what the procedure could be now? You start with your initial vertex, root and all the edges incident to the root will be your initial heap, will be the elements of initial heap. Then, you will do a find min that will tell you what vertex to include on that side. Then you are going to look at all the vertices adjacent to this vertex, all the edges that are adjacent to this vertex, beside, if you are to remove an edge or to add an edge. Let say, I have an array S. S in an array, S of V equals one if V belongs to S, zero otherwise. What is this S? This S is the S side of the cut. Not visited, but reached all those vertices that have been reached. So, this is one data structure we are going to have. Then, we are going to have a heap and let see what, so initially, I pick a vertex as the root and S of the that vertex root equals one and for all V, S of V equals zero. Initially, everything this is my initialization. Only the root is on, so, initially everything is zero and S of r is set one. This is my root vertex. Now, what should I do? I should insert the edges incident at the root into the heap. So, what should I do? For all e incident to r, do H that is my heap, dot insert e. Some such thing, I have to insert the edge into the heap. So, everyone follows so while not, I would say not H dot empty. do. Now, what should I do? I should find the minimum edge. H dot find min equals let say, this is equal to, what will this return? This will return in edge, and now what should do I with f now? I have to find the end point of f which is not in S. Let V be the end point of f such that S of V equals zero. For all e, e adjacent to v do. What do I do? For all e equals V comma W If S W equals zero then edge dot insert e, not w else H dot this is the spanning tree, minimum spanning tree. this entire thing is the part of the this loop. Clear to everyone? As you can see, all the effort is being spent in this step or not too much actually in this step. How many times is this loop going to be executed? n times? How many times is this loop, the while loop is going to be executed? n minus one or n times? n minus one times. Why, because every time I execute this loop one vertex comes into the set as n vertices So, this is getting executed n minus one time. So, this statement is executed n minus one time but, this is again just a constant time operation. So, this is not too much time. It is this way the most of the work is getting done. For every if you are looking at all the vertices adjacent to the vertex V, degree and for each one of those vertices or edges, you are spending, doing either an insert or a delete. Log n, degree times log n, you have seen that before, summed over all vertices will be m log n. There is a modification to this scheme that can also be done. In this modification, what you do is you have your set S, you have your set S complement. Each vertex in S complement has a number on it. What is this number going to be? Let us look at all the edges going from this vertex to S. Suppose, these were the three edges going from vertex V to S, suppose these edge lengths are 3, 4, and seven then this vertex is going to have a number of three return What are we going to do with these numbers? We are going to create a heap. Now, my heap is a heap of vertices and not of edges. So, this heap has one element for each vertex in S complement. What will be the minimum element in the heap? It will be the vertex which has the minimum edge incident at it among all the edges in the cut. So, it will be the vertex which has to go across. If I find the vertex the vertex which is sitting here at the top, the vertex with the minimum value, minimum label, let us call this labels the vertex with the minimum label let say, it is this vertex so, that means that the minimum edge going across this cut is one. We are not keeping track of edges which are here, within here. This vertex will only contain a label which is equal to the minimum of the edges which are going across the cut. If there is a vertex which has no edge going across the cut, incident at it so the minimum will tell me which is the minimum edge going across and that is the vertex that I have to move across and when I have to move across the vertex, what do I do? How do I update information? Very simple, this is vertex V all those in S bar which are adjacent to this vertex. The minimum edge that is coming to this vertex, so far is four. But now, this edge is also coming to this vertex, because this vertex going on that side So, that is the only things we have to do now. So, what is the operation we have to do on the heap now? Update what? Update or decrease? We will only decrease the label, decrease priority. Decrease priority is the operation we have to do. Decrease priority no insert, no delete. Find min, of course and decrease priority since, I have four or five minutes, let me write down the code for even this one point So, once again I will, as in the previous case I will have my array S, I will do the same initialization for all vertex V, S V is initially zero and S of r is one. Now remember, the heap is going to contain vertices in S complement. H is going to contain vertices in S complement. What should I put initially in my heap? Everything? Except r? So for all V, S V is equal to zero and let say, I do H dot insert V comma distance from r, what does that mean? What does that mean? Length of the edge from r? zero H dot insert No, no, everything is infinite only r is zero while H is not empty, we will do something. What will we do? We will take the minimum let say, that is the vertex V. I will take the vertex for all W adjacent to V do. If W is adjacent to V what should I do? If S W equals 0, what does it mean? W is on the S complement side. Then what should I do? Then I have to update its priority. Then if what should be the new, what is the option here? If, we will need a label array somewhere. If label of W which is keeping track of all the labels, so if label W is greater than length of V comma W then that means that this edge now, so what is it, what are they saying? then label W equals 6, sorry, equals length V W and H dot decease priority W comma label W. So, this is an alternative way of doing. So, the same running time complexity. You will check that yourself. Why is that? because, once again we are looking at degree, for spending degree time at each vertex and degree times log n, because decrease priority also takes log n time. Some over all vertices will come m log n and that is basically where most of the work is getting down so with that I am going to end today is lecture. So, we looked at Prim is algorithm for computing minimum spanning trees and we saw two ways of implementing it. 
</body>
</html>