<html>
<body>
Everything make sense? Are you guys good with Newton? . Yes, really? I am done. I am going home. Are you guys good with Karatsuba? . Kara what?  OK, so who is happy with Karatsuba? Good. Who is happy with Newton? Wait. I need to ask the other ones, because not enough people who is not happy with Newton and wants to look over it? Who wants to look over Karatsuba? Oh, so you guy are paying attention. Good. OK. All right. So Newton and Karatsuba. Let is start. So Karatsuba real fast, and then we will spend more time having fun with Newton. So suppose we do not know Karatsuba. We want to multiply two numbers. What is the method that we learned in elementary school? You take the first digit of the first number, and then you multiply it by the second number. And then you take the second digit and multiply it by the second number, but then you add a zero point And so on and so forth. So I will take this digit and multiply it with this number and write the result down here, right? So whatever this thing happens to be, 1, 2, 3, four times 8, write the result. Then I take 1, 2, 3, four times seven and add the result here and the last digits are zero point 1, 2, 3, four times 6, two 0s. 1, 2, 3, four times 5, three 0s. Then I add these up and I know that I am going to get the right result. What is the running time for this? . OK. So why is it n squared? Because you go through every single thing for every digit below. Yup. So I will have these partial products here, and I have as many partial products as digits in the second number. So if I have n digits here, I have n partial products. Each partial product is this first number here multiplied by a digit. So if this guy has n digits, then there are n digits everywhere here. And this thing will be two n insides actually, but we are doing asymptotic, so we do not really care about constant factors. So in the end, you have to add up n numbers. All of them are order n in size. So n times order n squared. This is plain old multiplication. Does anyone know why Karatsuba is better? Yes? You do three multiplications or something like that? OK. So, let is go for a simple answer. It is better. So the simpler answer is it is faster. OK. n, n log two I said better, it is faster. I mean, some algorithms have the same speed but are simpler. We like this one because it is faster. It is definitely not simpler. So, it has this running time here. Log two of three is a weird number. It is somewhere between one point five and two point So not revolutionary, but it is better than this guy. OK, why do we get to this? How do we get to this? Does anyone remember the recurrence for it? Yes? It is three times two You are not remembering it. You are cheating. No, I am not.  So, let is see why it looks like this. Karatsuba takes two numbers that have n digits, splits both of them up into two n over 2n, n over 2, n over 2, n over two and then is able to compute the product of these two numbers by only using three multiplications, and then some additions. Multiplications are expensive, additions are cheap. So it does three multiplications that are of the form some number of n over two digits multiplied by some number of n over or two digits. And exactly what the multiplications and what the additions are is, it is interesting to look over it. You can look over it, convince yourself that this is correct. Chances are you will remember for the exam and forget afterwards. Please remember this. This is the essence of Karatsuba. And remember Karatsuba, because if you google this, you get the rest. So the multiplications are in the notes. I do not think it makes sense to spend some time on them and convince you that, yeah, there are three multiplications that will get you that. Instead, suppose I labeled these as a, b, c, d. If I evaluate the multiplication as using brute force, it is a times n over 2b plus c sorry, a plus no, this is not good. ten to the power n over 2a plus b times ten assuming the base is ten, if it is not, you replace it n over two c plus d. And you get ten to the n times, I think, ac plus ten to the n over two times ad plus bc plus bd. The problem with this is this is a multiplication, multiplication, multiplication, multiplication. So this uses four multiplications of size n over two to evaluate the answer one multiplication of size n. And if I have four multiplications, then the recursion becomes 4t of n over two plus o of n. So this is t bad of n. So if you do this using the recursion tree, you are going to see that yup, I hear whispers. n squared. So this is not useful. This will give you insight on how to do it, but if you try to implement it this way, you do not get any speed up. The insight in Karatsuba is that the guy figured out how to do this with three multiplications. OK, makes sense? Is everyone happy with Karatsuba now? So that multiplying by ten to the n over two is just shifting a? Yup. OK. Very good point. So this is not an actual multiplication. If you have your number, say stored in a python list so if these are your digits, then in order to multiply by ten to the n, you append ten to the n 0s at the end. 0, 0, 0, 0, zero point So, this is append of zero n times. So this is order n, so it counts as an addition, not as a multiplication. So, these are free. These are expensive. 1, 2, 3, four point OK. Who is happy with Karatsuba now? Let me feel like I did something useful today. I have a question. Yes. I did not fully understand what. So, I have this number and I am splitting it up into two halves. The way split up is I say this is a number of size n over 2, and I have to shift it to the left. So n ten to the power of n over two shifts it left by n over two digits. And then I add it to b. So this in a sense is just saying that this is the left half, this is the right half. This is actually that same number. Yup. It is exactly the same number. OK, so who is happy with Karatsuba now? Wait, but that is four multiplications though. Exactly. That is not three. Exactly. But we said there were three. So, I was saying that this, if youre doing it the brute force way, you get four, and that is slow. So what Karatsuba did is he figured out the way to do this with just three multiplications. So it is not these three. You have to think a little bit more. But you google it, or you look at the lecture notes, or you think a little bit, then you find out the three multiplications that do the trick. So the difference between this four here and this three here is important. All right, anything else on Karatsuba? Cool. Let is talk about Newton. That is the hard stuff. And let me see how we are doing on time. OK, doing well. So does anyone remember the point of Newton? OK, so I heard an application that lets you compute square roots. What else does it let you do? . OK, we have Karatsuba for multiplication. You might be able to do it with Newton. Probably not going to be faster. But division, definitely. So square roots and division. So this is why we care about it. Now what does it do from a mathy perspective? So what is the mathy definition of Newton. Estimates Estimates? The value OK. So, we have a function. Suppose it looks like this. So, what Newton helps us do is it helps us find a root of the function. And the root is a value x zero so that f of x zero equals zero point So this is what it does. So when you want to use Newton, you have to set up your function in such a way that your answer is a root. OK. How does Newton work? Yes? You start at some point where you actually know the answer to it, and then you kind of draw a approximation. So you are just drawing a line from the point to the root, and then just incrementing down that line. OK. So we start at some point, right? How do we call that point? Initial guess. Fancy name. So we have an initial guess for what the root might be. It is not going to be the right answer, because otherwise why am I bothering with this? But it can be too far off. We will say that if you are too far off, you are not going to converge or you are not going to converge fast enough. So say we start somewhere here and, we think, you know, this is pretty close. It is not quite there, but it is pretty close. What I do from here on is, you said I approximate this function The line. Yep. So what is of the best line? The best way to approximate the function with the line is to use is the tangent, right? So here, it sort of looks like this. And if the function were linear, this would be a perfect approximation and we had get answer in one step. OK. So this is the tangent. And then what we do with this tangent? Well, after we get the equation for it, then we find the root, right? Or no? Well, I ca not find the root right away. The root of that line. Of our tangent line. OK. So we find the root of the tangent, which is the point where it hits the x axis. And what happens with this point? . OK, so this is our next guess. And then we trade. So then we draw another tangent, and the idea is that eventually, you are going to get there. And if we go through the maths, we will see that you actually get there pretty fast. So that is why we like this method. So let is see how we convert this drawing thing into an equation that you can write into python. Let is label these quantities. So, x2, x1 actually let is not use one and 2, because these are the first two guesses. Let is say our current guess is x and the next guess is x prime. So this line and is x1 minus x, so this guy over here. And what is this guy over here? f of x. Do not be shy. It is the right answer. So I have f of x here, x one minus x here. I also have this angle here, and this angle here is the same angle as the angle here because both of these lines are horizontal, so they are parallel. So what do I know about this angle? It is tangent. It is tangent. OK. The tangent, that is called the angle alpha. What is the tangent of the angle? . Sorry? F of x over x. I think you are trying to give me the formula for x prime. Just the tangent. Just the tangent. Oh. Right? Can someone reassure me? This is right, right? AUDIENCE AGREES I was thinking the slope of the line. OK. So, yeah, you are going to give me the slope of the line which lets me compute this. OK, I was looking for this. OK. So now, let is get what you are saying. So this is the tangent, right? So, the tangent at a point of a function is the function is derivative. So now we are going to write all these things down and hope that we get an equation that make sense. So we have the tangent of this guy, also happens to be this over this. Right? This is a right angle triangle, so the tangent is f of x over this is what you were trying to tell me, right? x1 minus x. So now I know that this is f prime of x. OK. So, we look at the picture, we put in everything we know, and then we write an equation here. And we solve for sorry, this is x prime. So, if we solve for x prime, we are going to get x prime as a function of x. And this tells us, given a guess here, how do we compute the next guess? So once we have an initial guess, this lets us make the guess better and better and better, closer and closer and closer to x0. So, let is solve this equation reasonably quickly. x prime minus x equals f prime of x over f of x, so x prime is Does it matter if it is x minus x prime or, because technically it is x minus x prime. Yeah, it matters, because you are going to get the wrong sign. Which is exactly what I am about to do here. Oh, OK. So, I am not going very well, right? This is wrong. Yeah, it is because you flipped your x at your prime x minus x prime instead of x prime No, I think it is because f prime of x is on top. It should be on the bottom. In the second no, third equation. Should not those be flipped? Because if you move the subtraction, x prime to the left f what? f of x over f minus x instead of f prime x over f of x. Yeah, there you go. OK, so I can do math. OK, so that is one issue. There is one more issue. So, there are too many issues here. Issue number one, this. Issue number two, I got this wrong. Oh, we get a negative number. 2x minus x prime. Yep. So the reason for that is we are going Only if you start from the right, though. Yeah. If you start from the left, if your guess is to the left of the actual root, it may or may not be different. OK. So our guess should be to the right. So this is x minus x prime. So the reason it is x minus x prime, the way you remember this and you do not do the same mistake that I did is, you want to walk against the derivative. If you walk in the direction of the derivative, it is going to move you forward, right? So, if you go in the direction of the derivative, instead of going backwards like this, you are going to go forward like this. So you are going to go away from the solution. So, this will take us in the right direction, and this means that it is OK. So two ways to remember this. One that you are going against the derivative. Another one is that you have your guess and you are subtracting something from it. You flipped your primes again. Again? Jesus.  I mean, I agree, the prime looks better on top part of the fraction, but still. OK. Well clearly, my hand thinks the same thing. So this is you had iterate using Newton. So the way to remember that the signs are right is your x is somewhere here, and you know you have to subtract something from it so it looks like this figure. And this actually works in all the cases, turns out. Our guesses are usually smaller than the actual number, and this still works. OK, so let is go over Newton. What do we have, or what do we need in order to make Newton happen. So we need to be able to evaluate this, right? So we need to be able to evaluate f over f prime of x for any x that Newton gives us. And for Newton, this is a black box. So whichever way you use to implement this is fine, as long as it works reasonably fast. OK, what else do we need to use Newton. We need to remember this formula Let is start with something easy. Suppose we want to use it to compute a over b. How do I do that? What do I need? You need a line, a tangent line like you did before. Well, that is already taken care of here. So we have this, and we know that we will have to compute this and plug it in here. So, what do I need to compute ab using Newton? So, I need the function, right? This thing. I ca not say it is something, I have to figure out what it is. I guess I was confusing because I said assume we have this. Well, sorry. We do not have this. We need to figure out the function so we can evaluate this. OK, so we need to come up with the function so we can evaluate that, and what property does the function need to meet? . Yeah, that would be nice, right? So we want the function so that f of ab equals 0, because that is the number that Newton will give us. And we also need to be able to compute f over f prime of x without doing any division, right? If we did the divisions, it does not work. OK, so the first thing we are going to do is we are going to simplify this problem to one over b instead of a over b, because if you know what is one over b, you are going to multiply this by a, and you are going to get a over b. Suppose we work with integers and we do not want to touch floating point numbers. What would we actually compute? You shift it out, right? To get that 0. 23, shift now to. All right, all right. So one over b. Unless b is 1, in which case it is really boring. one over b looks like this. zero point something. This is not an integer number. I do not like it. So what I do is, I decide that I am going to need digits of precision, and I am going to shift the decimal point right by d digits. So instead of zero point something, it is d digits here point something else. How do I do this? Multiply by ten to the d? Multiply by ten to the d. So instead of computing one over b, ten to the d over b. And we call this ten to the d R in our station notes. So we are going to compute R. Over b multiplied by a, and then everything divided by R. So we talked about how you multiply by R. How do you divide by R? So, if I have a number with n digits and I want to divide by ten to the d, how do I do that? Shift. Shift right. If the number is a python list? Slice it. Yep. So kill the last d digits. So, if I add d digits to the right, I multiply by ten to the d. If I slice the last digits, I divide by ten to the d. So this is division, this is multiplication. And the reason I care about that is this is going to be an easy division, and whenever I have this, it is an easy multiplication. OK, now what function am I going to use? Does anyone know? Can I use x minus R over b equals zero? Sure? Well, so, this is f of x. f prime of x is what? Just negative R over b. Or no, one point OK. So, f prime of x over I think you switched it again.  Thank you. Because I was running ahead, and I was like, OK, this works. Why does it work? OK, so this is going to be x minus R over b, right? Can you evaluate this? If I ca not evaluate this, I already know the answer. Your prime is not on the bottom one. So, it is x minus this divided by one point So, it is this. So then, if you are trying to evaluate this far the guesses that Newton gives you, you ca not. Because if you could, you had have the answer already. So we ca not use this function. This is a nice and easy function that does not work. So while I erase the board, one minute, someone figure out the right function. Sorry? . Man, that is hard math. No, that is too hard. That is too hard. OK, let is try this. Let is try instead of x minus R over b, let is try this 1x minus bR. And the intuition behind this is if I have to compute bR, I can do that. Right? It is an easy division. If I somehow get rid of 1x and all I have to do is compute bR, it is an easy division. Because dividing by two to the R by R means you are going to shift by some digits to the right. So let is see if the math works out for this function. What is f prime of x? Negative one over x prime? All right. Like, does no one know it? At least one student has to know it. OK, so f of x divided by f prime of x is what? Negative x plus x squared bR. Plus x squared b R. Yeah. Is this right? Yes. OK. So if I have my initial guess so if I want to get x prime, x prime is x minus f of x over f prime of x, right? So, what is it? 2x minus x squared over R. OK. Did this work? Did it get rid of all the hard divisions? LAUGHS Please nod so I know we are good to go. Tell me if we are not. So how many divisions did we have here? One division, this guy, right? But that is a shift. That is a shift. Because R is ten to the d. What about the multiplication? So, we know how to do multiplication because we learned Karatsuba just now. So we wanted to get rid of division, because if you are trying to solve division by doing division, it is probably not I am going to work unless you are doing divide and conquer. OK, so this is how it works. I am not going to run into the error formulas for this because I want to do another case first. You can keep going on this and it is in the notes. The only thing that is useful to remember is that we use this trick. So, I want to look at this function, square root three of a, and I want to use Newton to compute it. So this is the third order root. It is not the regular square root that we had before. So we are trying to not be boring and not just repeat what is in the notes. How do I do this? Let is walk through the steps. So what is the first thing that we do? Very good. Look to the right. Find the first step, and let is put it here. What is the first step. Function f of zero at cube root of a. OK. So we need a function f so that f of good. So before we start writing the actual function, what if I want to compute cube root of a up to d digits of precision? So if I want to compute cube root of 2, this is going to give me numbers that are below one point I have to do with fractions again. I do not like that. If I want the digits of precision, what do I do? . Jumping ahead. But yeah. So you have the right answer, but you are speaking slowly because you are afraid you are going to do a mistake, right? So, the way to compute this to d digits of precision ten to the d, right? This shifts the dot to the right. So I have to get this ten to the d inside here, and I get and to the 3d times a. Perfect answer, by the way. Do not forget this three here. If you do, you are going to get something else. So now I take this guy, and this is the new number whose cube root I have to compute. Cube, cube, cube. OK. So I can do this in integer land, and then I will get an integer result, and I shift it right by d digits, and I have a number with d digits of precision. Does this make sense? OK, what is f? . Let is go for that. Let is see if that works. x cubed minus a. Well, let is pretend. We are going to make this b the new a. So let is not to worry about this. This happens somewhere else. We went through it so that we know that we know how to deal with it. And now we are going to forget about it. So, it is x cubed minus a. Because we argued that this is an integer, right? So we do not have to do anything fancy like dividing by R that we had to do over there. So, what is f prime of x? OK. So, iteration? How do we iterate? x prime? Let is start with x prime equals x minus f of x over f prime of x. Right? Nice and easy so we have it here. And this becomes minus copy these two things, right? x cubed minus a over 3x squared. OK. Next thing, I bring this guy under the denominator, so it is 3x cubed minus x cubed plus a over 3x squared. So it is 2x cubed plus a over 3x squared. So this is 23 plus two over 3x. You keep saying cubed and writing two point Yeah, that is better. Thank you. Plus 13 times a over x. So this one is division. x squared. x squared. Ouch. So this guy wants division. By the time I do this, I better have division ready, right? OK, so that my iteration. x prime is 23 x plus 13 and a over x squared. What else do I need? An initial guess would be nice, right? I ca not do this if I do not have the first x. So let is try to think of a starting x that is reasonable. The better it is, the faster it is going to be. So let is try to come up with something reasonable that does not require too much thinking or too much. . Too much work. I have to compute a square root. So what is a? Let is start with that. What is an a, right? So, it is an n digit number. And say the digits are d1, d2, d3, all the way up to dn. So what is a good approximation? Well, the first approximation for this? You get a third as many digits. A third as many digits. OK. So something times ten to the n3. Let is say that something is 1, right? So this is the first approximation. It is the right order of magnitude. Do people see why this is a good approximation? So this number, whatever it is, it has to be between 1, 0, zero 0, 0, and 1, 0, zero point OK. So generally when we do this, what we have to have in an approximation is the right order of magnitude And maybe the first digit. If we can figure out the first digit, then we are in a good shape, or something really close to the first digit. How would we get the first digit? Cube root of the first digit? OK. Sure. How do we compute this? Get a formula? . OK, so I am not going to argue with that. I like that. So I want to reject the recursive argument first. So this is going to be small, right? This is going to be ten if you are working with digits, or if you are a computer, maybe it is 256, or maybe it is two to the sixteen or two to the thirty two point Not much bigger than that, right? Pretty small. So these algorithms really good for big numbers. Algorithms that are complicated but have nice asymptotic complexity are good for big numbers. They are awful for small numbers, as in they ten to one hundred times more times to run. So let is not to do that for this, because it is like bringing a tank and shooting it so you can hammer a nail in. Not the right tool. So, precomputed list. I like that. It is an option, especially if you are right? You can use pen and paper to get it. What if I do not want to do that. What if my base is more like this.? . So this is a very good solution. I am not arguing with it. If your power is this or this, by all means, use a table. So let is see what do we do here? I just want to think a little bit more. . OK, so there is some approximation that comes from math that says that d1 over three is not going to be such a bad guess. Now let is be CS people and do something better. the exponent. two to the 14, divide is that 14, right here sixteen point sixteen point Divide sixteen by three point Or I guess that is not quite right either. So you are saying two to the power of, say, 5? fifteen over 3? It does not seem quite right. So, let is try to do better. This is math. Let is just try to do it in a CS way. So we are trying to guess a digit between zero and two to the sixteen point I heard an oh. Yes? You had your hand up? No? OK. You take the current time two to the sixteen point I mean  So your algorithm is going to be fast with some probability, right? No, that is terrible. Let is not do that. Please do not make me grade code like that. Did you already cut out the recursive option? Yes. Yeah. Well, so I do not want to recurse on square roots. But you could recurse on that one. I mean, if you give me some algorithm that happens You are already. OK. So, what is the intuition? If you have a computer and you have register, bytes, bits, whatever. You do not know how to do square roots. That is not an instruction, but these are all instructions. Right? So if I have a guess, say I start with half and then I get my guess, what do I need for the binary search to work? Given a guess that is somewhere here, I have to be able to say whether this is too small, too big, or just the right number. So given a guess, I can multiply it by itself three times, right? Compute gets cubed. And I can see how does it compare to the number that I want. So I have the first digit, and I have an order of magnitude. Not bad, right? Pretty good initial guess. This is as much of an answer is you need to give out in physics problems, and you get full score, so that is good. OK, how are we doing so far? Following along? If we compute our guess cubed, we want only to compare it to our original number to see how close it is? Yup. And, do we just keep on doing that until Well, so you are going have to guess a digit, right? Between zero and two to the sixteen point So you choose the largest thing that is smaller than your guess, or something. Or until we get the first digit. Yeah. Just the first. And then you have a first digit, and then you have an order of magnitude. And then you feed that to Newton, which converges way faster. So you could the binary search for the whole thing, but that would be slower than Newton, turns out. Yes? So where had you get the f of x here? I am missing that stuff. Oh. Yeah, right there. Someone told me to use this.  One of you guys told me to use this. Well, so I tried it out. I put it here. And then I computed the derivative, and I looked to see if this looks reasonable. And this looks like something I can compute. And why was that reasonable? Because I know how to do the division and multiplication. So, say if I would have had the square root of three in here, that would not be reasonable, right? Just like before. When you are trying to compute division, we ca not have division. If you are trying to compute sine of x, you do not want to have sine of x. OK. and computing a over x squared is reasonable? Because we did it before. OK. So then you might use something else, maybe? Yeah. You can use something else as long as you know how to do it, and as long as it is reasonably fast. OK. Yes? . Oh, no that is fine. Oh, that fine? OK. So, the binary search is fine to get the first approximation. But after that so I am not going to do a binary search for the whole result, because Newton is faster than that. I am just using this so that I have a decent guess to pass to Newton. And we will see why we need that decent guess in two minutes total. So I am going to try to spend two minutes to explain how the error thing works, and you will have to look at the notes and make sense out of the rest of it. So, let is see. Errors. So with Newton, you start to with an initial guess, and then you get to a better guess, and a better guess, and a better guess, and so on and so forth until you are satisfied. By the way, if we are doing this one, are we satisfied? What do you mean, like, finding the guess? Are we satisfied? Oh, no. So, we have the initial guess. And we keep applying the formula that I just deleted to iterate. When do we stop? When we have enough digits of precision? So how do we know when we have enough digits, if we are working with integers? We iterate again and nothing changes. We iterate again and nothing changes. So I am computing do I have this anywhere? Oh, no. I erased it. So I am computing ten t0 some oh, I had it up here. So, I am computing ten to the power of d times a square root of 3, because I want to work with integers. Just integers. I used Newton to iterate. My precision gets gets better and better and better. And I use integers. So I only have d digits of precision. Everything after that gets discarded automatically. When I get two x is that do not change so if I get x5, and then I run the thing and then I get x6 that is equal to x5, there is no point to keep running Newton, right? Im stuck. And I am also done because I have the answer with d digits of precision. So this is where I stop. OK. Now, my precision is how far I am from the right answer. And we write that by saying that x1 is x, the true answer, times one plus epsilon, epsilon one point And then x2 is x times one plus epsilon 2, one plus epsilon 3, so on and so forth. Right? So, if we had a lot of time and not too much stuff to do, I could copy this thing here that we have in the notes. That is eight lines of math. And then we had get something along the lines of x of i plus one is x times one plus something times E squared I am sorry, Ei squared. So this is also one plus Ei plus one point So what we get is that E of i plus one is roughly E i squared. And this is what is really called quadratic convergence. Now why is this good? Can anyone think intuitively why this is nice? In which cases? Yes? You are converging really quickly to your answer. OK. But when do I converge? , So what I want this to happen? What do I want this to be? . Well, you guys told me everything I need for the next two minutes. So, I want this to become 1, right? This has to go to one because I want this whole thing to be x. So in order for this to be 1, I want to epsilons to go to zero point So I want them to be as small as possible. Now, you said that if my epsilon is smaller than 1, then epsilon squared is smaller than epsilon. And intuitively, how this works is, suppose you start with an epsilon of 0. 1. When you square it, you get 0. 01. You square it again, you get 0. 0001. Square it again. 0. 00000001. OK. This is step 0, step 1, step 2, step three point How many digits do I have here? Do not be shy. two to the i? Yup. two to the i. So this is going to be equal to this when one plus x times one plus epsilon i over one plus epsilon sorry, i plus one epsilon i when the floor of this thing is sorry, there is a delta somewhere here. So, something has to converge to zero point Sorry, this is what it is. one plus e of i. So this is the difference between two terms, x. So this is x6 minus x5, right? Convincing? . Let is write it again. Let is write it again. This is out of hand. So, x, x minus x5, or actually, xi plus one minus xi is equal to x times one plus epsilon i plus one minus x times one plus epsilon i, right? So this is x times Sorry? Those are xi, x of i. No, those are the real x is. These are so these are the approximations, but then, this is the real x. I understand, thank you. OK. So, this is, the difference between them is this guy here. So if I take the floor because I work with integers, when this floor becomes 0, we are done, right? So in order for the floor to become 0, this guy has to be canceled by this guy. So this guy has some number of digits, whatever that is. It is my number with d digits of precision. Well, that is OK because where my 0s? Did I erase my 0s? Oh, no. I have 0s here, right? The epsilons have a lot of 0s in them, so the 0s are going to cancel the digits in x. So as soon as I have enough 0s here to cancel this, I am stuck. The number of 0s increases exponentially. So in each step the number of 0s I have doubles. So after log d steps, I am done. If I have d digits in here, because I am computing this with d digits of precision, after roughly log d steps, I will have enough 0s here to reduce this and make the whole thing be zero point So this is how I know that it is fast. So in the end, what you want is the initial guess has to satisfy this, and then you want to be able to prove that this is true. So you want this factor here that tells you you are converging fast. So when you look at the recitation notes and you look at this long string of equations, make sure this is somewhere there, because this means you are on the right track. Yes? If it takes log d steps, does not the binary search also take log ah, OK. Log ten steps. Got it. Yeah. Which is d. He is talking about binary search Oh, for one digit. Yeah. Oh, sorry. I thought you meant for the whole thing. So if you wanted to do binary search for the whole thing, that is log of the whole number. So that is order d where d is the number of digits. Wait, he is talking about a binary. . wants to go for, ten to the 20th. He wants to do a binary search over like a cube root So, for this? Binary search for this or for one digit? Or binary search to compute the cube root? I think, yeah. So, if you do that, your entire thing is d digits, right? So ten to the d. Binary search takes log of ten to the d. Right, yeah. So the numbers that we are dealing with are d digits. So this d is the number of digits, not the number that you have. So if you look at the number that you have, this is log log n. Right, that makes sense. Sorry. So, it is faster. I like it. It is faster. OK. Cool. Thanks for the lesson. . 
</body>
</html>