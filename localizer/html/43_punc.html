<html>
<body>
OK so any pointed questions before we go over blackjack? Before you start blackjack can you go through the rules again? The rules of the game? Yes. OK. Well I am going to do something better than going through the rules. I am going to abstract the rules away. So I am going to say that a game of blackjack has, let is start here. So a game of blackjack has a deck. And we have x ray vision or some other illegal way in which we know what the deck looks like from the beginning. How many cards in a deck? fifty two point OK. So say from zero to fifty one because we like zero based indexing. So the way that the game starts is you get two cards, the dealer gets two cards. What is the only decision that you make in the game if you already have perfect information? So you know the deck already. You do not need to wait for each card to know what it is going to be. So as the game starts you have to make one decision. What is that decision? Hit or stand. Well that is assuming you care what you get each time. So if you have to look at the card then you have to decide each time if you hit or stand. If you know all the cards in advance How much to bet? I think our game has that fixed. When to restart? So it is hit or stand, but I want to restate that. Because you do not actually have to decide after every card if you want to hit or stand. You know what the cards are going to be in advance. When to restart? Like how many cards to pick? How many cards to pick. Yeah that is pretty much the same thing. So you do not have to decide every time hit or stand, you know ahead of time I want to hit three times, or I want to hit once. Because you know the entire deck. You do not need to actually look at the cards. So each game the only decision that I make is suppose this is one game the only decision that I have is h, how many cards I am going to hit. Right? And then after I make this decision the game will eat up some cards. I get two cards, the dealer gets two cards, then I hit some cards then the dealer gets some cards. And this is the number of cards that have been consumed. Some number of cards that were played in this game. And the other thing that comes out of it is how much money I make. For our simple rules it is either I make 1, or nothing, or I lose 1. Fair enough? Everyone follows? So I am going to abstract all this in a helper method. I am going to say that I have a method called round outcome. Where I say, look out of the entire deck I am going to start at card i, so this is where my round starts. So I tell it which cards I start at. And how many cards I am going to hit. And it gives me back a tuple, where the first item is how many cards are played. So number of cards played. And the second item in the tuple is how much money do I make. h is how many cards I am going to hit. So i says that I already played this many cards in previous games. So a game starts with a full deck. And then I play some rounds. Each round I do a whole exchange with the dealer, where I hit some cards, and then the dealer hits some cards. And then I win or lose some money. I do not understand why h and cp are different. So cp is how many cards are played in total. And this looks at the initial cards. So first I get two cards, the dealer gets two cards. And then after I hit some cards the dealer also has to hit. And the dealer has a pretty find algorithm, right? So the number of cards played includes the cards that were dealt initially and the cars that the dealer has to hit. So this little thing has all the blackjack rules encoded in it. Everything is already there. So blackjack, that is roughly 2h? cp is 2h, something like that? four plus 2h maybe. Because you get two cards, he gets two cards, and if you both deal h on average then So is cp the number of cards this round? This round, yeah. OK so intuitively I already know, so I already know the entire deck. So the decision that I have to make is, would I play optimally every round? Or do I want to maybe lose the first round and leave some good cards for later? So I have to figure out how many cards I am going to hit each time so that overall I make the most amount of money when I leave the table. And when I run out of cards I leave the table. The dealer says shows over, gotta go. Do the rules make sense? OK so I propose we approach this in two ways. First we model it as a graph problem, because we have already done this a few times. And then we model it as a dynamic programming problem. And we see how the two are related. Make sense? Is this too simple for everyone? You guys already get everything? So how would I model this is a graph problem? Do you already know the order that you are going to get all these cards in? Yep. So I in lecture we briefly talked about having your starting node go to a bunch of other nodes that would be your potential next move, and then you just calculate your shortest path distance from there to the x value. So that is the general approach. How do we do this for cards? So what would be nodes? What are the most intuitive nodes you could think about? OK maybe intuitive for me. So nodes show our state, right? Show the state that the game is currently in. Sorry? Your hand. Like your current cards. Is that your state? So from I guess two to ace. From? From two to ace, in terms of the number of choices you have. OK so the problem is you have four cards of each type, right? And you do not know where they show up and everything. So I think this my code more complicated than it needs to be. Like the rest of the cards in the deck that are remaining? OK. Is that a good? How many cars I have left in the deck, right? So basically I would have one node for each of the cards here. And that says I start a new game at this card. OK so I am going to draw some circles. Say these are our nodes. Maybe I draw a bit too many of them. Where do we always start? The left side. First one, right? We start with fifty two cards. So circle zero means that we played zero cards, we have fifty two cards left. When do we draw an edge between nodes? What does an edge mean? That is how many cards you have chosen, so the number cp. OK so the number cp. It means I played a game, right? So one edge is a game. And it goes from one state to the next state. So if I am, say I am at node i. How do I draw the edges? Say I am somewhere here. So I already played i cards. Iterate through all h is, cp is. OK. So for h in what to what? What is the smallest h? The smallest h is one point Really? Do I have to hit? Wait is not it 4? Because you are always dealing out four point Yes, so I might as well not count them, right? So h is how many cards I hit after the initial ones were dealt. So that I can start at 0, a nice and easy number. And where do I end? Rough approximation. You could go to zero and then break. It is still eleven because eleven at most oh no, eleven minus 4, six point You need to know the rules of the game. OK if you know the rules of the game it is that. If you do not know the rules of the game it is fifty two minus i. OK so what is first thing I do? So how do I draw an edge representing a game where I hold h cards? So you draw an edge from your current place to the output of round outcome with the zero element. So then let is store this output somewhere. Let is say o is round outcome. What do I give round outcome? i and h. See I picked good names. They are exactly what I have there. So I draw an edge from i to what? To the output of round outcome, which is o. So it is zero point OK. Or that the node at o is zero point Yeah. So suppose I am at i and I have already played five cards, right? So say i equals 5, for example. And I know that if I hit once the dealer will also have to hit once. So in total I have played six cards. And suppose I won. Then the output would look like this. six cards were played and I won. So plus one point So I would draw an edge from five to what?  OK, from five to eleven hopefully. So what is 11? eleven is five plus all of zero point OK, what am I missing there? i to i plus. Yep. So this tells me how many cards I played in this game. I want to look at each game separately. I do not want to have to keep track of previous states. So this output is localized to this game. It tells me how many cards have been drawn in this game in total. And how much money I made in this game. If I already played i cards before starting the game, after I play all of 0, the total number of cards is i plus zero point Tiny detail, but you had probably lose a point off of an exam or something if you forget it. OK so keep track of your state. It makes sense to write down this is my state, and then make sure that you are always representing it. So what is the cost of the edge? And then our answer would be what path do I want? I want to make the most amount of money, so that is the longest path. How do I convert this to a shortest path problem, because this is what you know how to solve? Where I put it? There. Good answer, there. Right there. OK so this builds the graph, then I run some algorithm on it. What is the best algorithm I can run on it? Dykstra because you can. But you can add everything on. The lowest negative edge weight is 1, or negative one point Are there negative cycles? No. Everything goes right, right? So even if I do not get hit any card, at least four cards will be played. So all these arrows go right. So then I heard a fancy term that I like. Can someone say it again? What is this graph? DAG. DAG. All the edges go one way. So this is a DAG. And that means that I can run what algorithm? Sorry? . Topological sort plus DFS, the one that we talked about last time when everyone was out for Thanksgiving. So you have to believe me that it exists, or look at lecture notes. So top sort plus DFS will give me the shortest path in order of V plus E. So this is better than Dykstra, which is E plus V log V. OK? OK I am guessing most of you do not know how that algorithm works. Well good news, we are going to do this using dynamic programming. So we are going to represent the graph implicitly. And we are going to write everything without needing to know the algorithm. If you know it, it helps because you can see how they relate. But if you do not we should still be able to solve the problem. But before we do that, does everyone understand this? Some nods would be nice so that I can feel good. Yes? Almost? OK. Questions? Like the number five there, that is only if you hit, right? Or that is the number of cards remaining. Is there a particular reason you picked 5? So I was choosing an example for i. So good question, what does i mean? So this means I am assume that I am starting a game. So starting sorry, a round. A new round. And I have already played i cards in the previous round. So I started a new round and the first five cards are out of the deck. What is the best strategy I can have? What is the most money I can make? But there is some nodes that connect to the next card over that wo not necessarily end the game, so there are not going to be any earnings, right? You could have five connect to 6, and that would not Here I am just trying to emphasize the point that all the edges move, all the edges point forward. But yeah, the edges have to go at least across four nodes. So assume there are some more nodes around here. OK. Yes? You were saying how you have to be careful with something or else you will lose a point. What was that? How you draw your edges. Or when we switch to dynamic programming, what you write in your recursion. OK so last chance to ask a question before we do a conceptual jump and use another algorithm. OK how do we do this using the dynamic programming? So what are we going to have instead of nodes? Sorry? Well so you still have states in both cases. But here you represent them with nodes in a graph. In dynamic programming you represent them using yeah, the states are basically sub problems. And what do we, when we compute stuff, what do we use? Numbers is a vector or in a matrix. So there is no graph to work with. There are no extra algorithms to call. We just straight up compute to the numbers, we trade the answers to the problem. So we are going to have an array. How many elements in the array? Can anyone guess? All right, I heard fifty two point If I am at element i, say i equals five because we used that before, what does this represent in the dynamic programming formulation? It is very similar to node five there. So what does it represent? The fact that we are starting a game after we played the first five cards. Sorry, we are starting a round after we have played the first five cards. And we want to maximize our earnings from here on. So then the problem is, how do we maximize our earnings starting here? So given that the deck has these cards, so the cards from five to fifty one point What is the maximum amount of money we can make by playing optimally? So maximum number of money we can win by playing optimally, starting around at card i. Starting at i. So if I want to compute this by the way, speaking of bad variable names, we did this before. When people do not know how to name this array they name it dpi. I think we did that in our PSet. So this is the most useless name you can have for the array. It just tells you that we are using dynamic programming. But it does not really tell you what it means. So we are going to go for it, because it is nice and easy to write. So if I want to compute dp of i, how do I do that? x problems. OK, so what are the sub problems? The function at i is past five where the i is are through this manner. OK so I had want to have something very similar to this, right? What are my decisions? So what are my choices? What do I iterate over? How many hits. Yep, exactly the same thing as before, right? Starting a node at i. I was starting a node at i here. So the choices are exactly the same. So I am going to start by looking at this line. Do I need to make any changes? Or do I copy straight over? So this is the algorithm for computing dp of i. For i in zero to fifty two point Sorry h in fifty two minus i. All right. I hope we can do a bit better than that. So we know that it is a max of 6, right? So can we just put that in instead? That is given the rules. Sure. If you are smart you can. I am not, so I am just writing this. So this helper function that I have here, that I call the magic that implements the rules of bag check will save me. So if I say that oh, I want to hit ten times, and that is impossible, then it will probably give me an earning of minus infinity, which makes sure I never choose that path. So all that is hidden in there. You are smart enough in blackjack so you can write six point I am not so I ca not. So fifty two minus i. OK what I do next? Do I copy this next line? Or do I change it? Yeah let is copy it over. Sounds good. How about this? Do I copy this? Trick question. Come on guys. So do I copy this line or not? Do I have a graph here? Can I draw edges? OK so I am not going to copy it. What do I do instead? By trick I mean easy. So what do I do instead? I compute my answer directly. So if I hit h cards, what am I looking at? Do you mean like a function? A function, sorry? You add the dp of o one or of o zero point OK so first let is see if I have i cards, and say I hit, I do the same exact thing that I did before. I look at i is five and h equals two point So then that function gives me the same answer, six one point So then I know that after this I am going to end up in a state where I played the first eleven cards. So I am going to end up at eleven point How much money did I make overall? OK, so one in this case. So how much money I made is o of I think it is o of one point And after I land here, how much money I am going to make? Assuming I am still playing optimally. . dp i plus. . OK. So i plus o of zero is used to compute so dp of i plus o of zero is used to compute dp of i. This is the same thing as dp is a function here? No. So you are wondering what the hell? Why will that work, right? Let is get to that in a minute. That will work, we have to make it work. So here I am drawing an edge from i to i plus o of zero point And the cost of the edge is minus o of one point So here we are looking at edges. Here I am assuming that they already computed the answer here using some black magic. It is already available. And I want to compute the answer here. So I have the cost of the edge plus whatever I had here. So if, suppose I know that if I start here and I finish the deck, I can make 20. So suppose I know that this is twenty point What will the answer be here? one plus twenty which is? So if I hit how many times did I say there if I hit twice I guess I will make twenty one point So this is a possible answer. And I have to go over all possible answers. So this is how much I am making if I hit h cards, right? Now I am looking at multiple choices here. This is the answer for each choice. Which answer do I want in the end? The largest. OK. So let is say I am going to start with a choices array that stores all the answers. So here I am just going to pend the answer, the possible answer. Choices append this guy. And then at the end of the for loop I am going to take the max of choices, and I am going to assign it where? . So I promised I am going to compute dp of i. I just finished computing dp of i. Now there is a little problem here. In order to compute this guy, I need to already have the answer for this guy. And maybe for some other guys here. So an answer here depends on future answers. The arrows here are the same as the arrows here, right? They represent possible moves in the game. At the same time the arrows here represent dependencies. This answer depends on this answer, this answer depends on this answer, so on and so forth. When we hear the word dependencies what do we think of? Topological sort. PSet, which one? PSet six still brings painful memories? Not anymore. We have a new one. So in order to compute this I need to compute the answer to a few other sub problems. To make sure that I have these answers ready by the time I compute this. So to make sure that this code does not crash I have to compute all the answers to the sub problems in the topological sort order. That is where topological sort fits in here. What is an obvious topological sort, if all the edges are pointing this way? . Yep, thank you guys. So start at the easiest problem. What do you do if you have one card? And then go look at bigger and bigger and bigger problems, until we tackle the hard problems of what I do with the entire deck. So when I compute this problem I am going to go to iterate how? From where to where? fifty two minus i to the zero point You are actually So this is i. Oh, that is i. So where do i go from here? fifty one to zero point All right. So now whenever I access this guy I know it is already computed. So the code is not going to crash. OK and this thing is my topological sort. So the advantage of this is that the code is a lot smaller, right? Here I am building the graph. So I am calling some graph methods. And then I would have to have the code for computing the shortest path in a DAG. And then I would have to have some code for extracting the answer using that. Here this is all the code. It is a few lines. And it is because the graph is represented implicitly. The topological sort is represented implicitly. The edges are represented implicitly. So this looks like magic. But if you know where to look you will find the items. You will find the things that tell you what the graph looks like. Yes? So that tells you how much money you can make, but does it tell you can How you make it? Not yet. Parent pointers. Yeah that is a good point. Let me see how we are doing on time. OK. I can talk parent pointers. Am I missing anything else? There is one decision that I am missing, that I missed here too. If things look bad for you, if you know you are going to lose money, what can you do? Walk away. How much do you get? zero point Yep. So you always have an edge that takes you all the way out with cost zero point So the way I represent that here is I start with a choice of zero point OK now let is do parent pointers. What is the easiest way of doing parent pointers? Keep track of the max of. So I want to keep track for every answer here I want to keep back of the h that led me to that answer. So in the dynamic programming vector, instead of just storing the maximum cost, I am going to store the maximum cost and the number of hits I have to make to get there. So instead of having one number here that is twenty one I am going to have two numbers. I am going to have twenty one and the one that says you have to hit sorry, two you have to hit twice. And then you will go on this arrow and so on and so forth. And if you know how many hits you have to make you can follow this you can follow these parent pointers and they will tell you how to play the entire game. You start at zero and play the entire game. Do we want to change the pseudocode to do that? OK, it is not too hard. How many people want to see the pseudocode changes? All right, I guess I do not have to write it then. OK any questions on this? So the change is really simple. Instead of storing one number you store a tuple. And then because tuples are sorted the right way maximum still works. You do not have to change that, you just have to change what you store down there. So you just add h in, into your Yeah, you add one more parentheses for the tuple. Wait, I already have two, OK, never mind. You have to go through your choices, so you just Is there any difference in making a separate dictionary for parent pointers? Does it make any difference in run time? Absolutely no difference running time. The code is, it might be more complicated, it might be more simple, depending on how your brain works. It is easier to patch existing code to add in parent pointers this way. If you are writing new code it might be easier for you to have a separate dictionary. This is fewer lines of code though. OK any questions on this? Yes? Could I generalize and say that if you have a topological sort you can do everything backwards. Otherwise you should use memoization. So actually you are doing it in the order of the topological sort. You are not doing it backwards. Oh, OK sorry. If you have a topological sort then you should do it in that order. But if you do not have a topological sort then you should do memoization. If you do not know the topological sort. But there has to be one, right? Because otherwise you have infinite loops. If you have an infinite loop in your dependency graph, then you are not going to have an answer. So that means you are dp formulation is bad. Fortunately for all the problems that we have the topological sort is pretty obvious. It either grows from zero to the problem size or the other way around. So then memoization is? So memoization is, it is more of a proof of concept thing. It shows you that if you have the recursion, everything else can be done automatically. So like if you build a graph then you can run top sort and get the answer, you do not have to think about it. We think about it because the code is smaller if we do it this way. If I had have to write memoization I would add four or five more lines, right? But the point of doing it that way is, all you need is that recursion. If you have this so this is the magic part. If you have this, so this line here of what your choices are and max, how you combine them, then everything else is mechanical. Once you have solved enough problems everything else is just follow the process. So this is the equivalent of in graph problems, the hard part is figuring out what the state is. Once you know what the state you know that these are the vertices, and you know how to draw edges between them. And then you know what algorithm to run. So the hard part is still knowing what the state is. Anything else? So this is dynamic programming. Smaller code. This is the graph approach. They essentially compute the same thing. This is more code, this is less code. And if you see the correspondence between them then you understand the problem a little bit better. The main point is when you have a new problem you can approach it either way. If you see the dynamic programming solution right away write it down, you are done. If not, draw the graph. Think of what the state is, draw the edges. And then after that you can write the math. OK let is talk about a new problem. Let is talk about the problem that shows up on interviews. People excited about interviews? OK suppose you have a sequence of numbers, I am going to draw a sequence here. And you want to find the shortest increasing sub sequence. So you get to choose some numbers out of these numbers. And they have to form an increasing sequence. So for example this is a sequence. It happens to be increasing. This is also a sequence, but it is not increasing. So it is not a valid answer. And I want the longest sequence, the longest sub sequence that is increasing. Does the problem make sense? How do we solve it? Do we want to solve it using dynamic programming or using graphs? OK so votes for dynamic programming. Votes for graph. Well too bad, it looks prettier as a graph. So how do we solve it as a dynamic programming problem? What are the sub problems? The largest sub sequence Starting somewhere, right? I am going to go off that answer because I know how to go off of it better. So say start here. Say start at four point Or actually say I start at three point I have two choices. 5, which is closer to me. And four point Well I have a few more choices, but they are further away. Whatever. So these are my choices starting at three point If I decide that I am going to go from three to four and the next number I choose is 4, now I want the longest sub sequence starting at 4, right? It still has to be longest sub sequence. So from here on, no matter what happened before, my behavior still has to be optimal. If instead I chose 7, I do not care what happened before. The behavior still has to be optimal. So a sub problem says start at number i. So starting at number i. By the way we are going to use zero based indexing again because we like it. So starting at number i, what is the longest increasing sub sequence I can get? So the length of the blah, blah, blah. The length of, you get the point. OK so I am going to have an array again, right? Which stores the answers. The array is going to be named dp. If I have N numbers I am going to have N elements, from zero to N minus one point Suppose I am at element i. And suppose this original array is called a. I am in the mood for good variable names today. So how do I compute dp if i? Let is write some pseudocode for it. N minus i So what is h? The number of steps we want to take So if I am going from three to four h would be what? two point three point OK so I am going to have to do additions and subtractions, and this is going to confuse me. So how about I propose this. What you say is perfectly valid, but instead, to make sure I do not make too many mistakes, I am going to look at the number I land at. At the index directly. So I am going to say I start at i and end at j. So the next step is j. And then your h is j minus i. So I am not going to look at the number of numbers I hop over, all I care about is where do I land. So what is the next number in the sub sequence? If I do it that way, where do I start? i plus one point So I can choose the same number twice, right? So plus one to n. And then I am going to have a choices array here that I start, initialize with nothing. And then what is the candidate, if I am at j? So what answer am I looking at? dp of j. OK. So if I am at i, and I am considering choosing j as the next element, then my sequence will be my sequence length will be dp of j almost. Plus one point OK, can I choose all the can I go through all the j is? Can I go from three to two point No. The number at j is greater than If the number at j is greater than the number at i then I have this new choice, dp of j plus one point What do I do with it? Stick it in choices. Stick it in choices. Sorry this is append. And afterwards? And by the way, this thing is under the if. . OK and I am missing one choice this way. What is my default choice? So what is the sequence length if I just stay there? . So if I decide to not choose anything after three then I have a number, one point Small detail, again one of those things that costs you one point if you get it wrong. OK so I have a default. So I know that this is going to be well defined, and I have all my possible choices. Yes? dp of j representing a. So it is saying, if I am at i, and the next number in the sequence is j, what is the longest sub sequence the length of the longest sub sequence starting at j? So let is run the dp for this example actually. Let is get a feel for why it works and how it works. So I am going to copy it again here. 8, 3, 5, 2, 4, 9, 7, eleven point So this is a. And dp is here. Where do I start by the way? . So I have the algorithm here, how do I iterate? For i in N minus N is zero point N minus one all the way to zero point So in this case we are going to start at 11, right? The default choice is one point Do I have any other choice? Can I go forward? Nope. So this is going to be one point Now for seven my array of choices has a default of one point And then for let me write the indices too, so I do not get confused. 0, 1, 2, 3, 4, 5, 6, seven point And these are i is. So we are at 7, i equals six point For j equals 7, is a of j greater than a of i? OK. So then 7, eleven is a possible choice, right? So if I choose eleven as the next point in my sequence, what is the total sequence length? two point And one plus dp of seven equals two point So this is good. So far the answers add up. So I have one and two as my candidates for the answer 2dp of six point What is the maximum? All right. Works so far. How about 9? What are the possible answers for 9? So what is choices? First there is 1, there is always one point And then for j equals 6, will the if be true? No. I ca not add a seven after a 9, right? So go to the next one. For j equals 7, will the if be true? So this append will happen, right? What will be appended in the array? And this means that if I am at 9, and then the next element is 11, the longest sequence I can get has length two point OK, what is the answer for 9? So if I start at nine the longest sequence I can make has length two point Let is look at four now. . What is? Just in general that is the problem is defined as, OK in this case you go from nine to eleven point Or do you have to go from nine to the next element? So this is the longest sub sequence if I do so the longest sub sequence I get overall. I do not have to go to the next element. So if my problem looks like this, what is the best answer? It is almost defined as So the problem is defined as, this is your first element in the sub sequence. What is the best answer you can get? I thought in that case it would be one because there is nothing following it that is greater. This is greater, right? Unless it skips. So it is a sub sequence, not a sub string, which means it can skip. I hope I got these right. So you can skip, otherwise the answer would be a bit easier to compute. OK how about 4? So let is start with one because that is the easy one. And then? 1, 3, 3, 2, right? Because it is going to be three for that one. OK. And then three for this one. three for this one. And then two point So all these are bigger, so all of them are possible next candidates. And these are the sequence lengths that I can get if I choose them. Final answer? three point three maximum. But for setting the parent pointers you had want to take the closest thing, right? As long as it is a maximum I do not care. So what are possible parent pointers here? The 2 is, right? So either this or this. Do I care which one I chose? No, I guess I do not. As long as I choose a two point From a three I know I have to go to a two point I ca not go to one because otherwise it would not be as long as possible. And then from 2 is I have to go to 1, and I do not care which one. OK how about 2, what is dp of 2? Does everyone else see it? So these are all possible choices because they are all bigger than two point And I get one if I do not choose anything, 4, 3, 3, two point So four is the biggest answer. Let is look at this one, this one is a bit interesting, five point So what are the choices here? one if I do not look at anything else. Then? There is a 3, 4, then nine point A 3, 4, then seven point And? And a two for the eleven point So this if is going to skip these two elements, which I ca not use to make an increasing sub sequence. And then it is going to look at these ones, and it is going to add one to the numbers here. And I get three point OK. What is the answer for 3? four point And what is the answer for 8? three point Right, the choices are nine and eleven point Starting with itself and then nine and eleven point So now what is the longest what is the answer overall for this problem? So it is not dp of 0, right? Before when I had blackjack I knew that I have to start at the first card. So the answer was dp of zero point In this case it is not dp 0, it is the maximum of all the dp is here. Because I can start my sequence anywhere I want. So I have to take the maximum. And that is the overall answer, which in this case is four point OK does it make sense now? Somewhat? So if you do not understand please look at how you had represent this as a graph. The idea is that the numbers are nodes and you draw an edge between numbers, where the first number is smaller than the second number. Write that formulation, write the shortest path for that, and see how that matches to this. 
</body>
</html>