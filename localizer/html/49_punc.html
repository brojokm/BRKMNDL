<html>
<body>
Today is class we will talk about stacks. Mainly see about stacks, besides we will talk about abstract data types, interfaces, exceptions, how stacks are implemented in java and application one application to the analysis of time series. We will also talk about growable stacks, which do a little bit of amortized analysis and then we will talk about stacks in java virtual machine. What is an abstract data type? It is basically a specification of what the instances and the what are the set of axioms that define the semantics of the operations on those instances. What does it all mean? So, You know the data types like integer,You know real numbers and so on. So when you talk of to integer say notion of addition and that is the same way as you add two integers in mathematics. So Hear, Similarly we will define data types in this course and we will define certain operations on those data types. And, Those operations would be defined through what is called an interface which basically gives us what is called as signature of the operation is what are the parameters that the operation requires and so on. And then We will also specify what are the results of those operations through a set of axioms. Just as in the case of integers, you know the sum of two integers as defined in mathematics. So, A plus B if you add a variable of type A and another variable of type B. If you sum them up, then the same answer will be of type as you would your mathematics class. We will see example that will be clear of them. The kinds of operations that you have talking about are essentially of three kinds. One would be just a constructor operation so this is a same as the constructor method in java. Using this method using this operation you can create an instance of that particular data type. When you are talking about sophisticated data types, this method we will do a lot of work Access functions, Functions which let us to access elements of the data type and manipulation procedure would let us to manipulate or modify the data type. Why are we talking about data types? Data types help us identify what are the requirements what are the building blocks of our algorithmic procedure. It provides a language which will help us to talk at a higher level of abstraction. And we can talk just in terms of adding to integers or in terms of stacks or queues or any of the advanced data type it could be discussed in this course. They encapsulate the data structure which is how the data is organized and the algorithms that work on that data structures then capsulate that. Also they help us to separate the issues of correctness and efficiency. We will see more of this as we see the example of data types. So Let me start by giving a simple example of the data type and that is a dynamic set. So you know a set as defined in a high school classes as a collection of objects. And Suppose we also had operations, which would let us modify that collection of objects, which means add an object to the collection or remove an object to the collection. To such a set would call it as a dynamic set. Dynamic, because we are changing the set to changing the collection of objects. And We will create data types for such dynamic sets. So,What are the kinds of methods that you have in a dynamic set? You would have a method to create a dynamic set, That would be a method new. Thay would be a method insert, to insert an element in to a dynamic set. S is the dynamic set and this method has two parameters let us say, the set s and the element. And gives as a result is an instance of the set itself which gives as a result a new set, another set and also includes the element v in it. Similarly this gives removes the element v from the set S. These are the two methods for updating the set. This is a method for creating or constructing the set and IsIn this is a method one of the access methods. All it is telling us whether this element is in the set or not. So the result of method return value is of type Boolean. If v is in the set then it is true otherwise false. And I talk about Axioms which define the which tell as how these operation should behave. We can write axioms in the following form. When I create a new set and I ask you v in the new set. When I create a new set is empty nothing in the set so the answer should be always false, no matter what v is. If I have a dynamic set S and I insert an element v in it. Now this resulting set which has v in it if I ask whether this set. When the answer should be true. If I have a set S and I insert u in it, then the resulting set has u in it. Then if I where to ask whether v is in the resulting set, What can I say, I will know if v is in the resulting set. If we was in the previous set S. So the answer to this operation IsIn DeleteS, u, v, should be the same as the answer to this operation IsInS, v, provided v is different from u. IsIn DeleteS, u, v equal IsInS, v, if v u Suppose I have a set S and I delete v from it. Now I ask whether v is in the resulting set, then the answer should be false. These are some basic axioms that define which tell as how the these operation should what is the nature of operations behavior and functionality of these operations. Here we did not specify how to do these operations or we did not talk about an algorithm or any procedure. At the least we have talked about the code for how we are going to implementing the dynamic set. When you are talking about abstract data types, we are interested in more of the specification. what the instances would be like and what are the operations permitted on those instances, and the what would be axioms that govern those operations. That tell as what operation. Some simple abstract data type that you may be familiar with is queue, but we will be doing it later. Let us see about stacks. Stack is what will be doing today. What is the stack? It is the again a collection of elements but now this collection follows what is call the last in first out principle. What does it mean? that the element which is inserted last would be removed first. If I insert an element and then I remove an element from this collection. Then the element that would be removed was the one which was inserted at the last. The operation of inserting an element is called pushing onto the stack and the operation of removing an element is called popping off the stack. Some of you might have seen this kind of toys. So this has collection of elements for so instance may be stack of trays in your mess. What you do is when you put a tray, you put it on the top and when you remove it you would always remove the one which is at the top. When you remove or pop of an element, it is always the one which you inserted at theby four methods which are the key methods. The new is a method to create a stack. push method when I specify an element o push adds this element to the abstract data type. It inserts an object o on to the top of the stack. Pop, pop is not taking stack as the parameter and it does not take any parameter other than abstract data type. When I say pop the stack, it just removes the top element from the stack. If the stack is empty, then they should flag an error stating that the stack is empty. The top operation returns the top element, it does not remove it and that is how it differs from the pop. Pop operation removes that element but the top tell us only about the top element. Again if the stack is empty then top does not make any sense, it should flag an error. We can also have some support methods which will help us do these operations. Size is one such method. Size tells us about how many elements are there in the stack and is Empty tell us whether the stack is empty or not. So we an understand The six methods that we saw are push, pop, new, top, size and is Empty. These are all the methods and you all understood about what these methods are doing. Axiom which governs the behavior of these methods. If S is the stack, An I push an element on to S and then I pop and the result is stack,what should I get. The element to push know. when I pop on to get back as If I do a top operation. When I push an element v and do a top to get v, Because v would be the top element of the stack. So this is a far is abstract data type so we will define what the stack abstract data type, we define the methods and two axioms. May not be complete but this is what the axioms would look like. Suppose we want to translate that into code? what we do how do you translate the obstruct data type. So that will need to constructs many of you, So already interfaces and exceptions. And What is an interface? An interface is a way to declare what a class has to do and what are the various methods associated with the class. It does not tell us how those methods are done. That would be a part of the implementation of that interface or a class. For an interface we just right down the various names of the methods and the parameters it is going to take. In fact we do not even specify the names of parameter, we just have to specify the types of the parameter. When we write a class for an interface, we will actually provide the code for those various methods. I might specify an interface for a stack and I am going to ask you to write implement the interface the classes for that interface. So to of you could write Different classes if might to implement the interface in a completely different ways. But, I can still use your classes your implementation provided they meet the specification of provide the meet interface specification, are given. But I can use that use your classes in a program that anobowritten I can use any class any implementation the interface specification I have written provided that implementation text to the interface. All I need know that implementation meets the specification, meet the interface use it in my own coding of my own program. So, It helps us to separate the implementation from the specification and that is why it is a very useful programming technique. Let us see about how a stack implementation looks like in java. Java has a built in stack data structure but nevertheless we will define a stack interface here. And, We just define the various methods that are going to be a part of this interface. So, There is one method called size, in which I need to specify the types of the parameters and the return type of the method nothing more. I have not specified not given here methods are implemented. This is just an interface. Your question is whether in an interface we need to know the types. Ya, We need to know the types of parameter. When I am pushing, it takes a parameter of type object. Object is the generic type in java and all objects are derived from this type. So far instance the method is Empty returns Boolean. It just tells us whether the stack is empty or not. It call the top gives you the top element in the stack so it returns an object. And we also throws StackEmptyException, if this stack is empty then top method should somehow signal that the stack is empty. When we are going to do that using the notion of exceptions. What is an exception? void means it does not return any object or any value It does not return a stack but it is a method which is executed on this stack and it modifies the stack You do not consider Thus stack cannot be considered as a parameter. Exceptions are the mechanisms to handle errors. When we have an error or when we reach some exceptional condition or an exceptional case in the execution of program, we throw an exception. So, The java term used in java is throw. As soon as an exception is thrown, the flow of control moves from the current method to the method point where the method was called. So, I will soon show the example. The idea essentially is that, when an exception occurs when something exception happen you delegate the responsibility of handling that exceptional case upwards to delegate responsibilities of problem having error, to the procedure which called this particular method. If you see an example You will be clear,. I have two methods here, one is an eat pizza method which throws a stomachache exception, so there is some dotted code here. If you eat too much of pizza, then there is a problem and you throw StomachAcheException. This procedure is eatPizza was called in the simulate meeting procedure here I call is method eatpizza,So, When this StomachAcheException is thrown, the flow of control will come to the point. when this Exception is thrown, we will exist this method eatpizza and go to this point. No, it would not execute, your question is I am not shown all the statement there are bunches of other statements they would not be get executed. The flow of control would interrupt the dotted point and would reach here. There is also a notion of try and catch blocks. When the exception is thrown what happens to the variable that we have modified? It depends your question exception is thrown happen to the variables is modified here no again the depend upon its like a procedure call, think as if we are returning from this procedure or a method. If those are local variables then you do not want to see them. If they are global variables and if it is modified in the if loop, then those modifications are carried over to the method. There is something called as a try and a catch block. If you think that there could be possible exception in this method, then you enclose the method within a try block. So try, open a bracket, and then include the method which you are calling and close it with a bracket. If there was no exception raised in TA. eatpizza method or this particular exception StomachAcheException did not get raised in this method, then we will just skip the catch block, then go on to the statement, after the catch block. If an exception was raised in this TA. eatpizza method, because this method might raise many exceptions. If this StomachAcheException exception was raised in the method, then we would come in to this catch block and execute the statements. If the method raises an exception, then if that exception is got caught here through a catch block, then we would execute the statements which are written inside the catch block. Any kind of statements can be written inside the catch block, not necessarily System. out. exception. So here is a Your question is, if I did not write this catch block it all? If I did not write the catch block what would happen, the happen this procedure simulating meeting now throw the exception to expiring procedure to the point getting called from. When this throws an exception, this will also throw an exception, then the control will go to procedure where simulate meeting is called. It is fine if that point catches the exception find if not it will throw an exception to the high level procedure and so on.. And finally your procedure will stop with your exception finally appearing at your console. In this manner it is keep getting propagated all the way up to, tell your procedure stops and the exception is then shown to the user. System. out. println is just the method to print the statement. This is a method just print out. An exception is really a java class. And by doing this creating an object of an instance for this class. Then I am initializing that instance with any parameter and I can specify some set of parameters here. StomachAcheException Ouch this class, I am creating an object of this class. StomachAcheException Ouch When the catch statement is caught, this e in that statement would get assigned to the object that is created by thisOuch statement. Yaagain it will be moved up calling procedure ya.. ya.. not enclosed by a try and catch block come together. If you have not enclosed between try and catch, then it would not exception just get propagate upwards move in the procedural hierarchy. There was an this exception throw then this procedure throw an exception calling procedure of simulate Meeting would throw an exception, till it is caught at some point. If not it reaches the console. That significant creating an object so your question is the name of the class followed by brackets and some parameters written would signify in java? In java it signifies, that you are creating an object of this kind for this class and you are invoking the constructor method for this class these as the parameters. So I just put at The try and catch block are a method for listening exceptions and catching them. As I mentioned before, a catch block can contain anything. It does not mean that it should have only system. out. println, it can also throw an exception in turn. It also helps us to exit from the program when an exception occurs. If you throw an exception in any method, then you need to add a throws class when next to the method name of previous slide. When we wrote the method eatPizza we had, throws this exception. Yes, A method can throw more than one exception. I come to that this point when you are defining stomachAcheException In java everything is really an object. StomachAcheException is the name of the class. Public class StomachAcheException extends And the statement and this is the constructor method for the class. To call the name of the class within the name of the same as the class. So the constructor method here is taking a single parameter which is the string. what is super means? Super means that it is calling the super class with the same parameter. Again as I mentioned before, if you never catch an exception it will propagate upwards, along with the chain of method calls, till it reaches the console. Any qustions? It call the constructor the class room to getting a remind in stomach ache exception is extending a run time exception, it will call the constructor method for the run time exception. I think I am going to pass the question because a little bit java more, will not take the question.. yaYes, If a particular method throws more than one exception, then you will have to specify all those exceptions which it can throws, next to the method name. and then Even in the try block you can have many catch statements. First we can catch one particular exception followed by some other exception and so on. We need to Look at your java book for more details. Now we get back to stacks. We had created the interface for our stack. We are going to implement the methods and there are many ways of implementing a stack. First we are going to discuss here using an array. So I am going to have an array lets to the maximum size of our stack is N and I am going to have an array of n elements of the stack. This is going to have a variable t, which will tell about the location of the top element of the stack. So t gives the index of the top element in the array S. The first element will be at location zero and then when I push another element it will move to the next location and so on. So here I have actually listed out an entire implementation for our stack interface. So, My implementation is called array stack because I am using an array to implement the stack. The statement mentioned below says that I am implementing the stack interface. Public class ArrayStack implements Stack Implement stack means, it is implementing the stack interface that we provided. I have set with a default capacity for the stack which is 1024, otherwise the capacity of the stack would be in the variable N. Final is just specifying that the value this is a constant and it can never be changed. S is declare to be S is an array which is going to hold the elements of the stack. Thus S is an array of object and t is the index of the top element. Initially t equal 1, because there is nothing inside the t. t equal 0 means the top element is in the location zero and when the stack is empty t equal 1. Public ArrayStack Public ArrayStack int cap These are the two constructor methods. If you do not specify anything or if you just call the array stack without any parameters, then I am going to create a stack whose capacity is one thousand and twenty four. If you call array stack with some number let us say 37, then I am going to create a stack of size thirty seven point Now given this method should be easy What should size do? Size should just return how many elements are there in my stack. If t is the index of the top element, then how many element are there t plus 1 elements are there because we just started from zero. If you want to know whether the stack is empty if t equal 1 that is t less than 0. If t less than 0 then the stack is empty method would return true, otherwise it returns false. If I want to push an object ob in to the stack and if the size of the stack already equals n, then I should throw a stack full exception. Else I should first increment t and then put the object at the new location incremented location. This is the first increment, and then put the object at that location. I have to give you the top element of the stack for that, I should check whether the stack is empty or not. If the stack is empty then I throw a stack empty exception. If the stack is empty then the flow of control would exit from throw new Stack Empty Exception Stack is empty. And when the stack is not empty it just returns the top element of the stack St. If I want to pop the stack, then once again I check if the top element is empty. If the stack is not empty if the stack is not empty then I save the top element in location element. Then I decrement t, because I am removing the top element and to the location which I set earlier was set to null that is I dereference it. Because earlier at the top location t, that the t was thirty seven initially thirty seven and I had an object in that location. I need to remove that object and decrement t to36. Then I return the top element. Pop also returns the top element. S t equal null Return elem So recall I said stack is a class Stack Empty use new to create an object or an instance for this class. You can also do that Why should we necessarily dereference the objects? It is best to deference, because you can remove those objects or you can get rid of those objects otherwise they will lie in your memory. Thus t is just an integer and it is a private member of this class, private because no one else knows about t and S is an array of objects and S can therefore access the tth element of this array. We will take your question later that I will continue.. About the array implementation is very simple as all the operations were taking constant time. None of the operations required time propositional to the virtual dependent upon the number of elements in the array in this stack at that point. Each of those methods take O 1 time. The problem is that we are working with an upper bound on the size of the stack. This upper bound may have the default value1024, which was specified at the time of creation of stack. The problem is because you do not know the size of the stack. We might allocate a very large size for the stack, but it might be a waste of memory or we might allocate a very small stack in which we could not be able to run our procedure to complete, because we would soon have a stack full exception. Stack Empty Exception is the requirement of the interface, because the top and the pop methods are not defined, if the stack is full if the stack is empty. It is the requirement of the interface but a stack full exception is an artifact of this implementation. If I had some other way of implementation, then I would never may be get have to raise a stack full exception. And we will see an example. We will see how to implement the stack and never to have a stack full exception, so that we can always grow the stack when needed. You have a question? So we will look at an application of stacks very quickly. We have the stock prices for we have the daily stack prices of a particular stock. If I give you the price on day 0, the price on day one and 5,2,3,4,6. This span Si of a stock price on a certain day i is defined as the maximum number of consecutive days that the price of the stock has been less than or equal to its price on day i. This example would make it clear. So the span S5 is the span of the stock price on day five and it is equal to the maximum number of days that the price of this stock has been less than or equal to this price. For four days the price of this stock was less than or equal to 5th day price and so the span of the stock price on day five equals 4, inclusive of the current day. Following picture would make it clear hence we are counting 1,2,3,4 and for day six, it is 1, 2, 3,4,5,6 that is six days. This is 1, this is 1, this is two. How can you compute the span an array S, if I give you the stock prices in an array p. P is an array of numbers. I want you To compute Si, what you are going to do look at the price of the stock on day i, i 1, i 21i 3 and so on. So k The index k will start from zero and it will keep going down and will keep going down till the price of the stock on day i k is less than the price of the stock on day i. The moment you find a case such that the price of stock on day i k is actually more than the price on day i, you stop the loop which is given below, otherwise you keep incrementing k. If this quantity P i k Pi is less, then you increment k else you say done is true. Done will help us to exist the repeat until loop. They will exit the repeat until loop if done is true or if k equals i, which means that you have reached day zero. And what will be span in the span will be determined by the value of k, because k tell us the span of stock price on day i. Thus Si gets the value k, Si k. This is one way of implementing this computing this span. How much time does it take? It takes n2 time as we can see on the slide. Why should it take n2 time? Because we are repeatedly comparing it go all the way from How many times the repeat until loop can be executed in the worst case? Higher position to It is i times, and i varying itself from zero through n 1. Once again we have same summation this is in the last class, this is executed I times I is going from zero thrown in The total number of times one of this statement get executed might be executed n2 or n22. Thus the running time of this algorithm is O n2 in the worst case. Question is can we do something better? Yes, quit we can we are talking of stacks, we can use a stack to do something better. To recall that compute the span, we need to know the closest day preceding i, on which the stock price is greater than the price on day i. In the example, I need to know for day five I need to know the closest day preceding day 5, on which the stock price is greater than the price on day five. On day 1, it was greater. For day 5, the span would be 1,2,3,4. I am going to call the quantity h i. What is hi? h i this quantity is the closest day preceding i, on which the price is greater than the price on day i. Thus h 3 equal 2, h2 equal 1, h1 equal 0, h0 equal minus one and h4 equal 3, h5 equal 1, h6 equal 0. Once you computed h, how can you determine the spanSi? The span for the price on day five is 5 1 that is four. If we can compute these h quantities, we can easily compute the span. How do we compute the h quantities? Suppose these was the prices those six. Days one to six point I have not told the price on day seven but through the definition of h 7, it is the closest day. But can h7 be one at I have told the price on day two but what is h7? Definition of h7 is the closes day proceed it which is the stack price that is larger than the price on day seven. that day cannot be three or four. So What are the possible values that h 7 can take? 2, five and six are the only possible values that h 7 can take. I do not know h7 is We will store the indices 2, 5, six in a stack. two will be at the bottom of the stack, five will be above that and six on the top. To determine h 7, first we need to compare the price on day seven with price on day six. Suppose the price on day seven is less than the price on day six then what is the h 7. It is 6, but if the price on day seven was greater than price on day 6, then I will compare with price on day five. If it is larger than the price on day 5, then I will compare it with two. If it is greater than 2, then it is minus one that is h 7 equal 1. Suppose the new bar I have drawn is the price on day seven and it is greater than the price on day six then what is h 7 is five. The first price larger than the price on day seven in the comparison gives me h 7. But now once I know h 7, I should update my stack. Now what should my stack contain? Earlier it contains the indices 2, 5, six. what should contains now 2, five and seven. It is clear because eight now h 8 can never be 6, I should get rid of six by replacing it with seven. You can see that the stack would be the right way to do these things. Let us look at the procedure. Let d be the stack and initially it is empty. When I get a certain price, I am going to compare that price with the price on the top of the stack. If it is less than the price on the top of the stack that is on the top of the stack we had 2, 5, six and if the 7th bar is less than the six then it is just what is there on the top. Then we are done, the index on the top of the stack will give the h value. If it is more than the top of the stack price on the top of the stack, then I will pop of or remove the top of the stack, because I need to compare with the next one. I pop of because I will not need that quantity any more. As you recall from the previous slide, since this was 7th bar was more than 6th bar, I can actually get rid of 6th bar because in the stack, I do not need that next time. We are going to go around the loop till either done becomes true. When it becomes true it says that I have found a price which is greater than the current day price. But if done never becomes true and the stack becomes empty then what happened the stack is empty h equal 1, exactly that is being set here in the below statement. If D. isEmpty then h minus one Else h D. top When I exit this Pi P D. top loop, the stack is empty then h equal 1 else h is the top value of the stack. Once I know h, I can compute Si and keep it. I will push i back in because in my previous slide when I got this 7, I now push seven in for my next computation. How much time does this take? May be n times. While loop might execute a lot of times and why this should take only n time. Is the worst case n2or n? It may be n2. How many elements do we pushed on the stack? one no in all how many element push on the stack Each element is pushed once and we have pushed at most n elements on to the stack, if there are n elements to begin with. Every time when the while loop is executed, we pop of one element from the stack. Yes or no? How many times the while loop gets executed? It is n times. Every time when the loop executes, we are removing an element from the stack. If the total number of elements ever we pushed on the stack was n, then how can we pop of more than n elements from the stack. It means that the total number of times the loop executed is not more than n. How many times do the statements inside the for loop execute? All most n times, because these are all a part of the for loop. If statements execute exactly n times. What is the total time it will take? It is order n and not n2. I am saying the total number of times the loop executes when all iteration put together is no more than n. Because every time the loop executes and when we go through the loop, we remove one element stack from the stack. We never pushed more than n elements or the total number of elements we pushed on the stack is at most n. Good question it should be h.. tanq.. I said One problem with our stack implementation is that we had to give maximum size for the stack. Suppose We now we are going to look at an implementation in which the stack can grow, if it ever gets filled. How are you going to do that? When we are pushing an element, if the size of the stack is n then I create a new array of length f N and I will create a new array I copy all the elements of my original stack S in to A and then I rename it as S. It becomes my new stack with f N locations in it whose capacity is f N. Thus f N will be larger than n for us and so we had to increase the size of the stack. I increment the top counter and I am trying to push increment the top counter the new object into my top location. How should we should f N? There are two strategies in which one could adopt. One could either have a tight strategy or a growth strategy. In a tight strategy, we always increment the size of the array by some constant c. We just increment that is additive increment. In the growth strategy, we double the size of the stack. We want to compare and see which of these is a better strategy. We are going to think push as of two kinds. One is regular push. In a regular push, there was just space in the stack and you just push the element and it takes one unit of time. A special push is one in which the stack is already full and you have to create a larger stack and copy the elements form the earlier stack to this larger stack and then push the element. You created a stack of size f N that costs f N units and you copied the n elements that cost n units. And then you pushed one more element that cost one more unit. The total cost of this special push operation would be f N plus N plus 1. Let us see how the tight strategy behaves when we increment the size of the stack by c units. For example c is taken as four. Initially I started with the array of size zero. When the first element came to push that was a, then I created a stack of size four and I push this first element in and the total cost was 4 plus 1. When the second element came, I do not need to enlarge my stack, because I have space. It just cost one unit which is a regular push. The 3rd and 4th operation is also a regular push which costs one unit each. The next one is a special push, I am not trying to push e because the stack is already full. I need to create an array of size eight and I need to copy the four elements, then I need to push one. The total cost becomes 8 plus 4 plus 1 and these are all the three regular pushes. Then once again when I fill it, I will create an array of size 12, because c is four. I am incrementing the size of the array by four units every time. I create an array of size twelve and I copy the eight elements then I push one more element, so I get 12 plus 8 plus 1 and so on and finally I have 16 plus 12 plus 1. When the size of the array was 4, I am going to call it as phase one and when the size of the array is 8, I will call it as phase two and so on. Let us see the total cost of the procedure. The pound symbol in the above slide is a multiplication operator. In phase I, the size of the array is c i. In phase one it is c, in phase two it is two c, in phase three it is 3c and so on. The size of the array is ci. What is the total cost of phase i? t At the beginning of phase i, I first create an array of size c i then I copy the previous array elements of the previous array. Let us look at an example. I first create an array of size eight then I copy the previous four elements. So I copy c i 1 elements and it is the cost of copying the elements in to the new array. Then I will do c more pushes in this phase before the array gets filled. C is the total cost of the four regular pushes that I have been doing. The total cost is c i plus ci 1 plus c which is two times ci. Thus the cost of phase i is 2ci. In each phase I am doing c pushes, then if I have to do a total of n pushes then how many phases I need nc phases. Total cost of nc phases would be 2c 1 plus 2 plus 3 plus plus nc because the cost of Ith phase is 2ci and this sum is roughly n2c2 times 2c and that is not t, it is approximately O n2c. So far we have seen the tight strategy. Ya, time We could also take creation as order 1, in that case the analysis would change slightly. For the purposes of analysis I am just taking it as, if you are creating an array of size something, you take that much as the cost. Let us see the growth strategy. In the growth strategy, I start with an array of size 0, when I get the first element I create an array of size one. When I am trying to push an element I would double this array, so I create an array size two and I push this element. When I try to push the element, I double this array and create an array of size four and push the element. I have space for one more element and this is the regular push while pushing d. When I try to push the 5th element, I will double the size of array again, so I create an array of size eight and copy these elements and then push the 5th element and so on. Once again we can analyze the cost. one is the cost of creating the array and you do not have to copy anything and one is the cost for pushing them. Here we created an array of cost 2, we copied one element and one was the cost of pushing. We created an array of size 4, two was the cost of copying, one was the cost of pushing the element c and here was the regular push so it was one and so on. We define a phase as when the size of the array was 1, we call it as Phase zero. When it is two we call it as phase one. When it was 4, we call it phase two and when it was 8, we call it as phase three and so on. In phase i, the array has size2i. Phase three it has size eight and phase four it has size sixteen and so on. In the phase i, since the size is 2i I spent2i units of time in creating the array. Then I have to copy elements of the previous array that is 2i 1 elements the previous array to be copied. How many elements are left after copying 2i 1 elements? 2i 1 elements are still left and they have to be pushed in, in this phase. 2i 1 is the cost of pushing in those2i 1 elements. The total cost of phase i is 2i plus 2i 1 plus 2i 1 which is2i plus 1. If we do n push, we would have log n phases, because the way the array is growing. The total cost of n pushes is going to be 2 plus 4 plus 8 plus plus 2logn plus 1, which is 4n. The total cost of n pushes is 4n growth strategy and in the tight strategy it is n2c. Hence this is clearly a better strategy. This we are going to stop the stack. Next class we will discuss about queue, stop here. 
</body>
</html>