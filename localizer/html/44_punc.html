<html>
<body>
So we are going to do a problem that looks like the guitar problem. But it is a bit cooler. At the same time, there are fewer states, so I think it is easier to manage. How many people know how to play DDR? Well. Yeah. OK. How many people know the rules of playing DDR? Because otherwise I wo not be able to lift my hand up. OK. OK, so let is go through an algorithmic model. So, you have a board that basically looks like this. And you have four touch sensitive pads. Up, down, left, right. And then you have a center position. You also have a sheet of notes that looks something like this. Say, up, up down, down, up down, up, up down, left right, left, left right, right. So on and so forth. So when you see an arrow of up, that is a constraint that says one of your feet has to be on the up arrow. Has to tap the up arrow, actually. There is no constraint for the other foot. So your other foot can be anywhere else on the board. It does not matter. You are also allowed to tap the board some extra times. So if you do not have a note showing up, you can still hit the board. And there is no penalty. So you can hop around as many times as you want, or as many times as you can, until you run out of breath. So up basically means, it is actually one foot has to be up. The other one center. Also, of course, because of the design of the board, it does not matter what foot is where. So what are possible goals for this game? Not to get an F. OK. Hit all the arrows when they line up with the top row. OK. So there are two different ways of doing it. One, you said, not to get an F. So I would say, given some limited set of skills. So given a set of skills, or your skill level maximizes your score. right? Yeah. This is dynamic programming, so we always want to maximize something. Now, if you are really good, then another possible goal is hit all the notes with a minimum amount of effort. If you are going to be in a competition, and you are going to be doing ten songs, you do not want to die after the first song, right? So, assuming you can do everything reasonably well, this is another possible goal. Any other goals? So we are brainstorming here. This is not set in stone. We have already seen the formal solution for this problem. So I want to play with it for a little bit, right? We brought a DDR pad, so I want to play with it. What else could you hope to maximize or minimize for with dynamic programming? Not look ridiculous. OK. I guess we are looking at the cost of each move, right? So, hit all the notes. Minimum effort, or otherwise say best appearance. So every move looks somewhat good or somewhat bad. And you want to do the moves that look as good as possible. So this maximizes entertainment, right? if you are on TV, you probably want this. Now suppose you are in a competition and you only have one track to play. Well, you know where all the notes are. Sure. Like, we assume that we know this ahead of time. So you have memorized this. And you are trying to compute the best strategy, so you can memorize that. Then when you go and play, you dominate. Yeah. So, if you have one track, then I would say that what you had want to do is minimize your probability of failure. Right? So given the probability of failure for each possible move. You want to minimize the overall probability of failure so your teammates wo not hate you. So, hit all the notes and minimize. So this one is a little bit different from the other ones because all the other ones are already set up as a nice problem where you add up things. So you can solve them with graphs or with dynamic programming. If you want to minimize the probability of failure, then you want to maximize the probability of success. The probability of succeeding on all your moves is the product of the probability of succeeding on each move. All right? So if you have five moves, then you have five individual probabilities. You multiply them up. And that is the probability that you execute the whole sequence correctly, and not stumble. So we have products instead of sums. Yes? Is not it related to the maximizing score goal? You can. Well, not necessarily because this one says that you only have some possible moves. I think in the end, all of them, except for this last one, can be solved using the recursion depth we have for it. The last one, you have to do a bit of massaging. And we are going over that right now. So, you have products instead of sums. How do you turn products into sums? Logs? Yep. So, for this one, I would want to use logs, so that I can say that I want to maximize the log probability of success. Which is just the sum of the log probabilities for each move. And then it looks like dynamic programming, as usual. Now, if I would not want to use logs, if I am using the DP formulation, where I am doing recursion, I can incorporate products there. But it turns out, I did not practice. If you have a lot of numbers that are close to 1, or that are close to 0, so all the easy moves are going to be really close to 1, for example. If you have a lot of numbers that are close to one or close to 0, if you multiply them up, you get numerical instabilities. So we get the number that is really close to one point So for example, if I am choosing whether to do, say I am here, and I am thinking, do I want to move like this? Or do I want to move like this, and then like this? These are both pretty easy moves. So, in both cases, we are looking at probabilities of success of 99. 991. And maybe 99. 992. So if you have numbers with probabilities that are really close to 1, and if you have a lot of them and you try to multiply them, you are going to get a bad result. So all the products are going to start looking the same. So we are going to get a random solution, instead of what you want. This is a practical thing. It is called numerical instability. And it is a practical reason why you had want to use logs, instead of multiplying things up. So it is not just a theoretical thing. It also makes life nice in practice. OK. So we have a goal that looks like this. Say, let is go for this one. Hit all the notes, minimize the effort. And all the other ones can be reduced to this one. We need to define effort, right? Let is say that we have a function called delta, that takes two foot locations so, where both of my feet are from and to. And it gives me a number from zero to 1, where zero is really easy. And one is really hard. So from would look something like, my left foot is up. My right foot is centered. To would look something like, my left foot is centered and my right foot is up. So basically going from here to here. So from left foot up. Right foot center. To here. So there is some difficulty there, right? We have to jump, so it is not zero point I am burning some calories here. So any move that I make has some difficulty. And I want to solve the game so that overall I have a reasonably small total difficulty. OK, are we understanding the problem? So we have three possible avenues here. We can start solving it using dynamic programming. We can start solving it using graphs. Or we can have someone else play the DDR again so that we can get more hands on experience, and look at what a good strategy or a bad strategy looks like. So you guys get to vote. Who wants to solve this using the dynamic programming? Who wants to solve this using graphs? Who wants to get more hands on experience? Damn. I was hoping that DDR would win. You guys are boring. So, graphs, right? We are going to have notes. Notes represent states, right? So a state is where you are at some point in the game. And we will have to define what where you are means. And then, when you jump, you make a move. So moves go between states. So in any game, you have states and moves. A state is very hard to put in time. And then you make a move. Like in chess. Your state is your board position. And whether you are moving, or your opponent is the next to move. And the move is when you take a piece and put it from one place to another. So your vertices are states. And your edges are moves. So what is in a state? This is our problem. Whether we are solving it with graphs or with dynamic programming, this is what everything comes down to. What is in the state? So your current state is how much difficulty have you what is the problem? Are those representing the probabilities, the difficulties? Or. So this is the difficulty for one move. Does it depend on previous moves? No, but. No. So it is a nice thing to note that the difficulties for each move are independent. Would it be dependent in real life? You will get tired at the end. And he is able to have less energy. Yep. So, in real life, we might want to say that this actually depends on how much energy you have expended so far. And if we have time, let is solve that problem. So the nice thing about this problem is there are many directions in which we can take it. This is one of them. I am fine. And I think we will learn a lot by doing that. So back to the original problem. Suppose that it does not matter how tired you are. You are pretty good, so you are not going to be tired enough to go GASP. So, mostly independent difficulties for each move. What is in a state? The sum of the difficulties up to that point. OK. So. Your appearance factor, if we are including that. Or are we only doing So we are doing this. Oh, I was just. Oh, effort. OK, we are minimizing effort. So the way I like to think of this is, what is does a solution look like? It is made up of decisions, right? What are the decisions? To make that move or do not make that move? We will see. But once you know what the decisions are, then you have to think, what do I need to make a decision? The note. So, a note is one of these. For some reason, they are called notes. So you know that somehow you have to hit all of them? Like, you can have steps in between. Yep. Moves in between. You have to hit all of them. OK, so I like this. So, every one of these is going to have to generate a move. And there might be some moves in between. Well, each move is going to map to some edge. And I am going to need vertices. So, as an algorithms program where when I hear that, oh. I can have some moves in between, I get really uneasy. Like, what is this? How many moves am I going to have? Is this going to become really huge? And am I not going to be able to run any algorithm on it? So let is think about that. How many moves would I have in between? And, what would I achieve with them? I guess you had have a max of, like, four, right? I mean, you can put your right leg someplace, and you can put your left leg someplace. That is like a max of two. Right? Or no? So, let is think of an example. You want to go, say, I want to go, what? From here to here, right? Um hmm. And you are thinking what? They can do this, oh sorry. So I can do this as one move. And this is one move. Yeah. Or you can just do one jump, right? So it is oh, yeah. I guess that is more than one. OK. So looking at this, if I am considering whether to go from here to here. If I want to go either this way, or if I want to go this way. So let is write this down on the board. So I am going from up down to left right. And I am considering, do I want to go directly or do I want to go up right first. And then left right. Let is not do these arrows because they are confusing. So, do I want to transition like this? Or do I want to transition like this? Well, I claim that, since my moves are independent, going from here to here, if it is beneficial to go this way instead of this way, I would want to go this way all the time. So I would just say that, look. Inside my delta here, I would say that, actually, if you know what you are doing, whenever you have to go from here to here, you are going to go like this. And the delta is going to report to the total delta for this. So, if the problem is that they have one note, and then I have my next note like this, between these two notes, I can always go in one move. So you are saying one would like, including in our difficulty function, it will also tell us, like, what move we should make to get there? How to get there. The best way to get from one state to another. Well, like when you are learning DDR, these are the basic steps, right? Like, you practice until you know how to get from one place to another. There is something else where you need intermediate steps. Or if you are holding one and then you have got to move to another. Right? So, let is not worry about holds. Let is say that we would just represent holds as so if you have a hold in a game, then we are just going to represent it like this. We are going to cheat. So we do not have to deal with it. In real life, you would have to deal with it. Like if you are actually writing a program that trains people. What happens if you have, like, right, left, up or something. So let is say you start off hitting your right foot on the top, and then you have to hit the right one again. And then you have to hit up again and then you have to transfer. So I guess anytime you have to through the middle. You have move your foot. So I like the idea of going through the middle. Why or how do you, why would you go through the middle? To avoid crossing your leg over or something. Well, what if I have something like this? If there are DDR experts, I know this is not the right way to do it. But one way of doing it is left, right, left, right, left, right. So then, I have some states that account for the fact that I am centering. So, some people like to do this, right? Some people like to go to the center as much as possible, if they have time between the moves. So then, I would need at least one state in between where I am allowed to center, right? In order to represent what I just did there, I need one move. So, one way I could meet this is I have left center. And then left right. And then left right, left right, left right. So on and so forth. But this would mean that instead of doing this, which is reasonably easy, I would have to do this. This. And then jump, jump, jump, jump every time. Harder. Not good. Not good for my knees. Not good for my score. So I do not want to do this. I want to have an intermediate state so I can say, I start here and then I get back here. Then I do this. Then I get back here. Then I go here. And then I go back here. And then go back. Do guys see how this works? You could also rock back and forth to because they do not require both feet to be on the ground the entire time. Rock back and forth. Hold that thought. That might come in handy. Assuming we have enough time. So, if we only do one move every time we see a note, we are stuck with this. In our to allow re centering, we have to add states between the notes. We need to add an intermediary state. And you can either think about it, or take my word for it, but if you represent the notes using the trick that I said above, and you want to represent centering, then all you need is one extra state. So one extra move between every two states. Between two notes. And that is enough. Because that one extra state allows you to center. And it allows you to do pretty much everything a beginner like me would know how to do. So you only need one extra state between each note? Yep. That is the inside. That is where I am thinking, right? So I have to do both this trick, to see that I do not need an infinite number of steps. And come up with the need for centering to see why I need one intermediate step. By the way, does anyone know what is the right way of doing that? What is the right way of doing this move? You said, rock back and forth. So I would not rock back and forth in this case, right? Because that would not be helpful. How would I rock? Well, you hold down one and then you go to the other one. Yeah, so rock left and right. OK. I said back and forth, I meant rocking Sorry. I thought back, forth. So, the optimal way of doing this is left, right, left, right, left, right. So what am I doing? You have another move. You have, like, one state for your foot where it is not touching the ground. OK. It is an interesting, and important, distinction. So if I wanted to hit both of them, if I am here, and I need to hit both of them, I need to hit them. If I only need to hit one of them, if I am here, I can hit it like this. If I am here, though, and I want to hit it, I have to lift myself up. So the difference is whether I am like this. Or like this. Where is my weight? So if I want to allow for these moves, if I want to go past the stage of very beginner, aside from keeping track of where my feet are, I have to keep track of whether my weight is on my left foot or on my right foot. So, I would actually have l, r, and W, where W is either l or r. So your state now has what you are currently putting more weight on. And where each of the feet are. Yeah. Where your two feet are. And then also, the song difficulty. So it is everything in your state, right? Ah, yes. I did not think about it. I was just talking about foot position. But we need to get back to the state thing. So that is a good point. So before we get to that, how many feet positions do we have? If we do not include where do I have my weight, how many possible positions for both of my feet do I have? So I have two feet. Each of them can be in any of these five squares, right? So how many total positions? five choose two point Using two point So I can do this. Sure. Why not? Well, if I have five choose 2, then you Oh, then that does not quite work. Yeah. Yeah, no. So flip. Times two point Yeah. So you have two feet. Each foot, five possibilities. Now, what if we have weight? If we are tracking on where I keep my weight. How many possible positions? ? Oh no, because there is only two. So, for each of these, there is two possibilities now. So fifty point You also have to be so your weight is like this. In the middle? Yeah. You can. Based on that what I have been reading, you never want to. Because if you are weight is in the middle, then you are extending a lot of effort to move either foot. So you always want to have your weight somewhere. So that, at least for one of your feet, it is easy to move it. Could it be the back? If that is not true, then yeah. We had need to have a center. Oh, so, like, whether I am like this or like this? Yeah. If you were, like, doing the same thing. Rocking back and forth. So, if I have two feet, then this says my weight is on my left foot. My weight is on my right foot. So l and r is which foot, not where on the board. So, did you not do center because it was optimal? Because I claim that, in an optimal strategy, you would not have it. But you do not have to take my word for it. If you do not believe me, then you add center. And you just have more possibilities. And if it happens to not be an optimal thing, then the dynamic programming will ignore it. So how many positions do I have if I add center? So if I have left, center, right for each position. seventy five point Cool. Yes. So why is it 25? You would not actually have both of your feet on the right. Why? Maybe, well especially, for maximizing this one actually. Especially for maximizing entertainment. Then it is way cooler to do this, right?  You get the point. possible weight. Like combinations for like, where is you should have your feet at one time. Like, not necessarily what the game is asking you to do. Yeah. So this is where my feet are. The game will always ask something like this. So the game wo not always care about both of my feet. Sometimes it will only care about one foot. So, yeah. There are two different concepts, right? There is the position of my feet. And then there is the note on the screen. And my feet have to match the note on the screen. And we will have to capture that somehow. So what is in a state? What are my decisions? Come on, now. We should be in a good shape to know what my decisions are. What do I decide every time? What move to make? Yeah. How am I going to jump, right? Where my feet are going to be in the new position. So every time, I am deciding what is the new foot position. Are not you also deciding weight position, where you are going to hold to, right? OK. So when I say foot position, it is a cheat for everything. So yeah. Good observation. OK. What do I need to know, in order to make this decision? OK. I would need to know where I was before if I want to compute the difficulties. But aside from that what? Sir, it came up with this polynomial. All right. Is that a hint to what the run time of this will be? It is not on purpose. But yes. So, yeah. That makes sense. Probably not good. I should probably not have my screen up without me looking at it. OK, so. Back to decisions. I think I want to know what is going to be on the screen when I land, right? Because if the screen says, yo, you need to go up and down. Then maybe I should not do this, right? That would not be good. So I need to know what the note is going to be when I land. Note. Is that the same as the next? Yep. Next note. Yes. So the next note here on the screen. So, my position in this list, basically. So it is kind of like the knapsack problem, where it is like which thing we are considering picking up. But in this case, it is coming. So it is close to knapsack. But the difference is, in knapsack, I have to decide, do I choose this or do I ignore it. So, if I had be like, if I can only do a few things and I want to maximize my score, then maybe I would choose, all right. This is easy. I am going to do it. This is hard. Screw it. This is easy. I am going to do it. So then my decisions are 0, one point Pick or not pick. In this case, every time my decision is a new state of my feet. So it is not 0, one point OK. That is the difference. And then, because of that, the state is going to look different. And the recursion is will look a bit different. OK. So I want to know the note that I am landing at. I want to know the sum of well, we will see if I want to know the sum of difficulties up to this point. And I want to know one more thing, so. If this is going to be my new state, and I know what note I am landing at, I am making a decision. The decision tells me where my feet are going to be. Right? The move decides where my feet are going to be. What do I need to do? What else do I need to know for my total solution? So what do I need to know to consider between decisions? So say I am considering the state of I am at note two. Note two says, left right. And I am considering of coming here from note one, where my foot position was up down. Or come here from note one, where my foot position was left right. I need to know where my foot position was, to choose between these, right? If I do not know that, then I ca not choose. That is not from your state, though? Not yet. It is not here, so it is not part of my state. We have been talking about it a lot, but we did not put it here. So let is say that the state is going to have the note that I am landing at. And my foot position after landing. So, if I know that I am going to land like this, then I know where I was here. l r. Say, l r. I can compute the costs here, right? This is delta of going from this to this. And this is the delta for going from this to this. Can you see? Is that too small? Delta wants to know where my feet were before. And where they are going to be now. So when I call it, I need to know where I was before. And I need to know where I am going to be now. So this should be part of my state. So our decision says, what is my new position going to be? So when I make a move, I influence my new foot position. They are going to be in someplace. And independently of that, the note the position here the position of the note, increases all the time, right? Because time can only go forwards. How are we going to account for these extra moves? . So, we said that between every two notes, we might want to make one extra move. Like, a potential new note in between your destination note? Yep. And then just fill in the difficulties for that and see which ones So, if I want to use the algorithm that I already have, that compares my landing position to my note, to see whether I can go there or not, what note would I want to put in that intermediate note? So, you are basically saying that between every two notes, I am going to have one more note. And my feet can be wherever here. Oh. I mean, you will also have the edge originally connecting them. So, you had have it going to the intermediate note, but also from the destination. Yeah, like that. You had have to So, what note would I have here? It makes you go to the center. Do I have to be at the center? Well, you can be anywhere. Yeah. So I am going to invent the blank note. That is a big O. That means you can do whatever you want. There are no constraints. So that is just an intermediary state. So then I am going to take this input, and I am going to add these blank notes here. And these map to adding notes in the graph. Well, then, when you just run through your difficulty function between each two notes and see if, for all the potential moves, which one minimizes that path. Yep. So basically, I am assuming I do not need this. I am assuming that. This is going to be where there is at least one choice where this is going to have the same cost as a direct note. And then I am going to say that instead of having more complex shapes in the graph, I am going to insert extra moves here. OK. I would think that, if you have an intermediate move that might be less expensive, you should, like, just hop to that new position than to have an intermediate move, right? Yeah. And I am going to assume that either that is not the case, or that I can always find an intermediate move that makes my life better. Every case? Yeah. These results do work. You will have to take my word for it that this works. And this makes your dynamic programming easy. And it makes your graph building easy. So the advantage of this is you are changing the input. And then, when you are building your graph or when you are doing the DP, you only worry about an input that looks like this. You do not care about any intermediate stuff. You have notes, and you have to transition between the notes. Period. So we reduce the complexity of the problem. So whenever you can get away with that, it is really nice. We can do that for centering. We might not be able to do it for other more complicated stuff. OK. So, we sort of know what we want in a state. Now we want to build a graph, so that the path from some source to some destination has a cost that is equivalent to the sum of these difficulties. Right? Because then I can run the shortest path. And my solution will be right there. I know. You guys seem awfully sad. Do you want to take a break and play for a little bit more? Yes? How many people want to play, instead of. You do not have to play yourself. You can just rest for these two or three minutes. And you can watch someone else play. And get more intuition about how you are supposed to play. OK. So one person wants to take a break. Everyone else wants to keep going? Or are you guys passed out already? Can we get out early? Sort of. Yeah. You will get out three minutes early, if we do not do another round. So who wants to keep going? No. Let is play. OK. So who wants to keep going? You can only vote on one thing. Who wants to play? OK. Five. Four. Victor, go. OK. Who wants to go? So we decided what we are going to have in notes. And we are going to build a graph, where the notes are the states. And the edges are the moves. Right? So a note tells me, just like there, what note I am at. Say I am at note two. And where my feet are on. So, left foot left. Right foot right. So, given a state, what outgoing edges do I build? Where can I go to? So let is say I have a state that says I am at note n and my left foot is in some position. My right foot is in some position. What are my outgoing edges from here? Is there an outgoing edge to every move? Because there is a point. OK. Well, actually, the blank is a note, right? So if the next note, if note three is a blank, then the note is a blank. And then I can have. I guess, is not the difficulty of the move dependent on what note that blank actually is? So, it does not depend on what the screen says. It depends on where my feet are. Oh, OK. I see. So I have a number that tells me what is on my screen. This number is enough for me to know what is going to be on my screen from now on until forever. Because I have the list ahead of time. And then I have the position of my feet. So these are both part of the state. So I have notes for all the notes. And all the positions of the feet. Right. But the blank note is just one position of feet? No. Or, it is all positions. Yeah. Is not the difficulty dependent on what position your feet end up? Yeah. So it is from where I start to where I land. So, if I decide to start from here, and go here, the difficulty of this move is so it does not depend on whether I have a blank there. And this was OK. Or, if I had an up down, then I just missed the note. But the difficulty, the effort I am expending, is the same. OK. But if you start from that other move and go to a different position, that is If I go from this to this, then that is a different difficulty. But it still could be a blank note? Yeah. So, a blank note will let me go wherever I want. I see. But there are different kinds of blank notes, with different I guess I am confused as to what OK. So let is go through them again. Is it kind of like it is, like, spreading, so really when you have your source note, it is actually connecting to every possible move. And every possible move is connecting to your next so it is kind of like a diamond shaped thing? Not quite. Not quite. So, let is go through the notes again. And then let is go through that. So the source move will be connected to some notes. And then those notes will be connected to other notes. And it looks more like you have a big, outgoing degree. Then you have a big network. Then the big, incoming degree. It looks like a messed up sorting network. So, notes are constraints. This accepts any possible feet combination, right? So this accepts this. Is the first combination contained in that note? In that blank note? No. The blank is a constraint. So, if I have a note that looks like this, then if one of my feet is here and the other one is in the center, then that is fine. The constraint is met. If one of my feet is up and the other one is down, then the constraint is met. But the edge running into that blank note, depending on how your feet land, is different difficulty. Is that right? Yep. But when I compute the edge width, I need to know where I am landing exactly. Not just where the note is because the note might admit multiple positions. I see. So this guy admits all positions. OK. This guy admits some positions, right? These are l r, l r. If I have up down, how many feet positions does it admit? Just one. Not great. No. How many? As an intermediate? If it is up down, then it is on the screen. My intermediates are all blank. Oh, oh. I thought you were saying start with that. So up down. If you see up down on the screen, how many feet positions? Left to right what it could have. Yep. So, if the screen says up down, the only two ways I can do that is this. Or this. Right? So, two positions. I see. Well, I mean, but you could have intermediate where you step in the first one, then back. But I do not care because I have added these blank notes. And they take care of my intermediates for me. But so, we are saying where the feet land are not part of the note. Nope. They are just states. So they are a decision I am making. So, do we have the multiple no, we do not because they are not part of the For each note position here, for every position in the screen thing, I have multiple feet positions that I could be in. Right. Right. But then, are there multiple moves to get to those? Yep. OK. So there is multiple moves connecting each. Yeah. So for example, if I want to get to l r, up down here, I can go from l r, up down in the blank. Or, I could have l r be like this. And then transition. So I can have a lot of possible foot positions that I am transitioning from in order to get here. But those are not actually separate notes on the graph. They are. They have to be. So these all have to be separate notes. Because the edges are going to have separate weights. Right? This edge is going to have one weight. This edge is going to have another weight. OK. That is what I thought. But then you said there was only one blank. Do not there have to be multiple blank notes for every foot thing. If you are approaching a note from different So, I am not sure what you are asking. So, if you want to care about centering, if you want to have intermediate moves, you need one blank note between every real note. So that you are allowed to make one intermediate move between. Right. I get that that is talking about the on the screen. Yeah. That is the screen. That is the screen. Yep. OK. So, that is not the graph, though. Here, we are talking about the screen on the graph. Here, we are talking about the graph. So two tells me that the screen is at note two. Whatever that happens to be. And my feet are in this position. OK. So that is very important. Thanks for asking because that is very important. So, a state has the note that I am landing at. So, where the screen is. And where my feet are. OK. OK. The state corresponds to the nodes that you are on. A note. A note is a state. So, a note is a state. And a move goes between two states. This is how we represent all the graph problems. OK. So, you need multiple blank. Yeah. So here, I am just drawing one example. Yeah. Yeah. So for example, here I would need sorry. Oh, OK. I get your confusion now. So, yeah. This would be one move. This would be another move. That is all for a single thing on the screen. Yep. OK. OK. That makes sense. So the next note would have a really large end degree, right? I guess they always have Well, no. It had have lots of So, this note has a huge out degree. Yeah. But I am saying the ones that all those intermediates connect to. Yeah. So, then, they would connect with some note that have, like, really large degree. Yep. But there is two of them after that, right? Because there would be two different So, what is next? Next, is position, hmm. How did U number them? I guess, crap. No. It is not going to match that, so. Whatever we do, it is not going to match that. Say the next note, 4, is just an up. four is up down. And then I have two notes for it, right? Wild One note, l r. So this is note four point That happens to be up down. And then I have this. And every one of these connects to every one of these. If the next move is up down, how can notes have down up? Oh, because you can switch the feet. Yep. Oh. Yeah. So, I aimed to ask you guys, how am I going to draw the edges? But you guys made me do it with questions. So, suppose I met note n, l, r. What edges do I draw going out of it? So, note n, left foot at some position. Right foot at some position. What are my outgoing edges? This is a note on the screen. Or In the graph. the new one or intermediate one? Does not matter. So, intermediate notes have a note blank. That is just everything. It does not matter. Yeah, we are looking at all of them at the same time. Wait, so you are asking what are So, given this note, who am I connecting it to? Let is draw the outgoing edges. So, if you are solving this as a graph problem, you build the notes. You draw the edges. You are on some algorithm. So let is draw the edges. I think it depends if you are an intermediate note or not. Nope. So the note tells you what your constraints are. And that covers intermediate notes. If you are note is a blank, then, well, there is no constraints. If the note is not a blank, then there are constraints. Oh, note. I thought that was referring to the note, not the No. So this is a note. Maybe n is not good. Let is use i, instead, then. If n is hard. So, i is the position here, in this guy. Right? Say for example, i equals one here. I equals two here. I equals three here. So and so forth. And that does not match this, so. We are talking about note Yep. not If one note is represented by these three numbers, right? Each note has this tuple in it. Then i is the note. Yep. So i connects to i plus one point And then all possibilities known. OK. So this connects to i plus one point And then all possible destinations, right? So I am going to say left. This is after the jump. So, left after the jump, and right after the jump. And this is for all possible left after a jump, right after the jump. And lost a weight on this edge. The way that it is from l r to l r to l r. l j l sub j r. l r. So you want to say from l r to l j, r j. But what? Difficulty level? Yeah. Where is that? Your difficulty function. Which is? Delta. Delta. So, yeah. The weight is delta. I drew d. Delta of these two foot positions. Almost. If I want to minimize the difficulty, then this is right. If I want to maximize a score, then I would have to add a minus sign. But if you are minimizing the difficulty, this is exactly the way because it maps the shortest path. Usually, in dynamic programming, things are maximized. Wait, why would you add a minus if it is So, if we are maximizing something, we have to flip we have to add a minus to the edge costs because Right. Yeah. But this time we are minimizing something. Oh. Right, right, right. I promised you that we will maximize something all the time. Well, I guess I lied. OK. Right, right, right. You do not want to maximize d. Then you are dead. No. You want to maximize show offs. So if we have the entertainment thing, then that would be maximized. And then you had have minus. Then you had have everything you need. Yep. OK. OK, so we are almost good. Source notes and destination notes. Well, I guess source, we know that means start in the middle. Right? Like, you would start off with What is the source? You want to start at the first note, right? Yeah. But in which position? Well, in the center, right? I mean, the start. Or, I guess you could start Wherever you want. Could you add a source note going to a bunch of intermediate notes? Yeah. Yeah. So what I am going to do is I am going to say there is a note zero point That let is me choose how I am going to start. Oh, it could be any position. It is like an intermediate note itself. Yep. So I am going to have a note 0, with all possible foot positions. And then this is going to be connected to a source, by edges of weight zero point So the intuition is that I get to choose my starting position, right? Starting position. I see the first note. I make a move. So I want to be able to choose the starting position. That is why I have all those notes. And then make a move to touch the first note. The starting position is also a note. Yep. Because, if the first note is here, I do not necessarily want to start like this because maybe this is harder than this. All right. What is the destination? The last note. OK. So, all the notes that are at note n, and have any position, would be connected to a destination note, using an edge of weight zero point Or I can consider them as destinations. And then choose the destination that has the shortest path. Oh, I see. The final destination is going to be, like, two notes. Right? It is going to be that last position, and then Or it might be more than two if the note is just a simple note. Because that would not constrain my feet too much. OK. And last, last question. Dijkstra or Bellman Ford? Bellman Ford, because you have negative edges, negative weight, as if you were going to maximize to death. So, this is always going to be from zero to one point So I could possibly use Dijkstra. The answer is neither. The answer is, we are building a DAG, so. Dijkstra. We do not use that. DAG, shortest path. Every time we have dynamic programming, DAG, shortest path. OK? Question. Yeah. Come on, last question. You ca not get away that easily. OK, so. Who wants to play? 
</body>
</html>