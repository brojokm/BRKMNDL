<html>
<body>
OK. So who is going lecture? Good. Does everything makes sense? Mostly. That is good, because we are going to do problems. Awesome. So, what I want to talk about is, first, there is a subtlety in the Rubik is cube problem, which I am guessing nobody has seen yet, but we are going to talk about it anyway, because otherwise you will trip on it while you are doing the problem. And then we are going to talk about one or maybe two problems. And I am excited about the problem titled, there is StarCraft and counter strikes, so, let is hope we get to them. I am curious, did you write this week is problem set? Because there is some Chinese in there. No. Oh, OK. No, someone else wrote it. I suggested putting that in there, though. You had an awesome internship, right?  Wait, did you make all the AMD questions? Of course. That is my stuff. OK. So Rubik is cubes. Did everyone see a two by two by two Rubik is cube? You guys are going to lecture, right? You have one. Yeah. Did you guys see Eric is two by two by two Rubik is cube? It looks sort of like this. All right, so big Rubik is cube has how many small cubelets in it? eighty point eighty point I like cubelets better than cubies. Cubies is hard to say. Yeah, I would say cubicles. So let is go for let is try cubelets and see how this works. OK. So each cubelet has six faces, but three faces are always facing inwards. They are always attached to the center of the cube. So we do not care about them. We only care about the other three faces. So if you have a plastic Rubik is cube. Say this is a plastic This is a plastic cube. Then you are going to have eight plastic cubelets. Each cubelet has three colored faces and three faces that we do not care about. So how many total plastic faces in a cubelet, sorry, plastic cube? Twenty four. All right. Now let is play with an imaginary cube. And I call this a wireframe cube, because I draw it like this. So, here pretend you have the skeleton of a Rubik is cube, made out of wires or out of wood or something. So it is basically a small sheet of wood, small piece of wood, small sheet of wood, so on and so forth. And so this does not have any colors in it, but it is the right shape and sort of the right look. So the way you would build the configuration is, you take twenty four plastic faces that you get from a plastic cube, and you paste them one by one onto the faces of a wireframe cube. And they claim that this can build any configuration that you can think about. If you look at a cube, after no matter how many moves you have done to it, it is going to have some it is going to have the faces somewhere, right? So you can take the faces and face them where they belong and there you go. You have a real cube built out of a wireframe and plastic faces. How many wireframe faces there are? Please do not get this wrong. Twenty four. OK. There are some configurations that are not possible, right? OK. There are some configurations that are not possible, and that is very good news. We will get to that later. Let is see how the code talks about these faces. So suppose we have a cubelet that has these faces. Front faces yellow, this face is blue, and this face is orange. This facing code is called so this yellow face here is called y o b. So y is yellow, that is the yellow face, and is the yellow facing the cubelet that has a yellow face, an orange face, and a blue face. Fortunately, there are not two cubelets that have the same face color, so this is good enough to distinguish between all of them. Let is see if you guys are paying attention. How would I call this face? o y b? Yeah. Either that or o b y, whichever one the code happens to use. So the principal is, these are the colors and the first one is the face that you are pointing at. So there are twenty four plastic faces, so there are twenty four names for these plastic faces. Let is see how we name the wireframe faces. If I take this face so we do not have colors here, they are all the same. So instead we care about their position. A cube has a front and a back, right? This cubelet is on the front somewhere, right? So I am going to have front somewhere in the name. It has an upper face and a lower face. Is this going to be upper or lower? Upper. And the left or right? Right. OK. So front upper right, which face am I looking at? The front. OK. f u r, fur. How about this space? . So far so good? Or it could be r u f, right? Or it could be r u f. . I really do not know what it means, I am behind. Ruff like a dog? It has fur. Oh, ruff ruff ruff. OK. That is not too bad. I was afraid of something worse. OK. That is cool. So a configuration will take plastic faces and face them onto the wireframe faces. So a configuration is going to be an array of twenty four elements. And the first element is going to tell me which plastic face ends up in Let is say if you are the second one, says which plastic face ends up in r u f, and the third one, let is assume it is the space. Ruff. Ruff. And there are twenty one more faces, right? So each face has a number from zero to 23, because we are in Python, so we like zero based indexing. And twenty four elements in the array, twenty four plastic faces. Which plastic face goes into f u r? Assuming this cubelet here see, I said cubicle anyway. This cubelet here goes here in exactly this configuration. . Yeah. So this face ends up here. And that is what it means that the first element in the array is y o b. How about r u f? Who ends up in r u f? . B o y. And who ends up in e r f? . OK. So does everyone understand configurations? Does this make sense? Yeah. I got lost somewhere in there. Can you explain the order for f u r and? Like front upright? Oh. So do you mean so the order of the letters. So there are two orderings here. One is the order of the letters and there is an order. I think the code uses clockwise order, but what really matters is the first letter tells you which face you are talking about. So this is front face. Face, up face. What is up? What is front? So for this cubelet, this is front, this is the right, this is up. This cubelet wold have a front, an up, and a left. So now there are twenty four faces and all of them get numbers from zero twenty three point And here we assume that f u r is space zero, r u f is space 1, and e r f is face 2, which is not quite, but you will have the mapping there. OK. So a configuration is in an array of twenty four elements and it maps plastic faces to wireframe faces, which brings us to, how many configurations are there? You mean like mapping four factorial? OK. So let is see what it does. We have twenty four plastic faces. From zero to twenty three point And they have to be mapped to twenty four positions. INTERPOSING VOICES There is six colors, are not there? Yeah. There are six colors, but if this is also yellow, but there is a red here. This is a different face, see, this is yellow, red, and there is a green down here. Then this is the yellow face of the yellow, green, red cubelet. So we care about the individual faces. So yeah, your answer was right. I am trying to explain it to everyone else. But your answer is right. Well, wait. But you ca not I mean, we talk about some are impossible. Like, you are always gonna have a grouping of y o b. That is never gonna change. Right. So some of these are not reachable, because you are not allowed to break up the cube. Yeah. And that is OK. This is still how the code represents them. So I am asking if you had if all these would be possible, how many would we get? And the answer is that to map twenty four plastic faces to twenty four wireframe faces. So this mapping is called anyone good with math? one to one point Bijection. OK. So when you are taking OK. So when we have two sets and you have a bijection between them or one to one mapping, that function is also called? . You probably do not know the answer yet. You have to wait until the end of six thousand and forty two point So I am trying to hint that right now, if you remember the end of 6042, maybe the answer is somewhere there. Blur?. Perfect. A perfect match Permut. I totally learned about that in middle school, I think. OK. So this is Permutations and combinations. So this is a permutation. Yeah. How many permutations do you have out of twenty four elements? Does that order? mean?? matters? twenty four. So this is a lot of permutations, right? It is a good thing that we are not going to explore most of these configurations. So we said before, that we are going to build a graph where the vertices are configurations, and the edges are moves that get us from one configuration to another configuration. Can they afford to build this graph first and then run BFS on it? Not going to work, right? We do not have enough RAM for this. So instead we are going to have to operate on an implicit graph for presentation. Well, fortunately, BFS does not want the whole graph. The way BFS works is it has a list of nodes that it has to visit, and when it visits a node, it wants to know its neighbors. And that is it. Yes? Everyone happy with it? So all they have to do is, in order to build this implicit graph representation, is we have to know the start node, So BFS can start somewhere. And we have to be able to give it a node, we have to be able to generate all the neighbor nodes. So given the configuration, we have to be able to generate the configurations that would result by applying most of that configuration. So what are the moves that you can do with this? Suppose you have a cubelet. What are the possible moves? There are not that many. We are interested in the simplest kind of moves.  Yeah, you can make the right side go right, which is equivalent to the left side going left. And then you can do 4, left. It is a nice number. OK. I think there are a few more, so here is how I look at it. You can take the front face, so these four, and do a clockwise rotation, ninety degrees, or you can do a counterclockwise rotation, ninety degrees. And you can do that for each face. But doing a front clockwise rotation is the same as doing a back counter clockwise rotation, which is? it? Yeah. Doing a front clockwise, doing a back counterclockwise is the same thing after you account for symmetries. Yeah. Exactly. So it is six? Yep. So there is only six after you account for symmetries. Let is play devil is advocate and assume we do not account for symmetries. We are actually doing the code, because I need to teach you something. So let is assume we do not apply. By the way, how would you account for symmetries, easy way? Did anyone read the comments in the code? OK. So would you account for symmetries. Does not it just happen? The permutation is going to. Can you just look at it, like, each space is neighboring faces, and? So the way we do it is we anchor one cubelet. So we have one cubelet that is a plastic cubelet that is always going to go here. So three plastic faces here are always going to go to three wireframed faces here. And if you fix those three faces then you do not have simple symmetries anymore. All right? Three axes of symmetry, so fixing three faces settles it. Wait, so then how many moves are possible? 12? No. But you only do one thing, though. Now you do not do counterclock you do not do. If one is anchored, there is six left. Yeah. Yeah. You do not move the anchored one. Oh yeah, because you can only two of the three of the faces now, but. OK. So let is look at the left face. So you have a configuration. So you can move the left face clockwise, left face counterclockwise. You can move the top face clockwise, top face counterclockwise, and a couple more. So what does a move look like? Someone said it before. So when you are doing a move, what is going to happen is, a move does not create plastic faces and it does not destroy them, right? It just changes their position on the wireframe. So if you have an initial configuration that has plastic faces assigned to wireframe faces, and you have a final configuration, these plastic faces are going to end up somewhere on the wireframe. And that is true for all the plastic faces. So the plastic faces are going to end up somewhere. Also, what is nice is if we look at the wireframe, if I do a clockwise rotation in the front, whatever plastic face was here is going to end up here. Whatever plastic face was here is going to end up here, so on and so forth. So it is a function of rotation inside. Like the four faces that correspond to each other, rotate. OK. That is some good that is going deeper than want to go. I want to account for something simpler. So my point is that the arrows will always, if I do a right clockwise rotation, the arrows will always look the same. So the only thing that changes is what is inside the array. But if you take one configuration array and you move things according to the way you are supposed to move them for the front clockwise move, you are going to get the right result. So what is this a bunch of arrows called? What does it do? What does it do to the faces? What does it do to the elements of the array? It moves in different spots. OK, so fancy math name? Shuffle. OK. So this is what I got before. This is how you think of it, right? It is a shuffle, so fancy math name for a shuttle. . All right. Something going on here. So then a move is a? Rotation? permutation?.  All right, so the thing is the difficult part of the code is you have two things that are represented by permutations. Configurations are permutations of plastic faces onto the array, onto the array of wireframes faces. And then a move is a permutation of a configuration into another configuration. OK, so now if I want to compute neighbors, I take we think there are six moves, so I am going to take six moves. I am going to type out the permutations, so six times twenty four numbers, and that is it. Now I can compute neighbors. Does that make sense? I think you have all the permutations. So there are six moves, right? Yeah, but then it is right. Oh yeah If I take a configuration, and I apply the permutation for this move, I am going to get a new configuration, and that is its neighbor. So if I apply the permutation for LC 4, left clockwise to this configuration, I get the new configuration. So all I need to do is hard code those configurations, and then I am done. I can compute neighbors. But that is a lot of typing. I do not want to type as much. I want to reduce my burden a little bit. And we can do that by noticing that some moves are associated with some other moves. So, if I go left clockwise move, that is the inverse of a left counterclockwise move. So, if given the permutation, I could compute its inverse, then I would not have to type as many permutations. Right? Why do I care about that? Did anyone take 6004? Remember? So at some lab, which is the dreaded beta lab, you have to write the control block for a processor, right? And that is a lot of zeros and 1 is that you have to type. And if you get one wrong, good luck to. INTERPOSING VOICES eighteen wide and sixty four tall. I know. Copy and paste like. Yeah, and copy paste.  OK. Bad memory. Let is move on. Let is move on. So two good news, two pieces of good news. One, some of these are redundant in our case, two, we wrote everything for you, so you do not have to write them, we are just teaching you how we did them, because the inverse of a permutation is cool and I think it is a good concept to know. So let is look at how a permutation looks like and compute its inverse and then move on to other nice problems. OK so let is take a presentation of five elements, not going to go to twenty four on the board here. 3, 5, 1, 2, four point This is how permutations look like in math mode. If you want to be more explicit, you can add a row numbers above. And this is a bit more explicit about what a permutation does. So permutation takes an input list, let is say a b c d e. And for this is an output list, according to the recipe that you see here. So this pretty much says, the first element of the output is the third element of the input. The second element of the output is the fifth element in the input. Wait, this is the wrong permutation. It does not look as pretty, so I am changing the permutation. The third element of the output is the first element in the input. The fourth element of the output is which letter? So which letter? Oh. And the fifth element of the output is which letter? Did you mean to get c instead of a? No. Yeah. That would make more sense, would not it? Thank you. OK. So if this is permutation pi, then this is the effect of applying pi to this original list. Now the inverse of a permutation by minus one is another bunch of arrows, and what I want to do is, if I take this, which is the output of pi, and I run it through these arrows, I want to get back a b c d e. So I want to undo the effect of pi. OK. How do I compute this inverse? How do I compute pi minus one given pi? Wait, you are giving us the initial, when we start with c d a e b? You only start with this. This does not matter at all. A different list would get different results. So this is the permutation, and I want pi to the minus one point So you take the value. So you have three four one five two point So the value at index one you put that index, that index has a value of index 3, et cetera. So c would go to position 1? Wait. OK. Is it true that you can run pi, so the number of times it will eventually equal pi inverse? Yes, but that is complicated algebra to prove that. Not forget that. Just like make that thing that you made and sort of flip it. OK. I like that. So 34152, one two three four five point Except this does not look very pretty, so I need to sort them again, right? So one 3, two 5, three 1, four 2, five four point Right? Did you guys come up with it now? Congrats. So this is good. This is how you compute an inverse. Let is figure out why you compute an inverse that way. Let is look at b. So b starts out at position 2, right? And then pi of five equals 2, which means that, after applying 5, b is going to go to position five point So pi inverse has to take b and put it where? Back to 2, right? Otherwise it is not a good inverse. So pi inverse of two point So the second element in the output has to be which element in the input? 5, right? Otherwise, this would not undo the effect of pi. So if you write out our permutation and split the index and the value, we get the inverse permutation. So you can compute that with a couple of lines of Python code. OK. So this lets us now compute some of the permutations there. So we only have to type up two, three, four, or something like that. It is a bit nicer and you guys do not have to type up any, because we gave them to you. Are not we nice? All right. Any questions about permutations or Rubik is cubes? Wait, so to get high inverse based off those numbers, you just well, it is the same thing. Wait, but five got flipped. Or you think the maybe if the inverse of that matrix then? So you take these two and you flip them, right? . And then you keep these bound, but you sort them. two 5, three 1, 4, no three five one two four point Oh they are still based off the top row? Yeah. Oh, OK. Wait, how did he get the second one? Based off the top row. So you sort this one, but you keep the bonds, so three ends up here and it gives it 1, four ends up here and it gives us two point OK. So this make sense? Good. We are remembering that, that is good. Now let is talk about a problem. So this is a Rubik is cube, this is how it works. Hopefully we will remember how to solve game. Let is try to solve StarCraft Well, of course we are going to cheat. We are going to solve a simpler version of StarCraft because it turns out you ca not really solve StarCraft with the computers that we have now. So let is make a few simplifying assumptions. Who play StarCraft, by the way? Two? OK. So you guys, please pay attention to the simplifying assumptions, because this is not real StarCraft. It is a lot easier, so that we can build a problem out of it. All right. So we are going to play with a race called Zerg. And so the idea of StarCraft is you build an army and then you take this army and you destroy your opponent, nice and simple. Good old violent games. So we are going to look at the build order part of the game. So the build order is the opening strategy and it takes care of the building process, so it is the strategy that says, what are you going to build and when, in order to come up with an army as quickly as possible? So the main goal is to amass an army quickly and then take that army and destroy the opponent. And yes, I know, not real life StarCraft, but let is go with it. OK, so these are the rules in our toy StarCraft And the Zerg is started with a building called the hatchery. And out of a hatchery the currency of the game, by the way, is minerals. We will write that down as dollars. So out of a hatchery you can build a drone by spending fifty minerals. You can build an overlord by spending 100, or you can build a Zergling by spending fifty point All right, what do each of these do? A drone harvests minerals for you, so it is a worker. So, for every drone that you have, you get eight minerals a second. So drone gets you eight minerals a second. As Zergling is your attack unit, so this is the guy that you want to build in the end. So this destroys your opponents. I do not know how to make a nice icon for that, so big smiley green. This makes it happy. All right. Overlords help you control your units, so drones and Zerglings are units. You ca not build for every eight units that you build, you have to have an overlord. Otherwise, you ca not build more units until you build overlords. So if you have eight drones, you ca not build a ninth on one you build an overlord. If you have eight drones and these eight Zerglings, you have to build a second overlord to be able to build more units. So one overlord can help you control eight units. In order to build a Zergling, which is what you want to do in the end, because these are the attack units, you need to spend 50, and you also need to have one building called a spawning pool. You what? All right. So how do you build that spawning pool? Drones can work for you, but they can also transform into buildings. So a drone mutates into a building, and after it mutates, it does not work for you anymore, by the way, so no more minerals. So a drone can mutate into the spawning pool for two hundred minerals, I think. It can mutate into a hatchery. That is the same thing that you have up here for, how much is it? 450. And it can mutate into an evolution chamber that we will talk about soon, for 400. OK. Why do we care about having more than one hatchery? One hatchery can build one unit per second, no more than that. So once you have a lot of drones and you are making a lot of money, you need to have a lot of hatcheries so that you can spend the money. Our goal is not to amass money, it is to build units, right? So money does not help you, I am going to spend it as fast as possible. OK. An evolution chamber lets you build let is you upgrade research to technologies. And these technologies are not like badges. Once you get them, you keep them. So you can research an attack upgrade and you can research a defense upgrade. They are both 1,000 minerals, but you only have to do it once. Why do I care about these? They decide how strong your Zerglings are. So, given a Zergling, at the beginning of the game, you do not have the attack upgrade, and you do not have a defense upgrade. So the Zerglings attack is one point If you research the attack upgrade, but you have not researched the defense one, their total power is one hundred and thirty three point If you research the defense upgrade, but not the attack upgrade, their total power is 1. 2. And after your research both of them, their total power is two point Again, oversimplifying. So, we have to build an army that is as powerful as possible. So in the end you want to have both of these researched. All right. Now there is one more limitation, that is, you cannot control more than two hundred of these units total, because even if you have a lot of overlords, your brain is not immensely huge, so you can only control two hundred units. So we want to build these two hundred units as fast as possible. And out of these two hundred units, we want to have at least one hundred and fifty Zerglings. If you build two hundred drones, you are not going to attack your opponent with that, those are not very useful. But you need some drones in order to make money, so you need the balance. So the goal is to get to two hundred units as quickly as possible, and at least one hundred and fifty Zergs. Yes? Evolution chamber. Easy, that is too much. OK. So how do we solve this? . So how do we solve this? Watch the pros play. Well, they are going to play real StarCraft this is toy StarCraft this is six level six StarCraft so it is not going to work. But there is a simple strategy, because I have not added one last constraint. Lets me guess. No. It is going to be harassing your enemy. But if you do not have to harass your enemy intuitively and build your economy first, so first build your drones and hatcheries, and then pop out Zerglings, right? So there is a greedy strategy. If you spend about an hour with a sheet of paper, you can realize what is the right order to build drones and hatcheries and overlords, so that you get to a nice big economy, and then, Bam Build Zerglings. Once you get to fifty drones, you start build Zerglings as fast as possible. So this is a greedy strategy, you do not need to do a lot of work for that. So we want to make things more interesting. So in order to make things more interesting, the game time goes in seconds. Everything that we had here is in seconds. Every two minutes, so two minutes, which is one hundred and twenty seconds. So every two minutes I want to assemble a small pack of Zerglings and send them to the enemy to harass them. And the Antonio enemy will defend themselves and they will destroy my Zerglings, but they wo not be able to focus on the game very well. So I need to do this in order to have a good chance to win. If I do not do this, my strategy is invalid. Does the enemy, does it do that to us as well? No. We are sending them facts. We are going to have a really fast strategy, because we are computing the optimal strategy, so they are not going to have time. They are going to be fighting us off. OK, how many Zerglings do I send? I have to send enough Zerglings so that the attack power at minutes 2m is six times log one plus m. You knew there has to be some mapping there. So the reason for this is, let is look at the first two minutes. After two minutes, if we have not researched any upgrades, we need to send this in six Zerglings. If we researched both upgrades, we only need to send in three Zerglings. If we researched one of the upgrades, we need to send in five Zerglings. So this is the total attack power, not the numbers are of Zerglings that we need to send. And is minutes? Actually, it is basically which attack wave you are doing, so every two minutes. Oh, OK. So the first one is m equals zero. And one point That is not the one attacking right in the beginning when we do not have Zerglings. . Equals 1, n equals 2, n equals 3, so on and so forth. How did you get that formula? OK. Is it making your life hard? Would that be logged base 2, or is that log base 10? Sure, log base two point Fine. OK, so how are we going to solve this? Intuitively, how did we solve all the game problems, all the problems recently? What are we going to do? . So the first thing we are going to build a graph, right? Yeah. So build a graph. The vertices are the states of the game, so a vertex shows me what state I am in and an edge shows possible moves that I do. So what I need to keep track in the vertex, what is my state? How much money you have, and how many units you have? And maybe how fast you are making money? Oh, unless the states, are states they are not movable? Oh, I guess they could be moveable could do nothing, in the next second, right? So you are saying you need to keep track of time, too? I do not know. OK so maybe time. What else? Badge thing. OK so upgrades. You said units, I am going to say buildings. Wait, is Zergling is a building? A Zergling is a unit, so Overlords. Unit, unit, unit. Building, building, building, upgrade, upgrade. So let is see how are we going to keep track of them. That is a good point. We started looking at units, we started looking at units. So how do I keep track of my units? What I need to know? The number of drones, overlords, servlings. Droids, drones, overlords, Zerglings. OK. How about buildings? PHEC Almost. So I want to know the number of hatcheries, because this is how fast I can produce. But then how many spawning pools am I going to build? Good. So that was StarCraft player one point Once you have a spawning pool, you can build Zerglings, there is no reason to build more than one. So a spawning pool is going to be like a badge. Once you build it, you have it, you are done. So it is Boolean. Wait, what is a spawning pool again? So a spawning pool is something that you build off a drone and once you have it, you can build Zerglings from a hatchery. So that is all it does. Why would you want two if you can build four Zerglings? So the spawning pool does not build a Zergling. See, the hatchery builds the Zerglings. So the spawning pool is just there. You need to have it to cross the edge. Otherwise you ca not. OK. I understand. OK. So what else for buildings? Whether you have it or not, right? OK. How about upgrades? a u, d u. So two flags, a u, d u. Cool. So now we have the thorny issues of money and time. Let is say that we are going to have some sort of approximation that is going to allow us to not keep track of money, because money is you can have a lot of money, so that will give us an explosion of states. So we are going to assume that we are spending money as fast as possible, because that is what you usually want to do. So should your money always be zero then? Almost. It is very close to that. So you start off with no money. You accumulate money, then you are going to issue some build orders and build something. And your money is going to drop, maybe to zero, maybe to almost zero. Then you wait to accumulate more money, issue another build order. Wait to accumulate more money, hopefully it goes faster now. Issue another build order. We are going to approximate that every time we issue a build order, so every time we tell our things to build something, the money will drop to zero. So that does not mean you can only build one thing and then your money drops to zero. If you wait for a few seconds and then you have two hatcheries and tell both of them to build drones, you build two drones and then your money goes to zero. So that means that if we model our states carefully, we do not have to keep track of money. You should probably keep track of time. Actually keep track of the rate you are gathering though, right? So what is the rate that you are gathering? It is the number of Oh drones, yeah., OK. So this multiplied by 8. So we should keep track of time. OK. So how would we solve it if we keep track of time? You multiply Can you do that layer thing again? Where is that? So you are going to have so what is a layer? Actually, never mind. I want to know what a layer is. Sorry? I want to know what a layer is. So last time we we solved problems by saying that, so we had the graph of streets. We had a highway graph. And that was a 2D graph. And we made it into a 3D graph by adding time as a third dimension. So we had layers, where each layer was, said that you are at a point in the graph at a certain point in time. So there is a layer four times 0, layer four time 1, so on and so forth. And you start at time zero and kept going up the graph. You have a flag that says, I have just purchased something? Because that way then you will know that you have completely exhausted your that maybe that will tell you that you ca not buy anything for awhile, right? Because if we are not keeping track of money then we should know. OK. So that is a good point. So if I have so suppose here I have to wait for five seconds to get enough money to do a move. If I keep track of time in my state and I have five things here. I also have to keep track of money, right? I have to know how much money I am getting, so that I know where I am buying things. On the other hand, in this case, if I keep track of both time and money as states, I can implement a precise strategy. I do not need this approximation. If I do that, then what search algorithm would I use? So if I have time in states, so each vertex in my note says that I get from some states to some other state in one unit of time. What algorithm do I use to search for my strategy? Yeah. Why do I use BFS? Because every edge has the same weight. Every edge has the same weight, right? So if we keep track of time, then we we keep track of time, we keep track of money, we use BFS, we have a solution. So. Let is try to not do it, either of these. If I do not want to keep track of time and I do not want to keep track of money, what would an edge be? If I want to say that, hey, this is a state and this is a state. What should be the edge connecting them. What other item you got is. Is that after a second? So the distance between these wo not be a second, right? If I have to wait for five seconds to accumulate enough to issue this build order that would get me the state then The time you have to wait? So that is what I would put on an edge. So this way I do not have to keep track of money, I do not have to keep track of time. So the graph is smaller. So I can look into bigger graphs. If I do this, what algorithm do I use? To find my strategy? . INTERPOSING VOICES So no time, no money. And? extra?. So this looks reasonably easy, right? I mean, if you want to get from one state to another, you see what you had have to build, you see how much it costs, and you see how much you have to wait to accumulate those resources. Except there is one glitch. How do we deal with this? How do we make sure that we do our attacks on time and how do we know that we are how do we keep track of them? What is this again representing? So this is that every two minutes you have to have a number of Zerglings that you are sending to attack the enemy. And the number of Zerglings that you need to have depends on the time and it depends on the upgrades that you got. So how do we keep track of this? If the edges are a function of time, then just know that at radius one hundred and twenty at radius one hundred and twenty over 5, then you had have to send more Zerglings. So what if not all the edges have the same weight. So let is look at how a graph looks like for a little bit. So we are going to have an initial state, say one hatchery and six drones and one overlord. And we want to build a new drone. Say we want to build a new drone. A drone costs fifty minerals. We have six drones. Each drone gets us eight minerals a second, so in one second we are going to get forty eight minerals. So bummer, we have to wait for two seconds to build one drone. And now we are going to be in the state of one hatchery, seven drones, one overlord. If you said we want to build a hatchery then we are going to need to accumulate four hundred or four hundred and fifty point Oh, we have to accumulate 450, using six drones, forty eight minerals, so I guess nine seconds. So we are going to have to wait for nine seconds to get that money. And then when we build, we are going to spend the drone building, because it is going to turn into a hatchery. And then we are going to end up with two hatcheries, five drones, and one overlord. So edges have different weights. So I ca not look at the radius in terms of number of his edges. Everything builds instantaneously. Yeah, sure. You could keep track of just the total distance from whatever starting build you are? Actually, if the distance from the origin to where you are at is a multiple of 120, then you should have another state that you have to. Assuming you have any drones left, hopefully you do. So that is modeling. One way of doing it is sure, model every round of the attack as one, every round of harassment is one there in the graph, and we can do it that way. Is that what you are saying? So you ca not once you are at one hundred and twenty seconds, you have to do an attack and then you get to the next layer in the graph. That makes a lot of sense. Of course that is what we were thinking. How about let is not do that. How about let is represent it without layers? So that is good. You are getting closer to the solution. It is much better than representing every time. Write the number of layers this time over 120, it is a huge improvement. Well, we can do it without any we can do it without any time notion whatsoever. Let is see, can I let you think about it? Oh, I can let you think about it for thirty seconds. So there is a key insight here that Ooh. Yeah. but if you figure how much time has elapsed, based on the items we have and our starting state, right? Because if we have two hatcheries and we started with one hatchery, we know that at least nine seconds has elapsed. Well, so I like the first part of what you said, the second part is too complicated. But we can know what time we are at. Why? Because it takes a certain amount of time to achieve everything, each thing. Are we assuming that we take the shortest path to get to each state that we are at? So we are using the extra. How does the extra work? You have a queue, a priority queue. You extract a node, you look at the neighbors. When you extract the node, do you know the distance to that node? Can you explain? You ask? I am asking. I know, but like the node asks and says, how far away are you? So you need to keep that in the priority queue. So the extra the main invariant is that once you pull out the node, you are not going to find any shorter path to that node. So you already know the shortest path. That how you sort the nodes in the priority queue. So when we are at a configuration Say we are at some configuration here, two hatches, six drones, and five Zerglings. We already know that, say we are at time one hundred and nineteen seconds. If what I want to do next is build another hatchery, then I have to wait, what, six drones, same thing as before. I have to wait for nine seconds, right? So the edge would look like this. And then we are going to get to three hatcheries, five drones, five Zerglings. This crosses a one, this crosses a two minute boundary, right? So when I cross this boundary, I had better have enough Zerglings to do an attack. Do I have enough Zerglings to do an attack? No. So is this a valid move? Is this the valid edge in our graph? It is not. So when you are at a node, you already know the time that you need to get to that node, so when you generate the neighbors, you can check for each edge to see it crosses that one hundred and twenty second game. Now let is assume it does. Let is see how this works and this is the last thing we are doing. So suppose you have two hatcheries, six drones, and eight Zerglings. And you are going to build that same hatchery. So you are going to go past this one hundred and twenty second mark. What state are you going to end up in? How many hatcheries? Three. OK. How many drones. Five. How many Zerglings. Two. Yes. So key elements, two Zerglings, because this edge crosses the 120 second harassment boundary, so you have to send in six Zerglings and you are going to lose them. So we are taking advantage of how the extra works to sort of generate our edges on the fly. So we would not be able to regenerate this graph, even if we wanted to have to. We have to work with the implicit representation and, as we learn the distances to the nodes, the minimum distances, we also learned the edges that we have coming out of those nodes. So it is kinda of like this graph that is growing and we are like as it gets to a certain point we kill a bunch of paths and then it keeps on going. Yeah. Does not this makes sense? So the good news is that this is like we are training you to run a 10 mile marathon, so you can run fifty meters for the test. Let is still try to get it, because I think it is a cool problem. 
</body>
</html>