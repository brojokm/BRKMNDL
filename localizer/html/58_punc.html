<html>
<body>
In this class we are going to talk about AVL trees. In the last class we have seen binary search tree data structure. One problem with the binary search tree if you recall is that the operations of insertion, deletion and search take time proportional to the height of the tree. Height of the tree can be very bad. We saw an example were the height of the tree could be as bad as order n or n 1. We want to some how create a tree which does not have too bad a height. That is what we are going to do today. We are going to look at this data structure called AVL trees. What is an AVL tree? AVL trees are also called height balanced trees. Ignore the white spots that are showed on the slide below and they should not have shown here. This is the binary search tree and inside the nodes are the keys. Everything which is less than the root is to the left of the root and everything which is more than the root is to the right of it. The thing that is written next to each node is the height of a node. What we will call the height of a node? We have not defined this term yet. We will just say the height of a node is the height of the sub tree rooted at that node. For instance if I look at this node 78, all the things which is below it is the sub tree rooted at this node. What is the sub tree rooted at a node? It is just the set of descendents. I am looking at the tree which is on the right and in previous classes we have defined the height of such a tree as two and not three. Because we had said that seventy eight is at level zero and fifty is at level one and forty eight is at level two and so we called the height of the tree as two. We will just modify, we will say that if it is the singleton node just one node then it is of height one instead of height zero as we have been calling it. So level numbers are beginning with one. This sub tree fifty has height two and this sub tree seventy eight has height three and this entire tree has height four. We are going to call this as height of the tree for the purpose of the AVL tree. With every node I have put down the height of that node. What is the height of the node? It is just the height of the sub tree rooted at that node. All the leaves will have height 1, the parents of the leaves will have height two and so on. Such a tree is called AVL tree if it is height balanced. What is height balanced? If I look at any node and its children then the difference in their height is at most one. There might be no difference in their heights, as in the case with the 50th node. Its two children have the same height. The node seventy eight has the difference, the left sub tree has more height than the right sub tree. The left sub tree has height two and the right sub tree has height one. The node forty four also has a difference of one. The right sub tree has height three and the left sub tree has height two. But the difference is no more than a one. This is the AVL tree. This is what our definition of an AVL tree would be. It is true for every node of the tree. The binary search tree has two properties. It has to be a binary search tree and for every internal node of the tree, the heights of the children differ by at most one. Why have I said internal? For a leaf node it has no children. It does not make any difference to talk about the height of the tree. So for this node seventeen the right sub tree has height one. The left sub tree is missing so we call it height zero. Now you understand why I had made this change. If the tree is absent then I will denote the height as zero. And the single node will become height one. That is why I have to shift the definition a little bit. Let us see what is not an AVL tree? So recall that one of our binary tree which was very bad, which had a huge height was a tree like this. This is a binary search tree and I put some keys so that it looks like a binary search tree. This has height equal to n 1, if there were n nodes. Is this an AVL tree? No. Is the last node height balanced? Yes, since it is a leaf node it is height balanced. Is the next node height balanced? Yes, it is also height balanced. Is the node following the 2nd node height balanced? No because the right sub tree has height two and the left sub tree has height zero. Thus the height balanced property is violated here. It is also violated in the following nodes. Thus we will never have such kind of trees as AVL trees. Since we said that we are not going to have such a kind of trees as AVL trees, let us try and figure out how bad the height of an AVL trees can be. Let say I have an AVL tree of n nodes, if its height can still be as bad as n 1 I have not gained anything. I would like to say that its height is no more than log n or something. We will figure that out and that is what we are going to prove in the next few minutes. The height of an AVL tree t which has n nodes in it is only order log n. Let see why this is true. I am not going to prove this claim directly, I am going to make a slightly different argument. Let us take an AVL tree of height h. Amongst all possible AVL trees of height h, let me see the one which has the smallest number of nodes. I defined this quantity n h as the minimum number of nodes in an AVL tree of height h. Let us figure out the quantity and then we will see how this implies the proposition. Given an AVL tree of height h, we want to find out what is the smallest number of nodes it has. Can it have only h nodes? Then we will be in trouble. We want to say it has many nodes, if you recall a binary search tree of height h can have only h plus 1 nodes like the example that I showed you. But a good tree which is like a complete binary tree of height h will have nodes. What we would really like is that our AVL tree which was of height h has large number of nodes, not just h but more like or something like that. That is what we are going to prove. Let us understand the quantity. It is the minimum number of nodes in an AVL tree of height h. What is an AVL tree of height 1? It is just a singleton node and nothing else. It has only one node in it. If I have an AVL tree of height two then it has root and one node. But it can also be root and two children. Why have I written n 2 equal two and not three because I am counting the minimum. That is why n 2 equal 2, the minimum number of nodes will be just two in an AVL tree of height two point Suppose if I have an AVL tree of height three or more, it will contain one root node. Suppose if I have an AVL tree of height h, it will contain one root node and an AVL tree of height h 1 on one side and an AVL tree of height h 2 on the other side. Why h 1 and h 2? It has height h so its children can have height only h 1 and not more than h 1. They can have a difference of at most one. If one of them is h 1 the other one can only be h 2 or h 1. One of the sub tree has height h 1 and the other sub tree has height h 1 or h 2. But what will we pick? We would like that the other sub tree should have height h 2. Why? Because of minimum number of nodes. A tree which has smaller height will also have smaller number of nodes, so we would like that the height of the other sub tree to be h 2. If n h was the number of nodes in the tree of height h, then what is the number of nodes n h equal to? It is the number of nodes in a tree of height h 1 the smallest possible, because the left sub tree which is of height h 1 can have as small as little number of nodes as possible and in the right sub tree which is of height h 2 also has little number of nodes as possible. The number of nodes in the left sub tree is n h 1, the number of nodes in the right sub tree is n h 2. There is one root node and the recurrence relationship would look like this n h equal 1 plus n h 1 plus n h 2. Once again we are seeing the recurrence relation. This is what we have to solve today. What are the base conditions? We know n 1 is one and n 2 is two. With that you can figure out what n 3 would be? n 3 would be 1 plus 1 plus 2 which is four and so on. But we would like a close form expression to do this. So we will solve this recurrence. We are not going to be solving this recurrence exactly. We are going to do it approximately. First we use the fact that n h 1 is only going to be larger than n h 2. Because as the height of the tree grows the number of nodes cannot reduce, it will only be more. So n h 1 is at least as large as n h 2. Then this implies what we had written earlier that is n h equal n h 1 plus n h 2 plus one. This quantity is at least as large as 2n h 2. Strictly larger because I also dropped the one. I have replaced this n h 1 by n h 2 and this 2n h 2 is what I get. n h equal n h 1 plus n h 2 plus one greater than 2n h 2 This becomes the simple thing to solve, n h is more than 2n h 2. This is what I will solve. So n h is more than 2n h 2 and now n h 2 is more than two times 2n h 4. This implies the entire thing n h is more than 4n h 4. Which implies that the entire thing is more than 8n h 6. You understand how this comes n h 4 is more than 2n h 6 and so on, which will eventually take us to something like after i steps n h 2i. Suppose I pick, I am going to assume that this quantity is an integer. Let us assume that h was even to begin with, so this is an integer and for this value I will get n h greater than in which I replaced. Recall n 2 was 2, so it becomes. What does this say? We just argued that if your AVL tree has height h then it has at least nodes. That is at least so many nodes. What is the maximum number of nodes it can have? Something like, one of those because it can be a complete binary tree. Suppose I were to take logarithms, what would I get? I would get h less than 2log n. So n h is actually less than n because I have an AVL tree whose height is h and it has n nodes. Suppose I had an AVL tree of height h and n nodes then it will also satisfy this relation h less than 2log n h. It will satisfy the relation because n is only going to be larger than n h. What was n h? n h was the minimum possible number of nodes. Any AVL tree on n nodes has height at most 2log n from this argument. The h less than 2log n h is what we argued after taking algorithms. Let me take a tree of height h and n nodes. So n is going to be larger than n h because n h is the minimum number of nodes that are possible in a tree of height h, n h is that quantity. This n is just a function, do not confuse this n with the number of nodes. You can replace this n with something else. n h is the minimum number of nodes in a tree of height h. What we argued was that h less than 2log n h. Take an AVL tree of height h and m nodes. Its height is h and it has m nodes in it. What does this implies? The m greater than n h, this follows from our definition of n h. We know that h less than 2log n h which is then less than 2log m. This implies h equal O log m. The h is the height and m is the number of number of nodes. The height of an AVL tree on m nodes is less than two times log of the number of nodes. That is what being said here. We have shown that such a tree will have height no more than 2log n. The best possible tree could have height only log n if it were like a complete binary tree, very dense and every thing. But this has more height but not too much, just a factor of two more. Much better than having a height of an n. Let us try and solve this recurrence slightly better. This is more of an exercise also to show you how recurrences are solved. We did fairly crude analysis, we replaced n h 1 with n h 2 and then we did the steps and got the result. Let us try and get something better. It is just an exercise. We will show how to get a sharper bound on the height of an AVL tree. The bound we obtained is 2log n. Let see if we can get something better than that. We are going to use induction and we are going to do a tighter analysis of the same thing. We are going to show that the minimum number of nodes in an AVL tree of height h which was n h is at least c times h that is where c will be some constant more than one. What did we show in the previous slide? The n h was at least. What was the c? It was, there we showed a c of. Let see if I can get a higher c that is a larger c more than. What would be the way of doing such a thing? We will assume that n h is at least as large as. We are going to prove this by induction. We will figure out what c is later. We are proving a certain statement without actually knowing exactly what the statement is because I am not telling what c is. But you will see what the c has to be for the statement to be true. What is the base case? h equal 1, say n h is one. This statement n h greater than equal is true at h equal 1. We have said the number of nodes is going to be at least as large as. I assume that I made a mistake, let us come back this base case again. We will have to perhaps redefine the height of a tree. I think we should have or some thing. Suppose the claim is true for all h less than k and lets try and prove it for h equal k. We have to prove that n k greater than equal. We will come back to this base case in a minute. So recall this n k equal n k 1 plus n k 2 plus one was our recurrence relation. Our induction hypothesis says that n k 1 is at least, n k 2 is at least and I have ignored this plus one. Actually I can say that this is strictly larger. I can show that n k is larger than if I can show this quantity is larger than . This is what I have to show is lager than. What should be the value of c so that this greater than equal is true. I just cancel out the terms appropriately and I get. If c satisfy this then this greater than equal will also be true. Why because I just multiply both the side by and I would get exactly that. If this greater than equal is true then n k which is larger than this would also be larger than. I just have to pick c which will satisfy this. You all know how to figure out c which will satisfy this. We will just solve this quadratic equation and this has roots. This is negative, so anything in between would keep this less than zero. But I want as large as c as possible, so I will take which is roughly one point six three. This quantity is also known as the golden ratio. Perhaps we will see this more often. This n k equal n k 1 plus n k 2 plus one is not a fibonacci relation. If you add one to both sides, so n k would be with the fibonacci number minus one. You can also do that. We get a bound of roughly one point six three that is c as one point six three. What is the mistake we have made? One thing is base case have not worked out. I guess this was the wrong thing to pick. It should not be but may be. So induction hypothesis should be. Let us take, it will not make a difference. We take the so precisely I am dividing out by c then the base would have also be satisfied. If h equal 1, you would have more than one which is the case. And sorry about the base case, for the other two also it will be okay. Because for h equal 2, n 2 is two and this would become which is c. The c is less than two because we just argued it is one point six three. So please make that correction, we really require that the induction hypothesis is h 1. It will not make any difference on this n k greater than equal how ever. If this n h greater than equal become h 1 then this n k greater than equal will become k 1. This would continue as it is. This will become. We have to prove this is greater than or equal to, every where there will be a minus one. So that you will still get the same quadratic in equality. The value of the c would still turn out to be the same. That is for n h please make that small correction. Thus the AVL tree on n nodes has height atmost . We just do the same argument as before. I take a tree of height h and n nodes. We have just seen that, this is the tree with smallest possible number of nodes. So n is going to be only larger than this that is. Let us take log on both sides, we get equal h 1. I am just using the definition of log. I am taking, so I will get h 1. This implies h equal plus one. We are able to prove this kind of a sharper bound. This equation also works for n equal 2, so that was our base case. Let us continue. I have shown you the two ways of solving this same recurrence. One was the much simpler way, actually both are very simple. The 2nd technique is also used quite often. You make a guess on what you think the right value should be. Then essentially you verify that. We said that suppose the right value is some and then you figure out what your c should be. You can get something better, earlier we had that is one point four one four and we could update to one point six three by using this kind of a technique. Let us look at the structure of an AVL tree in detail. Once again I have an AVL tree on n nodes. Let me take the leaf of this tree which is closest to the root, which means whose level number is the smallest among all the leaves. Suppose this leaf is at level k. We can show that the height of the tree is at most 2k 1. This requires the proof and let us do that. I have an AVL tree which has n nodes in it, although the number of nodes in the tree is not going to be particularly important. This is some tree, I took that leaf of the tree which is closest to the root. Suppose the red dot is the leaf which is closest to the root. We said that it is at level k. So the other leaves could be at this level or could be below. In this class for AVL tree we work with level starting with one. It does not make a big difference, let us say we start with level one. We are going to prove that the height of this tree is at most 2k 1. So the height of this tree is that is what we will prove. Let see why. I will draw this picture again. This is the leaf which I have colored red is at level k and it is the one which is the closest to the root. From the node which is next to k, there will be some sub tree hanging out. From the next node also there will be some sub tree hanging out and so on. The first node is my root at level one. Let us look at this node which is at level k 1. What is the height of this node at level k 1? It has one child and this child has height one. The heights are in blue. This means this sub tree at level k 1 can have height at most two. We want to get as larger height as possible for this tree. Whenever we say at most two will just take the largest value. This can have height 2, if this has height two then what is the height of this node? This sub tree will have height three. If this sub tree has height 3, what is the largest height that the next sub tree can have? It can have four point What is the height of this node? It is five point What is the maximum height this sub tree can have? It is six and this node would be 7, nine and so on. What will be the height of the root? In general given that this was k, just figure it out, it should be 2k 1. If it was just till the node three then it is basically k equal 2 height equal 3. If k equal 2 then the height equal 3, if k equal 3 then the height was five. If k was four then height was seven and so on. For arbitrary k this is 2k 1. It is a very simple argument which means that this entire tree can be no taller than 2k 1, if the closest leaf was at level k. This is the property of AVL tree and not a property of any arbitrary binary tree. In an arbitrary binary tree you might have leaves at any level. But the height of the tree could be as bad as you wanted. Here is a leaf at level 1, But for an AVL tree if there is a leaf at level k then the height of the tree can not be more than 2k. So in any AVL tree basically all our leaves will be in the shaded part of the above slide. This band whose width is as large as this roughly and both of them was k so I am ignoring that. I will just come back to this in a minute. We just argued that if the closest leaf is at the level k then the height of the tree is no more than 2k 1. That is the largest possible height the tree can have. Let us make another claim. If the closest leaf is at level k then all nodes at level one through k 2 have two children. Every node on these 1st k 2 levels should have two children. Why have I said k 2 and not k 1? Let us prove this by contradiction. What do we want to do contradict? Let us take some node at level k 2 which has only one child. The picture is given in the below slide. I have a node u at level k 2, it has only one child which is at level k 1. I have shown a node at level k 2 but the same argument would apply to any node at one through k 2. So v is at level k 1, it cannot be a leaf because our closest leaf was at level k. So it has to have another child. I have shown only one but it can also have two children. But this u has only one child. So sub tree rooted at v has height at least two because this should have one child, it cannot be a leaf. It has height at least two while the right sub tree here has height zero because there is nothing there. So we have a height imbalance at this node u. The height balance property is violated at u. Every node on these levels one through k 2 should have two children. At level k 1 how ever there can be nodes with only one child. This is level k, of course the tree extends. The dot on the left side is the level at which the closest leaf is situated. At level k 1, I can have a node with only one child and that child is the one which is in the middle. And provided it would not have any more descendants. It need not have descendants because it can be a leaf. This is completely okay but if it had more descendants then we would again have a problem in height balance property. This is okay which means that the node in the level in k 1 can have only one child. But everything which is in the 1st place should have at least two children. We said every node at level k 2 should have two children which means levels one through k 1 are full. It means they have as many nodes as possible on that level in a binary tree. This is after all a binary tree. So they are full. What does that mean? That means the tree has at least nodes. We also argued recall that the height of the tree is at most 2k 1. If the height of the tree is 2k 1 then it has at most nodes. This implies the number of nodes in the tree which was n is between and . Since we have been using h for the height, let us substitute h for 2k 1. Let us see how this equation would look like. This becomes and this becomes. This is the same thing I am showing you again. What is this saying? If you have an AVL tree of height h then it has at least which we had shown earlier. Now we are showing just roughly the same thing nodes, all though we have proved the sharper bound. I am coming back to the older bound. The point is it has an exponential number of nodes, it has number of nodes which is some constant an exponential. Because that gives the logarithmic height property. This is actually a third way of proving that the height of the tree is only log n. You can also use this as a proof. This did not require solving a recurrence relation. The other two methods we saw while solving the recurrence relation. But the sharpest bound we have seen so far is that is. Let us summarize what we have seen as the structure of an AVL tree is concerned. If the height of an AVL tree is h then the closest leaf can be at level. I have just changed things around, when I said when the closest was at k then the height was 2k 1. If the height is h, suppose I give you an AVL tree on n nodes of height h then the leaf which is closest to the root is actually pretty far from the root. It is atleast half the height away, it is at least away. It does not require a proof, I am just rewording what I have said earlier. We also saw that on the first levels the AVL tree is a complete binary tree. This is what an AVL tree looks like essentially. For the first half levels it is complete, very dense and then it starts thinning out. So it turn the tree around with the root at the bottom so initially it is dense and then it thins to the full height. But the fact that it is very dense for the first edge by two levels means it has a lot of nodes. It is a complete binary tree so it has nodes straight away. That means that the height can not be too large, if I had n nodes the height can not be more than 2log n. Once again I have said that if number of nodes in the AVL tree is at least just this fact, since it is a complete binary tree on levels it has at least and at most nodes because that is the height of the tree. This is the useful structural fact to keep in mind about AVL trees. Although we will not use it for any of our algorithms. But it just gives you some intuition of what the tree is and why is that this tree has only a logarithmic depth. We have looked at this height balance property, we said if this height balance property is there then it is nice the height of the tree is only algorithmic. We want to say that all our operations are only logarithmic because we still want to say that you can do a search, insert and delete in log n times. Search is easy there is no problem with search because after all it is a binary search tree. Forget the height balance property, it is just a binary search tree so you just do search as you do in a binary search tree. How much time will you take? Proportional to the height, order h. Height is log n so you will take only log n time. That is the best you can do in some sense. Suppose you were to try an insert. When you are going to do an insert what can go wrong. Recall for the tree to be height balanced, if the difference in the heights of its children is at most a one. When I insert a node it can change the height of some nodes and as a consequence the height balanced property might get violated. The first step of insertion would be the same as we did in the case of a binary search tree. How did we insert in a binary search tree? First you find the position. How do you find the position? You will just search for that element that you are trying to insert, that will tell you where the position is and just put the node there. And then you start marching up back to the route by following the parent pointers. As you march up you keep updating the heights of the various nodes you encountered because these are the only nodes whose heights could have changed and no one else. We will look at this again in more detail perhaps in the next class. I am just giving you the flavor of what needs to be done when we are doing an insertion. These are the nodes whose heights are going to change. So we are going to the first place where the height change appears, where the height imbalance happens. We are going to only start from the node where we inserted and move up the tree towards the root. Basically we keep going parent, parent till we hit the root. On this path that we follow, we find the first node which has the height imbalance property. Suppose that node is called z and its grandchild is called x. Let me skip this part and y is the node in the middle. So I think it is best if I show you the picture and that will give you an idea. Suppose the 1st one was my tree, forget this empty node which is the last node for now. This was my tree originally. If this was my original tree, then is that an AVL tree? Height balance is satisfied in the node fifty because forty eight is one and this sixty two is one. The last node is not there, forget this type of node. This seventy eight is also height balanced because this fifty is two and this eighty eight is one. This is also height balanced because this is one and this is 0. This is height balanced because this is two and this is three initially. But now suppose I went and inserted a node fifty four which came in here. The fifty four would come here, I go right, left and then right here and left here. Now the height balance property is violated. What I am going to do? I am just going up the tree towards the root. Is the height balance property violated here? No it is not. This is one this is zero. Is it violated here? No, 1, two. This is height 2, this is height one. It is not violated here. Is it violated here? Yes because this is now three and this is 1, so these numbers are the new heights. This is three. So this seventy eight is the first node at which the height balance property is violated. We call this node seventy eight as z, its child will be y and its grand child will be x. We wonder which child of this node will be y. The child on the path that we have taken. And now we need to do something to this tree to make it height balanced again. This is not height balanced tree. All the things we said about log n will go out of the window if you leave the tree like this. What are we going to do? We are going to do a kind of rotation operation and this 2nd picture in the above slide will become my new tree. In some sense what I have done is, I have moved sixty two up and moved this seventy eight down and this fifty was here. It looks a bit mysterious. That is what we are going to do in the next class. Understand how this rotation operation is done. So as you can see now the height balance property is not violated at any node. It is not clearly in the node 50, its not here in sixty two and also in seventy eight. Both of them 50 and 78 have height two. The sixty two is at height three and this seventeen is at height 2, so it is not violated. This is still a binary search tree with the same keys as before, we will not change the keys. There are other ways also but you want an automated way of doing it, you do not have to draw the picture and then figure out what rotation have to be done. You will be able to do this program. This is what we are going to do in the next class. Look at insertion and look at how to do these rotations so that the height balance property is retained even after insertion. So we will look at both insertion and deletion in the next class. So in todays class we looked at AVL trees. We saw how AVL trees are defined and actually we proved a bound of as the height of an AVL tree. We spent a lot of time figuring out how to solve that recurrence relation. We saw two ways solving that recurrence relation. We also looked at some structural property of the tree which also proved a similar bound and the height of the tree. With that we will end today is class. 
</body>
</html>