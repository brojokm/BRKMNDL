<html>
<body>
OK. Who is going to lecture? Wow. Nice. Does lecture make sense? One, two, three sort of. OK. Then I am going to have an easy job. So any pointed questions? Any specific pinpoints? We talked about DFS, but DFS and BFS are sort of related, so I am happy to take both. The classification of edges? OK. We are going to talk about that for sure. Anything else? I thought it was funny that in undirected graphs, you could have a backward or something like that. You do not have to give a radiance. I will derive it. OK So what edges do we have in directed versus undirected. OK. What else? Cool. So I am going to go through the concepts in DFS really quickly. And we are going to focus on this. Because it seems like this is where the issues are. I want this. So what is a graph? Interconnected notes. OK. Fancy names. Come on. We had this in the last workshop. A set of edges and vertices. All right. How do I draw my vertices? Dots. Circles. Dots. How do I draw my edges? Dots. Lines. Oops. Looks like a graph? What kind of graph? Directed. Because there are arrows and not straight up lines. Right? How do we store graphs in Python? Fancy name first and then implementation. list. OK. What is an adjacency list in Python? It just shows what notes are adjacent to other notes. OK. So what data structure do we use? What elementary python data structure do we use? A dictionary? All right. So an adjacency list is a dictionary that keys our . OK. So the keys are the vertices. So on and so forth. And what are the values? The nodes? Adjacent nodes? OK. A list of something. So after our presentation, is the object the one that has edges and the simplified one that has vertices. So suppose I want to go for the simple one. Where vertices do I have in A is list? B and G. Right? B and G. Sounds good. Right. What vertices do I have in B is list? C. Why do I not have A? Because it is an arrow, so it ca not get to A. Yeah. So the nodes that I have in the list are the nodes that are reachable from that node. I have an edge from B to C, so C is reachable from B. I do not have an edge from B to A because my edges are directed. So A is not there. OK. Let is write a bit of pseudo So although it is Python, let is say our graph is represented by a class G. Let is say in this class I have a dictionary called al, which has what we want. If I want to get all the vertices in the graph, I want to write the method that returns all the vertices. What should it look like? Just to make sure that we are all getting the data structure. . OK. So the keys are in the vertices. Now, given the vertex, I want its neighbors. How do I write that? You mean only the vertices that it can go to? Yeah. Yeah. Dictionary and that vertex. So return dictionary al bracket vertex v. Cool. OK. So this makes sense for everyone, right? Let is start writing DFS because no one said they do not understand DFS. So let is say we have a DFS procedure. And it gets a graph. And it has to do DFS. What do you need for DFS? Starting points would be good. Just like for DFS, right? So how do we do DFS? Start with one node and then we keep on following a path down by picking the first vertex. So like for A, we had start with A. Then we had pick the first vertex in its list. And then we pick the first vertex in that one is list, first vertex in that one is list, until we run out. OK. So basically you start today. And for every neighbor, you recursively do DFS on that neighbor. Right? So since this is recursive, let is write it in a recursive manner, nice and easy. So say DFS calls DFS visit of g and s. And let is say DFS visit takes the graph, takes the node that we are visiting, and how are we implementing this? Just return. No. It marks as visited. OK. Marking something as visited is important to lead this. So what is the main thing that you do in DFS? Iterate over the neighbors and recurse. Right? So for n in g neighbors of v called DFS visit of g and n. So this is the basic idea. It has some holes that we need to fill because otherwise it does not quite work. This is going to recurse forever, which is not very good if you have a time limit that your code needs to obey. So how do I make it not recurse forever? Every time you visit, you are about to visit a node, check if you have already visited it. All right. So we should keep track of the nodes that we have already visited and not visit them again. Right. So you start with A, go to B, go to C, you had better not go to A again because you have already been there. So let is implement that this way. Let is make a new object called DFS result that is sort of that drawer that you have where you stick everything in where you do not have a good place. So everything I do not have a good place to put it, you just stick it in a drawer. And then you can close the drawing that be like, it is clean. Everything is clean. So let is say DFS result is that drawer. Everything that they need from now on, we are just going to stick in there. So I have an object DFS result. And we are going to figure out what we put in it. But at the beginning of DFS, I am going to create that. So create the new object. And then I am going to pass it onto to DFS visit. So now we have a drawer where we can put everything we want. So let is keep track of the visited information here. How would I keep track of what nodes I visited? In a list? In a list. So if I do a list, it turns out that in DFS, and VFS, for that matter, you check if you visited a node pretty often. So it would be kind of slow. So let is have a dictionary. What are we going to put in that dictionary? The node and listed. OK. So we are going to have a visited dictionary. And then the keys are going to be nodes. And let is say we are only going to put the nodes that we visit in it so we do not have to initialize it. And the values are going to be true. Because if the node is in the dictionary, it means we visited it. So for all the nodes that are in there, visited is going to be true. Sorry. OK. So where do I fill this in? Let is use it. Four n and g neighbors, set it to true. But before that So here? R not. Um. OK. So let is say this. Let is say these are lines 1, 2, three point Line one point five or 2. 5? So at n 1. 5, check if v is in the dictionary. Here? OK. If v in r dot visited, then Return. Then 2. 5, set r dot n to true. You would only do it n times Wait. So here you are saying say r dot visited of n equals true? Oh, no. Change the v in v visited return, change that into a loop. Put that after the loop. Put that into the loop. And it is n visited to the. n in r dot visited we probably want not n, right? . OK. R dot visited is true and then the DFS. So will this achieve the thing that I wanted at the beginning. You start at A, you go to B, you go to C, and then you do not go to A? Not quite. We have not had our starting yet. Yeah. We could add V at the beginning and check at the end. Because that is only the visited, right? So I think I like Christian is suggestion. r dot visited of v is true. And then we can remove it from here. It has to be because the other case is going to cover for if you visited again. But the first time it is being called, it is not checking Well you mean the first time here? The first call that is being made, and the recursive call, it is going to be as if it is not into the visited node. Yeah. But this is at the beginning. Right? So this calls DFS visit to the starting node. Do we care? So I think this should work. It is not the only way to write it, but it is reasonably clean. It is easy to reason about, and it works. Does it make sense to everyone? OK. We are going to change things a little bit. So instead of using visited, we are going to keep track for every node of its parent. So the node that we visited from. So we are not going to use visited anymore. Instead we are going to use parent of v is going to be some other node. So what I want is for this graph, I said I am going to go from A to B, and then from B to C. So I want the parent of B to be A, and the parent of C to be B. Make sense for everyone? So what is the parent of A? None. None is a good value, right? There is no parent. OK. So how would I modify this code to write that? Stick a line in two point seven five and establish 3b as the parent of n. So r dot parent? Yeah, of n is v. Of n is v. Good. And I do not have visited anymore, so this line is going to blow up. So what do I do instead? Oh. It does not have a parent? Yep. So if it does not have a parent, we did not visit it. So the parents works just like visited, except the values are not going to be all true. They are going to be something a bit more useful. We ca not test for none because the first one has a value of none. But they are not testing for none, we are saying is it in the dictionary or not? Oh. OK. That is a good point. You could be testing for none. That would not work. So you have to write the check like this. And we are going to erase this because otherwise, it is going to throw an exception. And what else do we need? There is one missing parent. Inverse form? OK. Where do I say that? In DFS. OK. One, two, three, which line? 1. 5, 2. 5, 3. 5? 2. 5. 2. 5. All right, so here. What do I write? Yes? Parent of s is none. OK. So r dot parent s is none. So now this works. Right? Any questions so far? Nope. Basic DFS works. Everyone is happy with it? Let is try to track it for this graph here. And you are going to be in a better position than me because I am not sure I can see the graph all the way from here. Almost. So let is have the parents or the parent is dictionary here. And here, let is write the call structure as it will happen. So where do I start? DFS of A, right? DFS of A. And this is going to call DFS visit A. What are A is neighbors? b and g. Cool. Is b in parents? What is in parents, at this point? Just a. Oh. A is none. Good. Excellent. So B is not in parents, so what am I going to do? And it is the parents in visited. Right? What is B is parents? A. OK. I am going to call DFS visit of B. These children. C. Is C parents? No? What happens? Feel free to take over. When you get it, feel free to start talking, and I can just write. Of C. OK. What else? C is parent is B. So I am in B. The only child is C. C is not in parents. C gets in parent. C is parent is B. Call DFS visit of C, what are C is children? and d. So we are wondering about the order, right? Let is assume that in the adjacency list, all the nodes are in alphabetical order. So I am going to have A, D, and F. OK. Is A in parents? Yes. Is D in parents? No. So what happens? Parents visit D. D is parent is C. D is neighbors? E and F. E is in the no. . Cool. Does E have any children? No. So I am done. I get out of it, right? Is F in parents? No. F is parent is? Cool. F does not have any children. Right? So I get out of this DFS visit. I am done with F. So I get out of this visit. And I get back to this one. I am done with D, and I am at F. Is F in parents? OK. So what kind of edge is C to F? Forward. OK. So forward maybe tree. Let is start with the easy ones. So now we have gone forward with AB, BC, CD, DE, and DF. What kind of edges are these ones? Tree edges. Does anyone know why they are called tree edges? So if you look at the parent pointers that they have there, they are going to end up defining a tree. And the tree is, the tree shows the order in which DFS looked at the notes. So let me erase this and draw the tree for DFS that we had so far. So we started at A, then we went to B. Then we went to C, then we went to D, E, F. So this is all part of the DFS tree. You can see that for all these nodes, their parent pointers point the right way. So if you have parent pointers for every node, this is going to give you a tree. So these are tree edges because they are part of this tree. So now we have this edge from C to F. And this is what kind of edge? Forward edge. Why is it a forward edge? Somewhere up higher in the tree is trying to get somewhere lower on the tree. It is going forward in time. So it is going from a node in the tree to a node is child in the tree. Sorry, not child. Descendant. So F is strictly under C. So yeah. It takes us forward in time. It is a shortcut in the tree. So that is why it is a forward edge. So we now have two types of edges so far. Tree edges and forward edges. So tree edges? Yep. So the tree edges are the ones that DFS follows. All of these are tree edges. Yes. So like an edge from B to C, why ca not that be a forward edge? Because technically it is not a shortcut, right? But it is saying it is pointing to the children, but it only has one child. Because that is the edge that DFS took. So the edges that we actually follow in DFS have a special name, and they are tree edges. So first off, the most important edges are the edges that make up your DFS tree. And that is why those are tree edges. We do not even look at the other types. If you have an edge and DFS followed it, it is a tree edge. Done. So these are all tree edges. We do not care about the other definitions. So do not be ashamed to ask questions about this because this is hard to understand. It is an issue we are trying to clarify here. So the point, why we are doing that example, is to figure this out. So please do ask your questions. Yes? So is it edges that are followed at any point during the search process? I guess they are edges that never get touched. Right? Yep. So when I am at C, and I look at this edge, F is already in parents. So this edge is not going to be followed by DFS. There are some other types of edges that will not be followed. And we will get to that by the time DFS completes. Yes. You mean that like G to C is not You are ruining my example, man. I am supposed to ask you that later on. So let is let go through it and see what kind of edge it is. You are right, but let is pretend we do not know that. And we will see as we follow the DFS. OK. So yep. That one is a forward edge. We will deal with it later. We are here. We decided that C to F is a forward edge. F is already in parents. So we are going to return from DFS visit C. We are in DFS visit V. We are done with C. Do we have anything else to do here? So we go up to A. We are done with B. And we look at G. A to G. Is G in parents? No. So we are going to call it. So A, B. DFS visit G. What are G is neighbors? C. OK. So is C in parents? Actually I was wrong. Sorry. So C is in parents, so we are not going to visit it. So let is see how the tree looks like at this point. So it looks like this. Is C a child of G? So I am wondering about this edge that we chose not to follow. We followed A to G so we know this is actually the edge. So from this edge, G to C, I am wondering what kind of edge it is. So C is not G is child, right? So another forward edge. Sorry. I got confused earlier because they look the same in a drawing. So it is not a forward edge, then it is a cross edge. There is one more edge that we have not talked about because it was too early in the search. And that edge is from C to A. So if you remember there, we were in DFS visit C. And the first thing we did was we looked at A, we said, hey it is already in parents, so we are not going to visit it. So DFS did not follow the edge C to A. That edge looks like this. What kind of edge is it? Back edge. Wait. So it has to be direct descendant in order to be a forward edge? Because they are related through A, right? C and G? So you have to look and which direction does it go? Does it go down the tree or up the tree? It is going down if you consider G to C. From G to C, so it is a cross edge. Yeah. But is C G is descendant? No. But they are related. They are related, but they are just related because they are in the tree. OK. So it is only directly descendants? Yep. So DFS puts together a tree. A forward edge is a shortcut in that tree. It lets you go forward in the VFS. A backward edge points to a parent in the tree, so it lets you go back in time. A cross edge takes you from one point to another point. And it is not a forward edge, not a backward edge. So it takes you in a whole different world. So C, A, G, has A, G is the sub tree, and then this guy is this other sub tree, and they are different little worlds. And this edge goes from one to the other. So the algorithm to decide what kind of an edge it is, let is put it together. Which edge do we look at, which type do we think about first? Tree edge. So DFS followed the edge. It is a tree edge. So we have tree edges. What do we do next? So say we have an edge from u to v. If DFS follows it, it is a tree edge. If not, then what question do I ask myself? It could be one of three edges then, back, forward, or cross. OK. So let is try to write a simple algorithm so that if I ask you this on a quiz, you can decide which is which. So I think that you look forward if u is the parent of v. OK. So if u is a parent of v well, let is say ascendant. It is not just the direct parent, but this is the right intuition. Then what kind of edge is it? Then it is the forward edge. So the edge is from u to v. If u is a parent of v, forward edge. Good. Otherwise? . OK. Then? Then backward edge. Else cross edge. Does this make sense? So these are the four types of edges. DFS takes the edge, it is a forward edge. If not, we draw the DFS tree. And we see does the edge go forward in the tree, forward edge. Does it go backward, backward edge. Does it grow between completely unrelated nodes, cross edge. OK. Now let me ask another question. Let is suppose we do this DFS thing again, but let is suppose we do it on an undirected graph. What types of edges do I have? Anyone remember off the top of their heads? Do not think so, right? So let is do it and find out. So let me see where do I get some room. Here. Let is write the tree that is we are going to go. So let is do a VFS of this quickly and write the tree. So we start at A, then what? Then? Then? D. E. And go back to D. It could go from C to A. OK. So we have C to A. What kind of edge is this? Backward edge. OK. So we still have tree edges for sure and backward edges. How do you get from C to A? This was supposed to happen way before. So we went A, B, C, and then when we were at C, oh. Sorry. My bad. So we went from A to B, B to C, and then A was the first thing in C is adjacency list. So we saw this back edge. So C to D, D to E, D to F. E to F? Or F to C? And then F to C. So what kind of edge is this? Backward. So none of these guys. And then we are all the way back at A, right? A to oh. Sorry. No we are not done. So C to D, D to E, D to F, then we are back at C. And C to G. There is supposed to be a line between C and F? Oh, yeah. Sorry. I guess I ca not copy. One, two, three, four, five, six, seven, eight, nine. One, two, three, four, five, six, seven, eight, nine. Now it is right. Thank you. OK. So what am I missing? Edge from C to G. What kind of edge? C and G? OK. So we have tree edges and we have backward edges. What do we not have? Forward edges and cross edges, right? You need one from A to G. A and G are related. What edge is this? Cool. Thanks. You never add those, though, right? You just see that A was in the parent is list, and be like, OK. Yeah. So for all the edges that are not tree edges, DFS does not actually follow them. We just care about them because other algorithms care about them. They let you compute fancy things on the graph. OK. So are we good with the types? So why ca not I have a forward edge? So there are two types of edges I ca not have, cross edges and forward edges. Why ca not I have a forward edge? On an undirected graph? So in order to have a forward edge, I would have to go C, D, F. And then not follow this edge. I mean not see this edge here. Right? If this edge would be undirected, I would say, hey, it goes from F to C. It is a background edge. So I would have seen this edge when I would have been in C. So I am comparing this tree with this tree, and trying to figure out why they are different. How does a forward edge look like? You have a node u, then you have some more tree stuff. And from here, you got to v. And then when you are at v, you did not see the edge. Right? Because if you would have seen it, it would have been a background edge. So you can only see the edge from u to v later on. So this is tree edges, a bunch of tree edges, and this is a forward edge. In an undirected graph, this never happens because when you are at v, you are going to see the edge. And you are going to mark it as a backward edge. So forward edges can ever happen. Yes? No? Is everyone happy? So cross edges. Why ca not they happen? A cross edge can never happen because in order for a cross edge to happen, I would have to go A, B, C, visit C is children, then go up and go somewhere else. And then see this edge. But, hey, when I was at C, why did not I see this edge? Why did I only see it later? If it is an undirected graph, I would see this edge here and it would be a forward edge. Sorry. A tree edge, because that would take it. Yes? So is it just when you are is it just because it is the way you traverse in DFS or would it apply generally to VFS as well? VFS does not have forward and backward. Yeah. VFS is completely different. So these are all DFS terms, purely DFS. OK. So no forward edges, no cross edges. And if you forget which ones you can and ca not have, now you know how to reason about it quickly and remember. Yes? OK. So this is DFS. Are we all happy with DFS? Let is talk about topological sorting then. Because it is really useful. It is one of the few algorithms that is really useful and that you might have to write yourself later. So suppose these are classes. So let is get back to this oriented thing and suppose these are classes. And the edges show prerequisites. So A is a prerequisite of B. Like say A is six hundred and one and B is six thousand and six point And you have to take six hundred and one before you take six thousand and six point Otherwise you will cry during programming assignments. So what we want to do is these are all the classes you need to graduate. We need to come up with an order in which you can take them so that when you take a class, you took all the prerequisites. So you do not cry while you are taking that class. How do we do that? And let is use this graph as an example. Use a directed graph that is acyclic? OK. Is this graph acyclic? No. OK. So what then? . So if the graph has a cycle, you ca not solve the problem. It has no solution. It is like those cardboard boxes that. It is really annoying. I do not know the cardboard box problem. Yeah. You know those cardboard boxes with the four flaps when you close them, and they close like Yeah. Those are so annoying. That is just what this reminds me of. That is all. Continue. There is a cycle there, so you ca not just put them in an order. Right? You have to violate the repeating variance somehow. And you do that by twisting the edges. So if we had classes A, B, C, you cannot take them in any order. Right? If you take A first, you would need C. If you take B first, you would need A. If you take C first, you would need B. So you ca not start with any of them. So if you have a cycle in a graph, it is not a dependency graph. You ca not compute dependencies. So topological sorts only works on cyclic graphs. So acyclic graph. And what else? So a dependency graph is a special kind of graph. And I am looking for three fancy words. You already have two. So we have acyclic and we have graph. Directed. So you have to have a directed, so that you know which class goes first. Needs to be acyclic, otherwise there is no solution. Needs to be a graph, because that is what we are talking about. So the shortening for this is a DAG. OK. How do you compute an order? So say we remove that edge. How do we compute an order? You run DFS and then print out the reverse. And then print out the reverse? Of your final output. Which is? Your final output? You want me to do it on a graph? You can tell me how to change the codes, too. So I am not sure what you said print the reverse of something, but what is that thing? So I go down a path, right, until you have hit all the nodes, then basically you start from the last node you visited and print out the reverse of that. Go back to the first node. OK. So you are saying I go A, B, C, D, E, and then I print E, D, C, B, A? No. Because that would not hit all the nodes. OK. He is on the right track, by the way, so that is why we are You go A, B, C, D, E, F, G, and you print G, F, E, D, C, B, A. OK so we print them in the reverse. So you are printing them in the order in which you are done with them after DFS? No. You are printing them in the reverse order of the order which you visited them? So you visited A, B, C, D, E, F, G, so you are saying print G, F, E, D, C, B, A. Yeah. Because in lecture was not it flipped, so if an arrow points from A to B then A depends on B. And we are looking at the other way around. In lecture, based on the graph you gave, if the arrow goes from A to B, then A depends on B. If the arrow goes from A to B, then what? If you are saying A is a prerequisite for B and G, then we just sweep from left to right and say, I have to do this. And then those two. No. They have to It is the order that because when you are doing DFS, you recurse. It is the order that they finished the recurse. Yeah. You have the right answer. I am just trying to build out the annotation for it. I am pretty sure this is the right way. I can look at this, but I ca not promise you that this is the right way because I coded it and it works. So no. This is the right way. Yes. This is the right way to represent them. So forward edge means B depends on A. OK. So let is figure out how we do this. Let is do this in pseudo code and then build the intuition for it. So you said reverse of the finishing times. So let is build a list that has all the nodes in the order of their finishing times. So let is build a list finished that is empty at first. Then I am going to add all the nodes in the list as I am done with them. And then I will reverse the list. Where do I add nodes to the list? In the check. Line 2. 75. Not quite. So line four point So I am adding them in the order in which I am done with them. So when I am about to leave a node completely, I will add it to that list. Which node? What is the name? V. OK. And then where can I reverse the list? Line four of the first OK. How would I do this? r dot finished dot reverse. Like this? I think that is OK in Python. I think so, too. So this will give me a topological sort. Let is figure out why this works intuitively. Yes? So while we are building the topological sort, while we are building the inverse of the final list. So the first thing that we put in the list is the last class we are going to take. So as I go forward in this graph, my VFS is going to go A, B, C, D, E. There is nothing after E. And it is done with E. So this means there is no class that depends on E. Otherwise, DFS would keep recursing. So E is the last class I take. If I take this last, there is definitely no dependencies that I am violating. All right? So it is safe to start with E. Now I am out of E, I am back to D. I go from D to F, I print that. Let is not worry about this for a little bit. And let is go back to D. When DFS comes back, it is going to print D. So I know that by the time DFS is out, I printed all the classes that depend on D. Right? So when I am at D, whenever I have forward edges that I have not visited yet, I will call DFS visit on them. DFS visit returns before I can get out of D. So all the edges that depend on D have been printed. Sorry. All the nodes that depend on D have been printed. So when I get out of D, I know that all the nodes that depend on D have been printed, so it is safe to print D. This is the intuition behind topological sort. So you can build sort of an induction proof based on this. So whenever I am here, I assume that all the nodes that I have forward edges to are somewhere in my results. So I can include my nodes. So this means that whenever you put a node here, all the nodes that have forward edges to this node have already been output. So this means that no dependency relationships are going to be violated. OK. Let is keep building this and see the result. So D, E, F, we get out of B. We get out of C. What do we do here? Print C, right? What classes depend on C? D, E, and F. I had a tree edge to D. I had DFS visit here, so I know that all the classes that depend on C because they depend on D have been output. And then I have a forward edge on F. So I did not recurse from C to F, but I know that has been covered somewhere. Right? Forward edge means that I have already seen it in DFS, and that I have already returned from it. So it has already been printed. So I am going to write this. Now I get out of C. I get out of B. I go into G. I get out of B, and I go into A. And I go out of A, and I print it. OK. So I have tree edges that I can handle. So these are all tree edges. And the reason that topological sorting works on tree edges is that I call DFS visit on the tree edge, and I know it returns by the time I return. So I know that whatever is underneath that tree has already been printed. I have forward edges that will just take me forward in the DFS. So I know that by the time I return from a node, I have already returned from all the nodes that I have forward edges to because they are lower in the tree. Right? Forward edges work like this. So by the time I am out of C, I have definitely printed F. Now I have this cross edge from G to C. A cross edge means that there is no direct relationship here, but I have already visited C. If there is no direct relationship, it means that for sure I am done visiting C and I have returned so that I can get to G. So there is some common parent between C and G. I am already done with C, and I have returned to that parent. And then I went to G. So all the nodes that are pointed to my cross edges have also been printed in topological sort. OK. Now what about back edges? What if I had a back edge? What if I had this back edge between C and A? What happens then? If I had a back edge, then that would break topological sort. Right? Because this is saying that hey, you should print A before you print C. But I know that I am going to come out of C way before I have a chance to come out of A. So if I have a back edge, topological sort does not work. When do I have a back edge? When I have a cycle. So this is why I do not care about back edges. Back edges cycles. So back edge means I have a path forward. And I have a path backward. That does a cycle. OK. There is an awful lot of silence here. Does everything makes sense or? OK. Any questions? Nope? Everyone is happy? So you do not need to reason about this formally. Just remember the intuition that the reason we are printing them in this order is the first thing you print is the last class you are going to take. Because for sure there are no dependencies left on it, otherwise DFS would keep recursing. And then there is that recursive structure that makes this work. OK. Cool. 
</body>
</html>