<html>
<body>
VICTOR COSTAN Hi, everyone. I am Victor. My full name is Victor Costan. I am a third year Ph. D. student. I am in CSAIL, and I work in systems. I do mostly security and distributed systems. And I will be your algorithm TA for this term. Yay. How many people went to lecture yesterday? All right. Are there any parts of the lecture that were particularly unclear that you guys want to go over? So that I schedule what I talk about in such a way that I will cover that more than the parts that are boring and obvious. Can you explain complexity in equations, because I took forty two like three years ago. VICTOR COSTAN OK. What else? Thank you. Maybe some basic outlines for, like, writing proofs relevant to like the. VICTOR COSTAN All right. Sort of methodology or something. VICTOR COSTAN OK. Anything else? OK. We are going to get started then. So the hardest, and I think most important of the whole course, is learning how to deal with asymptotic complexity. So asymptotic complexity is this very nice tool where you have a function that looks like this plus what will I have here? ten plus sin x. So you have this guy, which is quite long and horrible and would make your life miserable if you had have to reason about it. And you can say that this is theta of n squared. x, sorry. So everything that is here goes away. And this constant factor here goes away, and it is nice and small function. Why is that the case, first of all? If I plot this function and since I do not have my projector you will have to take my word for it I will get something that looks like this. If I plug this function, I will get something that looks like this. This is a scale from zero to two hundred point However, if I make my scale zero to 20,000 Let is say 200,000 to make sure that is going to be correct. x squared looks like this. And this function looks like this. And as you make the scale bigger and bigger, you ca not even see this noise anymore. The reason is that all the noise is in this term. In the x to the power of one fifth term. And as n pretend this is n, x, n same thing so as the input to the function gets bigger and bigger, this grows at a much faster rate than this. So if I do not care about this, how the function grows, I can ignore anything aside from the dominant term. Do people remember this from lecture? Does this make sense? OK. If it does not, that is great. It means that I am not wasting time covering it. So we learned about three symbols, or we will learn about three symbols, when talking about asymptotic complexity. The three symbols are theta, O, and omega. Let is say this complicated function is g. And this nice simple function is f. If I say that g of x is theta of f of x, that means two things. It means I have a lower bound, like I showed here, and the lower bound looks something like x squared. And it means that I also have a higher an upper bound for it that also looks like x squared. So the upper bound would be something like this. And if I say this, then I am making a promise that the function stays between the lower bound and the upper bound, and the bounds look sort of the same. I ca not really have x squared here, and x squared here. Right? That would be impossible. So that is why I said they look the same. They are not the same. And they are not the same, because they are allowed to differ by a constant factor. So if this is f, and say this is f prime, f of x might be x squared. And we know for sure that this is going to be lower than this. And f prime of x might be one point two times x squared. And because I have a one point one here and I know that these get smaller and smaller in relation to this as the function as the inputs to the function get bigger I know that this is going to be the dominating factor. And because this is bigger than this, this function is going to eventually be larger than this function. So I have a bound from above, and I have a bound from below. And the bounds look almost the same. They are only different by a constant factor. This is theta. To make things spicier by the way, theta is really hard to pronounce as opposed to O, so we usually say and write O instead of theta. We will talk about what O really means in a bit. But if you see O in a lot of places, including our notes, know that most of the time we actually mean theta. And sorry for that. When do we you actually mean O? VICTOR COSTAN You can ask us, and we will tell you.  Fortunately, it does not a matter too much. So we are trying to get an idea of how the functions look like in the bigger picture. So most of the time it does not matter. I will give you an example though of where it matters, and how it could matter. So suppose I have another function that looks like this. So this is kind of ugly, too. This function is g of x, say x times one plus sin of x. So I ca not say anything about the lower bound of this. This is going to hit zero at an infinite number of values. Right? So I ca not say that I ca not have a nice lower bound for it. The lower bound for it is zero point But I am pretty sure that it is never going to be bigger than 2x. Right? And that is still worth something. So there is this other function here that is supposed to be a line. Pretend it is a line. f of x equals 2x. And I know for sure that this is never going to exceed these, this. And in that case, where I only have one upper bound, and I do not have a good lower bound, I say that g of x is order of f of x. And this is where This is what O really means. It means that I only have an upper bound and not a lower bound. In most of the cases when you are coding something, you do not really care how well your program can run if you are really lucky. What you really care about is how does it run in the worst case? Or how does it run most of the time? So suppose you are Google, and you are writing your search engine, and you have to return the result to the user in two hundred milliseconds. Because they did a study that shows that if you return the result in four hundred milliseconds, they lose some number of users, which means they lose some number of billions a year. So to them a guarantee that their algorithms complete in two hundred milliseconds is pretty important, because it means a ton of money. So if you have a running time that looks like this, that is OK, as long as this is two hundred milliseconds for the number of pages that Google indexes. Does that make sense? OK. No answer means yes. So if it does not make sense, please say something. OK, I will draw another function. Again Victor? VICTOR COSTAN wavy. Yes? It says x times one plus something. So what? VICTOR COSTAN So it is Oh it is sin. VICTOR COSTAN one plus sin of x. It It looks like. VICTOR COSTAN Yeah. Sorry, my handwriting is not very good. It is OK. Mine is not either. VICTOR COSTAN And it does not really matter what it is, it just needs to be sin so that it looks wavy like this. OK. VICTOR COSTAN So that I can make something that looks complicated. OK. Got it. I have a question, too. In the first example, is it one point two times x squared? VICTOR COSTAN Yes. I wanted something that is higher than 1. 1. It is like. VICTOR COSTAN Yes. OK. Now that I got a break, does anyone else want to ask questions? OK. So I am going to draw another function. This one looks like this. And this is f of x equals one plus sin of x. I have to use these signs to make them look like that. Times x to the power of What do I have there? one five plus x to the power of one fourth. So for this function I know for sure that it is greater than x to the power of one fourth. Right? So if this is I know for sure that it is greater than that. Also if I look at this, and I know that sin is never bigger than 1, I know this whole thing is going to be, at most, two point So if I have another function that says f prime of x equals, say, three times x to the power of 1. 5, I know that it is going to bound it from above. So I have two bounds. So it sort of looks like this case. Except when I use theta, I have to make sure that the bounds are very similar. They can only differ by a constant factor. In this case my bounds differ by the exponent here, which is more than a constant factor, so they are not the same. So if I take my function which by the way is g if I want to say that g to the x is theta of something, I ca not. Because no matter what I put in here, it is not going to be correct. The lower bound is this, the upper bound is this. But what I can do is I can say that I know for sure that it is theta of x to the power one fourth. And by the way I can also say that it is order of x to the power of one fifth. So if you have weird running times that looks like this, then you can only use O and omega. And with that being said, we will use O for pretty much the rest of this course. And for most of the cases we will use it to mean theta. Oh, by the way, these formulas look ugly and complicated, because I wanted the graphs to look complicated to illustrate the idea that asymptotic notation makes things look simpler. In this course the running times that you will be dealing with are all look like this. They will either be order 1, order log n, order n, order n log n, n ordered n squared. You might have one or two cases where you get something else, but most of the time if you have something else coming out of your occurrence, it means you are doing it wrong. So nice tip to have. And you can see that I already started doing it. I am already using O instead of theta. So I guess I am getting into the habit. So why did you leave the theta one blank for g of x? VICTOR COSTAN Because whatever I put here is going to be wrong. If I put x to the power of one fifth, this is wrong, because I can have an upper bound that has x to the power of one fifth in it. But I ca not have a lower bound like that, because this function hits x to the power of one fourth in infinitely many points. If I try to do x to the power of one fourth, same deal. Lower bound yes, upper bound no. So whatever I put in here is going to be wrong. Thank you. Good question. Yes? Is that one point four or one fourth? VICTOR COSTAN 1. 4. They are one point four and one point five OK. Because I thought you were saying 14 and I was VICTOR COSTAN Oh, sorry. one 4, 1. 4. 1. 4, 1. 5. OK. Are we good so far? OK. Let is go through a couple of exercises. So I will give you a few functions Yes? Do you make omega Is that It is a lower bound already without multiplying by any constant, or something? Is that what it is? VICTOR COSTAN So for all of these, what you put here is the simple, is the simple form. So you are lower bound can be this function multiplied by any constant factor. That So omega means lower bound? VICTOR COSTAN Omega means lower bound, O means upper bound, theta means both. OK. Any other things to clear up before I ask questions? So it is your turn before it is my turn. All right. I am going to go over a few functions, and I want you guys to tell me what to help me write them in asymptotic notation. So I will have f of n. And I want to know it is theta of what? So let is start with f of n equals ten to the eighty point Does anyone know why ten to the 80? Yes. That had be O of one point VICTOR COSTAN OK. That is the correct answer. You are going ahead though. I was wondering if I was wondering if you know why? Why did I choose this? Does anyone know why I chose this? Yes? Is that? VICTOR COSTAN I think that is one hundred point Oh, OK. VICTOR COSTAN You are getting close though. It is something. It is a really big number. VICTOR COSTAN It is a really big number. All right. So it is a really big number. That is the estimated number of atoms in the universe. So realistically any quantity that you deal with that will represent the real world, is not going to be bigger than this. So if you want to get all philosophical, you can say that for any algorithm that you write in any realistic input the running time will be theta of one point But if you do this, we are not going to be happy with you on exams.  So let is choose another one. twenty n to the power of seven point What is this an asymptotic notation? And why? Yes? Order O of n to the seventh. VICTOR COSTAN OK. Of that same thing, n to the seventh. Thank you. Why is that? Because if you distribute the exponent 7, twenty to the seventh is a constant. VICTOR COSTAN Excellent. twenty to the seven time n to the 7, this is a constant so it goes away. OK. And before I do another one, I want to give you guys some help and remind you about logs. How many people remember the laws of working with logs from algebra or some math class? All right. You guys will be helping me write them for everyone else. So if I have log of n to the 100, and I want to get to the theta notation for it, what is it and why? Log n. VICTOR COSTAN OK. Excellent. Why is that the case? It is one hundred log n. VICTOR COSTAN OK. So when I have an exponent here, I can pull it out in front of the log as a constant factor. So this is the same thing as one hundred log n. OK. Now if I have the logarithm to the base using base five of n How about this? multiply. That is just log n? VICTOR COSTAN OK. So this is can you say that again? Log n. VICTOR COSTAN OK. So this is theta of log n because it is Log n over log five point VICTOR COSTAN So that is log n over log five point So exponents inside the logs turn into constant factors, bases turn into constant factors. So if you have an ugly expression inside a logarithm, you can, most of the time, simplify it to something really nice. And this contributes to the fact that these are the only functions that you will see when the answer is cleaned up in asymptotic notation. OK. Yes? So when you are writing log, are you assuming the second base then? VICTOR COSTAN Yes, there is a certain base for logs. We are all computer scientists. Right? So what is the natural base for our logarithms? two point 2D. VICTOR COSTAN OK. Sweet. Math major? No, you know I always heard natural base VICTOR COSTAN OK. Yeah, it is a math joke. So for everyone else a natural logarithm is in base E. For us CS people, a natural base is 2, because that is how many values you have for a bit. So log means log n is to log base two of n. The good news is that most of the time we are working with asymptotic notation, so it does not really matter. We can communicate with our math friends, and we do not have to talk about this. OK. I need to get another complicated example. And my memory fails me. OK. So log See, I am using Ln to mean the math natural logarithm. So we still have that somewhere in here. Of log n to the base one hundred point They made me add all these parentheses in the last section to be clear, so I am adding them now from the start. Who wants to help me clean this up? Yes? Log, log n. VICTOR COSTAN All right. Wow, one step. Log, log n OK. Can you tell me why, very quickly? So we can simplify out the base and the exponent in there. VICTOR COSTAN OK. Then VICTOR COSTAN Base goes out. Exponent goes out. Log, log of something is another. It is not exactly up there. But can you VICTOR COSTAN Yep. occassionally. VICTOR COSTAN Yep. What does a theory student say when they are drowning? Log, log, log, log. Some of you are laughing already, because know this. OK. What if I want to make this a little bit harder? And I say log five of log n to the one hundred point You have to do a bit more work now, you ca not just use the tricks on the right. Anyone else? Yes? It is still log, log n. VICTOR COSTAN OK. It is still log, log n. But for a different reason. Right? . VICTOR COSTAN Almost. OK. Maybe not. So the base still goes out just like before. But this guy now goes out here. So I will have this be, sort of like Notice that I am not saying equal, I am saying like because I got rid of the base. So it is like one hundred times log n, which is log one hundred plus log, log n. And this is a constant factor, this grows as n grows. So this is going to become incredibly small as n becomes larger and larger, so I can get rid of it. OK? OK. One more, and this one is going to be less boring. out into a separate term the log of 100? Going from it in the last step, how are you able to cross that out? VICTOR COSTAN If my memory If my memory works, I think, log of a b is log a plus log b. Gotcha. VICTOR COSTAN Am I right guys? Sweet. Good question. I was not sure, but now that you asked, everyone else helped me make sure it is right. OK. I am erasing so much, because we are going to need more room for this. So I have a log again, but this time what I have inside the log is n choose n over two point Does any brave soul want to come up here and solve this for me? No? You guys are going to make me write for the entire hour?  VICTOR COSTAN I will offer help. It is n VICTOR COSTAN So this is Is that n factorial over VICTOR COSTAN Yep. n divided by two factorial? VICTOR COSTAN n factorial over n divided by two factorial, times n divided by two factorial. Close. And I will give up another hint, which is that n factorial can be approximated as square root of 2pi n multiplied by n over E divided by n to the power of n. But I think this will make you guys not want to come up and solve this. Yes? OK.. VICTOR COSTAN I was Is that it? Is that not it? Did I get it wrong? OK. minus n. VICTOR COSTAN I think that is an asymptotic. That is what we will I think we will get to that. But factorials grow exponentially. So it should be something like this. OK. So we have that nice approximation. Does anyone want to work it out, or will I have to do it? I will keep that in mind when I am grading your homework.  VICTOR COSTAN OK. So it is log of square root two pi n multiplied by n over two to the power of n. I am going to put these two together. So two pi n over There is an n over two there, right? So it is n over 2E times n over two to the power of two point OK, I can get rid of this guy, because it is a constant. I can get No, I ca not get rid of this guy yet. In the denominator should not it be 2pi n over two under the radical? VICTOR COSTAN Yep. 2pi n over 2, so this simplifies. OK. Thank you. Square at the bottom term, you can get rid of the square root on the end VICTOR COSTAN Yep. and then cancel the some of the exponents. VICTOR COSTAN OK. Do you want to come help me? Sure. VICTOR COSTAN Thanks so much. STUDENT OK. So we can distribute this exponent here to cancel this. And then we get square root of pi n times n over two point And it had be n sorry about my handwriting. VICTOR COSTAN I think it is better than mine by quite a bit. STUDENT Square root of pi n. And this is square root squared, so that cancels. Times n over E to the n. Do you need parenthesis around n over 2E? STUDENT Yeah. That is probably good. So, since this is n over E to the n, and n over 2E n. Well since they are to the n, both the n we can give them a single exponent and cancel stuff. So we just get square root of pi n to the times two the n, over pi n. Can do some more cancelling and just get two the n over Going to simplify this to the n over the square root of n. We can take out the pi, because it is in our natural logarithm. It is a constant factor. And this is log of and then Since it is a log of, it is just log of two to the n. So it is say since it is log you can turn it into log of two to the n minus log of square root of n. Log of two to the n is a much greater complexity than square root of n, so we can VICTOR COSTAN Sweet. Thank you. So see? Complicated formula Even more complicated formula came out to be one of the numbers that I promised it would come out to. Thanks for the help. So you can get rid of the pi as soon as you want to. And this is the last step. I just want to say it again, just make sure everyone heard it. So once you get here, you get this, order n minus log of square root of n, which is This is This is order n minus one half log n. And the log n is much smaller than n, so this goes away completely. And you get this as your final answer. OK. Does this make sense? Any questions? Anyone? How many people are still paying attention honestly? Wow. Nice. You should come to all my sections. OK. Let is talk about something we covered in class. Let is talk about peak finding. And we will start with 1D peak finding, and then we will go to 2D peak finding. So does anyone remember the pseudocode for the faster 1D peak finding by any chance? ID peak finding. I think everyone said they went to lecture, so I do not have to explain what peak finding is, right? OK. So that is go for it. So suppose I have a few numbers 3 let me write this one 3, 4, 5, 6, 7, 6, 5, four point So the peak finding problem says there is an array of numbers, and I want to find the local peak. And the local peak is a number that is surrounded by numbers that are smaller or equal to it. So there should not be any larger numbers than it. And I want to find a peak as quickly as I can. So what is the faster algorithm that we talked about in lecture? Yes? OK. You did not answer, right, as much, at least so. Binary search? VICTOR COSTAN OK. It is exactly like binary search. Yep. Do you wanna help me write the pseudocode? You can tell me what it is. Sure. So, I guess well start in the middle. VICTOR COSTAN OK. Start in the middle. If you If you write this on your Pset you might want to be a little bit more formal. Someone asked about proofs. I would say something like, start by looking at the middle element of the array. Same thing though. OK. So let is pretend this is the middle. Now it is. What do I do? Then you can check one side in the middle. So it is the right side. VICTOR COSTAN OK. I am looking at the right side. I see a seven there, so I know for sure that this is not a local peak. Right? What do I do now? So now you can start over, and using seven point VICTOR COSTAN OK. What if This would be small. What if I would look at five first? Or you should I look at the other side too? Well you do not have to in this case, but if you But if seven were smaller then you would go and look at the other side, and check to see if five is also smaller. In that case you have already found the peak. VICTOR COSTAN OK. So I have to look at both sides and make sure if none of them is smaller, than I I am sorry. If none of them is bigger, I found the peak. If any of them is bigger then I can go whichever way I want. So I saw my 7, I am going to cut this in half. And now I look at this. You were saying, right? So look at the neighbors By the way, can anyone understand my handwriting? Is it even worth bothering to write? It is pretty good. VICTOR COSTAN OK. I see three nods. I am going to write for those three people. It is just we have not taken any cursive in about twelve years. So VICTOR COSTAN OK. Thanks. Not feeling well at all. OK look at neighbors, figure out if you are a peak. You are one of the people that said you can read it, so now there is only two people that can read my handwriting and that I like.  VICTOR COSTAN Look at the neighbors. See if local peak. And if not, figure out which way to go in. And I will say if not recurse. So what is the running time for this? Suppose I have n elements to start with, that is my array size. I will use t of n as my running time. So to figure out the running time for the whole algorithm, I have to look at the running time for each step and add them up. Right? What is the running time for the first step? Looking in the middle. the middle elements. VICTOR COSTAN one point one point I would not say zero point I still have to look at it. Or to be on the safe side you say 1, theta of one point It is a constant. OK. Now I have to look at the neighbors, and I have to see if one of them is bigger or not. How about that? How much time is left? I heard the constant. OK. Very soft voice, but I heard a constant there, so I am going to take it. So this guy is a constant. If it is a local, if you come down. If it is not a local peak, what is the running time for this? n over 2, since If you FOIL that you divide by, right? VICTOR COSTAN Yep. So I am looking at this guy. It is clearly not a peak. So I am going to look on the right side, because I see a seven here that is bigger than a six point So now I have the same problem, except my array size just dropped to half. So same problem, because I already have a name for it, except the input size is different. So the running time for this entire step is theta of one plus T of n over two point So the running time for the whole thing is I should have said theta of one here, sorry. So theta of one plus theta of one plus T of n over two point So this is theta one plus T of n over two point So I wrote out my pseudocode, looked at the running time for each step, added them up. Now I have a recurrence, and I have to solve it. Let is solve it. We sort of glossed over that in lectures, so we are going to do it now. So T of n equals theta of one plus T of n over two point I am going to expand this using the definition. And theta of one is long, so I am going to call this c instead. It is a constant, right? So c plus expanding this c plus T of n over four point I am going to expand it again. And again Anyone getting bored of this? So if I expand it a lot of times, I am going to get i times c, plus T of n divided by two to the n. And you can expand it as many times as you want until we see the pattern, but this is the pattern. So I have a recurrence. What else do I need in order to get a function? I need a base case. So the problem size gets smaller and smaller and smaller, but at some point it becomes so small that I can solve it just by looking at it. What is that case?  VICTOR COSTAN OK. So if I have an array of one element, it is a peak. Right? Job done. So T of one is a constant. So I want to write this in such a way that this becomes this. So I want to figure out an i such that Yeah. T of n divided by two to the i equals T of one point And the easiest way of doing that is to say that n divided by two to the i is one point So i is the inverse of an exponential Anyone? . VICTOR COSTAN Logarithm, thank you. Log n. So I have i, and I am going to plug it back in here. And I get constant times log n, plus T of 1, which I know is theta of one point I am going to make this theta of one again. So theta of one times log n, plus theta of one point And I know that log n dominates a constant, so this is going to be theta of log n. Solved. OK. How are we doing? Yes? In the second to last from the bottom, I do not understand of c times log n replace i by log n. In the second part of the equation, how did you VICTOR COSTAN OK. So in the jump from here to here, where I said i equals log n Right? Yep. VICTOR COSTAN OK. So i becomes log n, c stays c. You are wondering about this part, right? So if i is log n, then two to the i is n. So I have T of 1, which I have here. So I want this to have this happen. When I am solving for i here, I set this guy to my base case, so that I can get this to happen. The idea here is that you are expanding the recursion forever, and you know that at some point you are going to have to stop. When do you stop? You stop at the base case. So you force this to become the base case. OK? OK. Let is do 2D peak finding. Let is talk about it a little bit. So 2D peak finding is exactly like 1D peak finding, except you have a 2D matrix instead of a 1D array. Let is see if I can do this right. So suppose this is our matrix. And suppose these are the rows. Suppose we have m rows and n columns. Can anyone remind me what the psuedocode for 2D peak finding that we talked about in lecture? So we had two attempts. The first one was a clear failure. It did not work. The second one worked. And we talked about its running time a little bit. And then asked you to think of a variation to the second one. So let is do those straight up second version of the pseudocode without the variation. So 2D peak finding. What is the algorithm? All right. One person was not asleep in my section at the end of lecture. I am proud. OK. Well, Which one of us? We both spoke at the same time. VICTOR COSTAN You had your hand up first though. So you just pick a middle of the column. VICTOR COSTAN OK. And then you find the peak there. And then you shift the neighbors, I think. VICTOR COSTAN Find peak neighbors. Neighbors in the same room? Yeah, yeah. VICTOR COSTAN That is the horizontal line, right? OK. So what do you mean by find the peak here? Like within the column? VICTOR COSTAN Yes. So find the peak using what we talked about before? Yeah. VICTOR COSTAN OK. Find 1D peak. So you are thinking ahead. You are thinking of the variation that asked you guys to think about at home. I am glad you thought about it. That is good. But what is the one that we had in lecture? I do not want to think about I do not want to give you guys the answer yet. So what did we say we were going to do in lecture? Yes? I think we just picked a spot, checked the neighbors and kept walking uphill. That makes sense. Every time we found a neighbor that was bigger, we moved to that spot. Checked its neighbors. VICTOR COSTAN So this is the This is the first algorithm that is slow. It works. You are going to get the correct answer. But it is slow because if you have some handily crafted matrix you can go like this, and you are basically going through the whole matrix. Yes? I think there is like an algorithm that is find a look through the column for its maximum, and then look to either side. VICTOR COSTAN OK. So instead of finding a 1D peak, we are going to find the maximum value. OK. And this is correct, and let is look at its running time. Does anyone want to help me? So this is T of n m. Right? Then rows, then columns. So what is the running time for the first step? Come on. This is the easy one. Yes? The constant. Perfect. OK. What is the running time for finding a maximum amount of n numbers? n. VICTOR COSTAN OK. Perfect. And suppose we do that here? Suppose these rows do not exist. Suppose this is my entire matrix. And I am here, and I found the maximum. What do I do? I look left, I look right. If both of them are smaller, then it means I found my peak, because I know that number was a maximum in my column. Now if that is not the case, if I find a number that is bigger, I will go in that direction. Does that sound reasonable? OK. So maximum for my column, and I am going to go right. So check neighbors, and I have the same two conditions there. If it is a peak, then I am happy. Otherwise recurse. So what is the running time if I have to recurse? How does the new problem look like? It is an identical problem. I still have a matrix, except What changed? So suppose I got here and this is the middle of my matrix and I see that this guy is bigger, so I am going to recurse to the right side. What happened to my problem size? OK? Sorry I am not answering your question, but should not find x be theta of m, not n? Is that? VICTOR COSTAN Let me see. I ca not tell VICTOR COSTAN You are right. Thank you for paying attention. Theta m. Sweet. That would have tripped me up later. Thanks for saving me. OK. So what was your question? Sorry. VICTOR COSTAN So the question is, if I have to recurse Uh huh. VICTOR COSTAN what is the running time? So I am If I have to recurse, I am in this array that was originally n by m, and I am only going to look at the right side. How many these how many rows do I have in the? Start to the easy one. m. VICTOR COSTAN All right. Same as before. How many columns? n over two point VICTOR COSTAN n over two point Sweet. So there recursion for this is theta of one plus theta of m plus T of n over two and m. I know that a constant can be absorbed by this other guy, so it is theta of m plus T of n over two m. How would I solve this? What is the first thing that we need? Yes? Need to figure out the base case. VICTOR COSTAN All right. Excellent. Base case. What is the best What was the base case? T of one comma T of n m. Sorry. VICTOR COSTAN Nice. Equal to O of m. VICTOR COSTAN OK. Sweet. So if I only have one column, then I can do I can find the maximum and I know for sure that is going to be a peak. Job done. That is my base case. So I am going to reduce the problem size in half, until I get to a single column. Then I find the peak there, and I am happy. How would I solve this recurrence? It is a one minute answer, because I think that is exactly how much time we have, as a hint. Come on guys, this looks familiar. Yes? Going to be something like the recurrence over there VICTOR COSTAN Exactly. of just n. VICTOR COSTAN Exactly. m never changes, right? So this is basically a function of n. So if m never changes, and I pretend that it is a constant, this looks exactly like the recursion the recurrence that we solve before. T of n is a constant, plus T of n over two point So I am going to get that constant, multiply it by log n, which is the solution that I had before. So the running time is theta of m log n. All right. I think I have thirty seconds, so what if I would choose What if I would try to do this algorithm instead? It is another one minute question. So I guess I am cheating. I am taking time away. Sorry. So what if I would be finding a 1D peak instead of finding a maximum? I am looking at the running time, because if the running time is going to be the same, it is not even worth thinking if it is correct or not. If it is a more complicated algorithm with the same running time, why care about it? So is the running time going to be better? OK. I heard a nod. Why? Wo not it be log m times log n? VICTOR COSTAN All right. So 1D peak is exactly what we have there. Thank you. 1D peak is exactly like you said, log m. So this constant here becomes this constant here, so the algorithm would be a lot faster. As an order of magnitude idea, if your m and n are one million each, then log n is twenty point So that is a fifty time max improvement. And these are real input sizes you might get. And that is it. Thank you guys. 
</body>
</html>