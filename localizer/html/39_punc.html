<html>
<body>
Ok then, let is start with problems. And as we find concept issues, we will get to concept issues. So, we talked about shortest path, but we talked about shortest path in a very odd way, right? I am a coder. So for me I am used to, all right I go to one of these lectures, I hear a problem, then I get out of the lecture with an algorithm and the running time, right? This time we got out of the lecture with no algorithm and no running time. So, what is the point? The point is that we learned some analysis tricks that we can use for any shortest path algorithm. And the advantage of knowing that by the way too easy to forget, at least until you see the first real algorithms if you know that, if you have to modify an algorithm, you can still use the same analysis to prove that your new algorithm is going to be correct and that it is going to be fast. They are really nice tools to have, especially if you have to do that on a problem set or on an interview, or who knows, maybe even on a quiz. We will see if that happens or not. We did not talk about any shortest path algorithms. So, we are not going to assume shortest path algorithms. Instead we are going to use them as if we had them. No, wait. I do not like that. That is kind of annoying. Let is not do that. Let is do something else. We did not talk about the shortest path algorithm in lecture. Let is build one right now, how about that? Let is turn to the graph. Vertices and edges, right? Let is see if I can make this work. Suppose we have a graph. We have V vertices, E edges and all the edges have a weight that is non negative. Sorry, let is make it positive just to make things easy. It is smaller than W, so it is not too big. And they are all integers. Go. There is brute force, OK. So, brute force would mean what? Enumerate all the paths? OK. Let is go over something a little bit better. Does anyone remember the algorithm that was taught in class? The structure? No. Klaus mentioned Dijkstra and mentioned Bellman Ford. Let is write them up here. And they gave us the running times, which we will try to remember in a bit. But, we do not know algorithms, so no Dijkstra, no Bellman Ford for us. What do we know? Let is start with a simpler case. What if there are no weights here. What if the graph looked like this. You are making my life hard. Like this. No costs. All the edges have the same costs. What would we do to solve the problem? Say we want the shortest path from A to E. BFS. BFS. How is everyone feeling about BFS? What does BFS do, really quickly? How do you run BFS? Take a starting node and then you can search all it is neighbors. OK. Pick a starting node. Then, look at its neighbors? And then you enter it through each of its neighbors to find its neighbors and so forth. Sounds an awful lot like BFS. What is the difference between them? Well, you go through all of these neighbors before you start going through any of it. I mean, you go through all As neighbors before you take a neighbor and go through all of its neighbors. Ok, that is the difference. And it makes a huge difference as we have seen in topological sorting last time. So we have a list and we are going to use it to keep track of the nodes that we need to visit. We start with A. We numerate all of As neighbors. And the ones that have not been seen get stuck at the end of the list. A, B, C. A is out of the list. Then we take out the first node from the list, B in this case. We numerate all its neighbors, A, C, D, E. Out of all these, we take the neighbors that we have not seen and we put them at the end of the list. take out C, we look at its neighbors. We have seen them. We take out D, we look at his neighbors. We have seen them. We take out E, we look at all its neighbors. We have seen them. So this is BFS. BFS has this concept of levels. And another way to look at levels is, if you start at A, and you draw a circus of radius one, it is going to have all the nodes that are distance one from eight point Right? Exactly one edge. Then you draw a circus of radius two and you get all the nodes that you can reach in two edges. And BFS calls these circles levels. A is at level zero point This is level one point This is level two point If you look at this list and you write down the levels, you have 0, 1, 1, 2, two point If you had another node out here, say F, this would be discovered when we get to D. It would go all the way here at the end, and this is level three point In BFS the levels are always increasing. If you keep track of parent pointers, the parent pointer of a node, at some level, will always point to a node at the previous level. So, in BFS we get the shortest paths in terms of edge count. Make sense? This is a recall, right? It is not new stuff. Everyone happy with it? If it would not have costs, we could use BFS to compute shortest paths. But, we have costs. How do we deal with that? Intuitively, I had like to make BFS go across this edge faster than it would go across the edge. If I could do that, if this guy could get stuck in the queue before this guy, I would be happy. Intuitively, that is what I had like to do. How do we do that? Sort before adding? Sort Sort your neighbors sorts. Sort? OK. What if you kept track of it in a menu? Kept track of your queue as a priority queue. Congratulations. You deserve a Turing Award. You have discovered Dijkstra. OK, let is go for something simpler. I just say this is Dijkstra. We will talk about it in lecture on Tuesday. Very good. Like, have an adjacency list and, I think using what he said. Just sort it by cost OK, let is see how this would work. We have A, and we are pulling A out of the list. And we see its neighbors are C and B. Right? The distance to C is two point The distance to B is four point So we start with A. Does this mean that I am going to put in B before C? I am going to put in C and then B? No, it does not really matter because at the end you just sort the part. I guess you could add in the costs. Like associate the costs of B with four and C with two within your adjacency list? So, that is how we would keep track of costs, right? One way. for the queue would be A and then the value would be like a B and its cost, and the C and its cost. So you are saying that what I would have in this list is B with a cost of 4? And C with a cost of 2? Presumably, the other way around, right? C goes first? Like This? And then I take out C, I explore the neighbors so and so forth? The moment I did this I already lost the battle. Because, see this path A, C, B, length 3? If I put both of them in the queue, then the parent pointers are going to look like this. So, I already have a bad path from B to A. OK, well do not add that node then. OK, then how do we do it? I guess you can talk to each of them and see which one is lower and then, only add that one if it is the lowest. So it is more like depth search then Well, you two need to talk together because you are getting to Dijkstra, too. You are both going to rediscover Dijkstra. So that is great, but I am looking for something simple. This is too complicated. If you are going to do Dijkstra now, then what are going to do on lecture on Tuesday? More Dijkstra problems? Well, I think Shreeny wants to talk about Dijkstra, so let is not get there. How do you do this without doing Dijkstra? Good. That is exactly what I want to know.  So, let me give you another hint. The first hint was that I want to go through this edge faster than I would go through this edge. The other hint is that we are allowed to change the graph. Is this what we talked about in lecture, or are we thinking of something else? He might have talked about that at the end of lecture. Were you putting the current weight for each node inside the circles? No. You could add it and then if you could find a better path to B? With rows relative to A, then you could just delete that path? And B to 4? So at the beginning you add them all, but then You are risking to have exponential running time. LAUGHS Those are all valid optimizations under some constraints. Like, this one is good if you do not have too much memory, but the time goes up. I want my graph to have edges with no costs, because if I have costs, this is not going to work. BFS is not going to work. We ca not tweak it. If you could tweak it then that would be another Turing Award. So, create dummy nodes? Create dummy nodes. How do I do that? Put a band of node in between A and C? OK. Why am I doing this? So now I have two edges and they have costs. One. Then you put three nodes in between A and B. OK. And now here I have four edges, right? 1, 1, 1, one point There was a four here before and there was a two here before. Do you guys see what is happening? So, instead of one edge of cost C, I have C edges. So, now BFS is going to take C steps to go through that edge. And all the edges now have the same cost. This looks like a problem that BFS can solve. We know it can solve. We proved that it can solve it. Well, CLRS did. We take their word for granted, sort of. This works right? Is everyone happy with it? Does it make sense? So basically, we get through C before you will get to B on the other path. Yep. This is the path of length 3, so this node is going to get in the queue first. Then this node. Then these two nodes. And they are going to get in the queue from C. Let is see what happened here. This is really important because this is what you are going to be doing in real life. Chances of having to build a new algorithm? Kind of slim. Why do not you want to do that? Say you take Dijkstra and you tweak it a little bit. If you did that, you have to go through the analysis and prove the running time again, prove the correctness again. Time consuming, error prone, it is really hard. However, what happened here is that we have some problem that we want to solve. Say we have the raw input for that problem that we are trying to solve. That is this graph that I draw the board. And we apply some transform and we get an input that is suitable for an algorithm that we already know. I am going to take a shortcut here. We apply the transform, right? We took this graph and we built a new graph in. And this is hopefully easy. Right? Take an edge and split it up. Put in fake nodes. This is easy. We know how to code that. And now we have this algorithm that you already know, and we are treating it like a black box. We know it is correct. We know it is running time. We are not questioning them. We are taking them straight from the textbook. They have to be right. By the way, what is the running time of BFS? V plus E? Very good. Then BFS is going to give us a path, right? And the path is going to look like this. It is going to be A, fake node, C, D, fake node, E. If you are giving this back to the guy who gave you the problem, they are going to be like, what are these fake nodes? I do not know anything about them. This does not make sense. You need to take this raw output and you need to transform it again. Based on what you did this transformation, you have to read out the output. You have to interpret it. So, this is either interpret or readout. And then you get a nice output that is the output to your original problem. This process here is the most likely way in which you will use your six thousand and six knowledge. And this is replaced by any algorithm that we taught. This is replaced by any real life problem that you will encounter. There is one missing step here. We know the running time for this. Let is find out the running time for the whole thing. In order to do that, we have to figure out given this original graph. Let is say that now, in the original graph, we have V prime vertices, E prime edges, and W prime weights. We have to convert this into V plus E. We have to see when we make this transform, how many vertices do we get? How many edges do we get in terms of the original graph so that we can compute the running time? In the original graph, V prime vertices, E prime edges, W prime weights. In this new graph, how many edges do I have, at most? Something times E? Yep. Perfect. Each edge has cost at most W. That means we are going to split it up into most W edges. How many vertices are we going to have? W prime? W prime, E prime. Plus V prime? Plus V prime. Do not forget about the original ones. They are still there. So, total running time for BFS on this new graph is? E prime. Put it the other way around, plus W prime, E prime. This is the running time that we have. Now, does anyone remember Dijkstra is running time and Bellam Ford is running time? So what is the running time for Dijkstra? V log V plus E? Almost. V log V? Oh, wait. I think you are right. V log V plus E? I already named this from CRS? Or is this what we got? Entry is a fancy key to give this running time. . You can get this, but you need the really fancy data structure for it. In real life, the running time looks more like E log V. And how about Bellam Ford? So let is take this running time for Dijkstra because this is what you are going to implement in real life. And we can argue about that after next lecture for now. Take my word for it. And let is compare it to what we got here. V is smaller than E in most same cases. Let is say that this is actually W prime, E prime. If you compare this with this, you will see that, if W is smaller than log V, well, smaller equal, then this algorithm is not worse than Dijkstra. It is on par with Dijkstra. For graphs with small costs, we discovered an algorithm that solves shortest paths. You walked into this recitation knowing no algorithm to solve shortest path. Now we have an algorithm. Already in a much better position. Right? And we did not invent anything new. We do not have to prove correctness. All we did was one of these transformations. How is everyone feeling? Those things makes sense? Everyone happy? Let is talk about another problem that also uses this structure. Suppose we have the same graph that we had before, or actually, any graph with V vertices, E edges. Now we know how to compute shortest paths. So we can assume these as black boxes. We are going to use these as they are. We have a graph with V vertices and E edges. Let me copy the costs really quickly. Suppose this is the highway system, right, like in Google Maps. And we have two brothers. They start off from a place and they have to end up in another place. They are going to drive together. They want this to be sort of fair. Every time they go between two cities they are going to switch seats so that none of them drives too much. So say the brothers are Tim and Jim. The names are wrong. This is actually a problem from last year is quiz. So, by the way, real problem. You can pay attention now. These are two brothers. They are going to alternate. Right? One of them is going to drive across one road, then the other one, then the first one, then the second one. So on and so forth. Now, two Tim has a much better sense of direction than Jim. That is just how things are. And if you ever driven long distances, the hardest thing to do is to get from the city to the highway. Like, if you have to drive from here to New York. Hardest thing to do? Get out of Boston and onto the highway. Then, at the end, the hardest thing to do? Get from the highway into where you want to go through New York traffic. Everything else? Piece of cake. We want Tim to handle both of these situations. The driving path must start with Tim and must end with Tim. Otherwise, God knows, they are going to crash. First off let is convert this into graph terms. And then let is solve it. You might convert what is already in the graph. I have this constraint that they are going to switch seats and that Tim has to start and Tim has to end. How do I phrase this in mathy terms? In graph terms? We are starting it where and ending where? We are given where in the graph. We are starting at S, ending at T. Some points in the graph. And people have to drive with it an entire edge? Ya. So basically, Jim has to whoever the good driver has to to drive on the edge that is adjacent to E and S. Yep. OK. You physically need, like an odd number of edges. Yep. So I want the shortest path with an odd number of edges. Why odd number of edges? If we look at the edges, Tim is going to take the first one. Then Jim, then Tim, then Jim, then Tim, then Jim. No matter how many I have here, it has to end with Tim. So, I am going to have an odd number of letters here, therefore, odd number of edges. Right? So I want the shortest path that has an odd number of edges. And as the hint we are going to use that trick over there. Yes? But, the shortest path is not necessarily like the fairest, right? Like, in terms of distributing driving? One of them is going to drive one more road, such is life. Sorry, one more edge segment. Tim is going to drive three times, Jim is going to drive two times. Right, but like, in terms of the weights? Oh, yeah. We do not care about that. Jim does not know where he is going anyways. Just a minimum, we have to have like three paths, right? We do not just want Tim to get out to the highway and be like, oh look our journey is not that far So I went to the path with the smallest cost. So, smallest total weight. In theory it could be length, too. Right? Well, if it is length, too, then it is not going to be good because they are going to crash. Oh, I see. They have to switch every time. Tim ca not drive for two consecutive edges. You could use breadth first search and, once you get to the end point, or made all paths that are and then, of those paths, go through to see which one is the lowest cost? You are thinking enumerate all paths of even length? Just to make sure I got it. So this is cool because it let is me show something else that is cool. So, enumerate all paths of even length. Something else I heard, enumerate all the shortest paths. For both of these, let is look at this graph. S, T, all the paths have length one point How many ways are there to get from S to T? Two to three. Two to three. Two ways to go across this diamond. Two ways to go across this one. Two ways to go across this one. Right? two times two times 2? eight point If I add another diamond, how many paths? One more? So the number of even paths, or the number of shortest paths, the number of whatever paths I can think about is, order of? Come on, guys. Math. Rrrr Go  two to a number of diamonds? Which is? Roughly to the vertices. Exponential in the number of vertices. Not very good, not very good. We ca not do this. So, it is better that we talked about it here, then that you try to do it on the quiz and you have to discover this on your own, right? Good comment. Did not understand what you meant by that lecture. Now it makes sense. That is completely different. That was not the thing he was talking about? That is different. OK. That is where relaxation can go wrong. So if you show that if you relax the edges in a random order, you can have an exponential number of steps. This shows that there are an exponential number of paths for any graph, no matter how good your algorithm is. So we are not going to be able to enumerate them. Let is try something else. You have another suggestion? Just look at all the So, you are doing this. You are looking here. Everyone is looking here. How about this? We should do that? Ther is that, right? There is a transform. You need to transform your graph in some way, then run the algorithm. And then reading off the outputs should be easy. I claim that the hard step is the transform step, not the read off step. Let me give you one more piece of intuition. We are going to keep track of states, somehow. Remember Rubik is cube? We had one vertex for each state. A state representing the configuration of the cube. Here, suppose I am looking at the path from S to D. The problem that I have with this is that, if I have an algorithm that tells me the shortest path from S to D is something, I do not know if it is even or if it is odd. It is not keeping track of that. It is missing some state. The state that it is missing is whether the path that I used to get here is even or odd length. I should do something to the graph to keep track of this state. Can you BFS it once? To plan You BFS once. Then you that B and C are all like 108, and then you know that E and D are 208? B two hundred and eight if I take this path. It might be 108, might be two hundred and eight point But, this is good. This is what you will do on a quiz, right? You come up with an idea and then you are going to think about it for a bit. If you get stuck, try to convince yourself that it is wrong. If things get too hard, discard and look somewhere else. This is thought process, right? You think of something, backtrack, backtrack, backtrack, and eventually you get to the right solution. Let is go over the solution for this one, and then I will give you a hard one that is sort of like this. Then I will want the solution from you for that one. I am going to draw this graph in a bigger version, so I will have to erase this. So this is a cool concept. You will be able to do a lot of things with it. Is this one solvable by Dijkstra? Ya. Just curious. Yeah, we will run Dijkstra on it after we transform it. These are big nodes Why am I doing it this way? LAUGHS Is that like, Seattle, Portland, San Francisco? It is because I am going to need room for copies. I am going to make a copy of each node to keep track of state. Gosh. So, instead of one node I will have two nodes for each node. And I have two nodes because this is what lets me keep track of state, odd path or even path. Let me erase the edges because that is not how it is going to work, actually. Instead of having a node A, I am going to have a node A even. And I am going to have a copy, A odd. E even, I am going to have to copy, V odd. C even, copies to C odd. D even, make a copy to D odd. Wait, this is E, sorry. Sorry, my bad. QUIET TALKING Suppose I got to A using an even length path. If I take the edge from A to B, I will get to B using an even length path, or an odd length path? Odd. So, if I get to A using an even length path, then from there I will get to B using an odd length path. Sorry, four. Using this exact road. A really messed up graph. That is a nice way to name it. WOMAN LAUGHING I have heard worse. If I get to A using an odd number of edges, how many edges will I have and I get to B? . So this edge became these edges here. Now let is do the edge between B and E. I get to be using an even number of edges. I take B. Do I get to the even or to the odd? Odd. I get to B using an odd path. What are the lengths of these paths? five point Cool. God, this is starting to look ugly, you are right.  Let is do A, C and stop there. A even is connected to? Odd. C odd, by a path the length. And A odd is connected to C even by a path of length. Is this starting to make sense? So all the edges are going to look like this. So are those like two independent graphs? Well, I have edges connecting them. But, I like your question. The reason this is ugly is because I am looking at a 2D projection of a 3D graph. If I had a holographic display, which would be a lot nicer, then I would do something along these lines. Two pieces of paper. I would draw the original graph, and call it the even graph. Put it here. I would draw the graph again, call it the odd graph, and put it here. So this is my 2D graph. This is my map, the original map. And this is state. The third dimension is state. When I am at a node, and I used an even number of edges to get here, I am going to go take one edge and go to another node using an odd number of edges. So all the edges are going to go from here to here, and from here to here. Does it makes more sense now? So the reason that looks ugly is because you are seeing the graph like this. If you could see like this, and maybe play with it a little bit, it would make more sense. It would not look as ugly. There are two graphs, the even graph and the odd graph. And the edges between them represent you doing something. When you take the highway, you transition from an even state to an odd state, and from an odd state to an even state. So that is why the edges are the way they are. Now let me see if you guys get it. What node do I start from? What node do I want to end up in? A, and you are ending up at B?  OK. Oh, there is two I heard three answers. One of them is correct. Do you want to vote or do you guys want to figure it out? Talk it out? Fight? A even, E odd. We start from A even and we end up at E odd. Why do I started at A even? We have seen exactly zero cities when we started out. Yep, so the original path has length the 0, which happens to be even. And we want to end up with an odd length path. So if we go from here to here see how because we have two nodes out of each original node, the path is going to alternate between even and odd. And is going to keep track of the state that they did not have before, and it is going to just do the right thing. It is magic It works Let is see what is the running this new algorithm. Say my original graph had V and E. How many new vertices do I have? Two kinds. How many edges? Twice? Each edge is copied exactly twice. Which algorithm am I going to use? All my weights are positive because they are the time it takes to drive somewhere, the distance or something. So which algorithm do I use? Breadth first search? We ca not use breadth first search because you have weight. So breadth first search is not going to find the right answer. . Oh, you want to use this thing. Yes. Well, so we do not have to worry about that because now we put the shortest path algorithm in the black box and we have them. Oh, so we can use them now. We use these black boxes. But what we need to know is when to use this black box and when is this black box. Which boxes faster, by the way? Please, please give me the right answer. Dijkstra? All right Dijkstra is faster.  So whenever we can use Dijkstra we will use Dijkstra. When ca not we use Dijkstra? When it is negative,. Negative Weights. Negative weights. If I have weights greater or equal to 0, I am happy I can use Dijkstra. If I have weights that are smaller than 0, well, whatever. It is going to be slower, but I can still solve it. It is like arbitrary negative weights. Yep. Arbitrary negative weights. So all the edges here are positive, so I am going to use Dijkstra. Dijkstra Very good. So the running time will be, order of V log V? V log V plus E. If you are a theory person, if you are in real life it is E log V. This is exactly the running time for the original graph. The transformation only increased the graph size by a constant factor. So, same running time. Pretty good, right? OK, let is do one more problem. Let is do the hard problem now. Are you guys getting ready for the hard problem? If we had not seen this probably would not have thought of it. I would not even think about this. Well, that is why we taught you this. So I wanted to do two things. I wanted to show you that trick, which is a cool trick, keep track of state by multiplying the vertices that you have. And I wanted to go through some wrong solutions and figure out why they are wrong so you can develop an intuition. Because, when you are going to get a new problem, you are going to think of something. Unless you are really good, unless you are destined to win a Turing Award of some sort, the first solution will probably be wrong. Even if you are destined to win a Turing Award, the first thing that comes to mind will probably be wrong. I am willing to bet Dijkstra did not think of Dijkstra off the top of his head when he heard about the problem. What you want to do is get an intuition. So you think of a solution and it starts getting complicated, or things start looking wrong, you want to back out and think of something else. The more things we can consider, higher chances that you are going to stumble upon the correct solution. So that is why we are building an intuition for bad solutions.  I am not just saying, hey, give me a solution and now I will tell you it is wrong. It is not just to embarrass you or something. There is that intuition building step. That is really important. There is this network that we keep talking about. There is this highway network, except this time it is a bit more complicated. So for each edge I have two things. I have a fuel cost, which is constant. A fuel cost is a function of the length of the road. But now, I have these realistic highways where I have traffic. If you try to go from Boston to New York, two AM? Three hours. Rush hour? Six hours. So we have to keep track of this in some way. Well we are going to split up the day into minutes. Say you have ten minutes in a day. Can anyone tell me what M is, really quickly? Not a number, a formula, something. What is 3,600 times 24? And that is seconds. All right. So this is how many minutes in a day. This is how many minutes we have in a day, right? For each edge, we are going to have a function that is the time cost of the edge. So it is the time cost of this edge, and it is going to say, if I start at a certain time, it is going to take this many minutes to go across the edge. For each highway I know how much time it is going to take to go across it, given when I start. And I know much fuel I am going to consume. By the way, edges are directed now, just to make our life easy. This graph is going to be like this. Let is see if I can get this right. . So the real reason I am having this is the time to go across the highway might be different, depending which way you go. Oh Getting into Boston in the morning versus getting into Boston in the evening. Which one is easier? Sorry, versus getting out of Boston in the morning. Intuitively, I had say it is probably harder to get in in the morning because people are going to work. And it is easier to get out. But ya, I do not know either. The ninety five one is a hurdle.  We have an answer.  Our edges are going to be oriented. I want to find an itinerary that satisfies two constraints. . Ya, that is not good, right? New York and New York. WOMAN LAUGHING So I want to see how fast I can get to my destination. That is my top priority. If I get to New York at 500 PM, I want to get there at 500 PM. I do not want to get there at 501, for example. But if I have three ways to get there at 500 PM, I want to choose the way that is the most eco friendly. So, the least amount of fuel. So out of all possible ways, the fastest way? Out of all possible fastest ways, the way that consumes the least fuel? Go. You have two minutes. Maybe five. And we have the same costs for the Each edge always has the same fuel cost. But, depending on when you start, going across it is going to take a different time, too. And we do not know what those times are? They are going to be different for each edge. One guess, take Dijkstra. Find the shortest path length and we look for all path lengths that are that length. I do not know. So we have the issue that I might still have it. Oh no, never mind. Sorry, I erased it so it is not on your mind anymore. We have those diamonds that show you that there might be an exponential number of paths with the same length, or the same distance. And it does not help that we know we should cut off the Nope. So we need to do the process that I just erased. Transform the graph in. The thing is, now you are missing state, right? This misses state. This tells you how many edges you have to get from source to destination. But we are not keeping track of some state that these vital. Transform the graph to keep track of state, run, say Dijkstra, and then interpret the output. What state do we need? Let is think of that. Fuel cost, I think. Sorry? The two costs is the same for each edge. It is just the time is different. To be in traffic. But once we have found the fastest spot that we wanted to see cut into our fuel cost range and which one do we want to take. Thinking about the priority, our priority is time. So we want to save fuels as a state, to check it? The problem is I do not even know if fuel costs are integers. I ca not keep fuel as a state. How many copies would I have? For each vertex how many copies would I have if fuel is a state? Who knows? So let is try something else. But, you are on the right track. Let is take a variable and make it state. So for every vertex can you keep track of what is the shortest time it took to get there? What is the shortest time it took to get there? How would you keep track of that? Would you make that state, or how would you keep track of that? I am not disagreeing. I am trying to understand your So for example, let is say if you have B, right? Let is say it takes like one hour to go from A to B. It depends when you start, by the way. How much time it takes depends on when you start. If you start at 800 AM, it might be an hour. If you start at 900 AM it might be two hours. Do you need to have a finite number of states? It is nice if it is not infinite, but it does not have to be constant, like we had before. It can be more than constant, for sure. So what are you thinking? I want to use time as a state. I like that idea. Let is try to do it. We are going to use time as a state. How many vertices am I going to have for each vertex? So for each original vertex, how many vertices am I going to have in my new graph? Three or four. The sum of all times? So if I say, hey, I am at this vertex at this time, then I am going to have M vertices for each original vertex, right? Right. I promise that the resolution of time is minutes. I promise that this thing gives you an integer number of minutes. Can it be put into days, though? Suppose we can get from source to destination in one day. So let is see how it builds this graph first, and then we can figure out the rest of the things. So for each node I am going to make M copies of it. Suppose in my original graph I had a node. I am going to have M copies of that node. And each copy has the original vertex, and the time when I am there. Right? There are V of these. And there are M of these. Yes? It totally makes sense. It is a great idea. Yeah, you had it Great idea. So far so good.  Now they need to be connected to the appropriate next one. Let is hear how we do that. Suppose we have an edge from U to V. How are going to connect this? How are we going to transform this? How many edges are going to make from that edge? Do you have to do it from every start time? I guess. So you had write M edges. M edges. From U and a start time to V and what? T plus T C of T. T plus T C of going through that edge. Right? Right. T C are going from U to V at the stop. Ya, like this. So you start from a time. So the edge points from the time that you start up until the time when you had be able to finish. So, up until the time where you had be off the highway and die in the next city. And we need one more type of edges. There is one more tiny trick. If I am somewhere in Massachusetts, and I know that it is really bad now. I prefer to wait out for a few minutes, go to a bar, and then come and drive OK not to a bar go to a food place, then drive later.  vertical edges that represent waiting. You have to add one minute between them. How do I do that? From U to U with a cost of one point So from U to U at twenty plus one point I like this better. What is the fuel cost of this? Zero. So here this edge had fuel cost at C, Then the new edge is going have fuel cost for the ones on the top. Is it proportional to minutes? Speed? It is the same. F C stays the same, no matter when we go through the highway if C is a function of the distance of the road. This edge becomes M edges with the same cost. And then I have to have vertical waiting edges. If we had the holographic display that I talked about earlier you had have M sheets of paper this time. You start at time zero at your source and then your edges go represent the moves that you can make. So, you could start in Boston at 800 AM. And you could take I 90 and end up in I do not know Massachusetts city names Albuquerque at 900 AM?  Amherst. Amherst, OK. So you started in Boston 800 AM, you end up at Amherst at 9, 1000 AM. Right? So this is one edge. The edges represent the moves that you could make in this graph. Does this makes? I do not understand the two last lines there. I do not really get what we were doing there. Let is see what we are trying to do here. We are saying that, if I am a node U, and I am starting at time T. Ya, so that is like one piece of paper. Yep. I am going to go on the road, right? I am going to go on the road from U to V. So where am I going to arrive? There at V at some time plus that. Now we have to figure out what time we are going to arrive at. The time that we arrive at is the original time, plus whatever time I am going to spend on the road. What is the time I spend on the road? It is not constant because I have that timetable that includes traffic. So this is what this tells me. This is what this big, ugly formula is all about. It says the timetable for this edge assuming you start at time T. That is all there is. Nothing else. What is the second line, then? So the second line is waiting. So if I do not have this then I am constrained in that I have to drive all the time. I go from here to Amherst, then I have to go from Amherst to somewhere else, and keep going, keep going, keep going. . Yeah, this is where I wait for a minute. If I wait for a minute, I do not consume any fuel and I go from time T to time T plus one point OK. Does this make sense? Do we want to analyze the running time for this really quickly? Sure. How many edges? E times M? OK, let is do vertices because vertices is quick. V times M? So, edges is, you are saying, V times M? Almost. Pause there. So there is a pause, right? How many pause edges do I have? V M. This is how many vertices? This is how many edges? Plug this into which algorithm, Dijkstra or Bellam Ford? Dijkstra. Done Yay, we solved the hard problem. How do you ensure that the time is right? Do you have to go through and see if there is a path? How do we read the solution? That is good. That is a good question. I like that. So, we are going to have M vertices of the destination. Alright? Let is see how they are going to look like. First off, if you start at 800 AM, maybe you are not going to make it to New York at 801 AM. The vertex that says New York at 801 AM is probably going to have a cost of plus infinity. First off the really early times are going to have a cost of plus infinity. Not going to happen. Then, at some point, the cost is going to become finite. That is the fastest way you can get from Boston to New York. using the least amount of fuel. So the cost that you have there is the answer to our problem. So basically, when you get there you have to enter it through all M. All M vertices that correspond to the destination. The costs are going to look like this. They are going to be infinity, infinity, zero all the way up, until some point in here you are going to have your final answer. The cost to get there the fastest see, you can get there at 300 PM. This is how much fuel you have to spend to get there at 300 PM. But, if you are willing to wait until 301 PM, you are going to have the fastest cost you can have for that. If you are willing to wait until 302, you are going to have the answer for that, too. So here you are going to get the whole trade off curve of, if you are willing to wait for a few minutes, or if you are willing to wait for an extra hour, how much fuel you can save. So, I think that is cool about your questions. You had a question, too. Why did we have V times M in the E prime expression? First off, we have E times M, right? We are good with these. These are the waiting edges. So we are waiting after every minute? The waiting edges are vertex time to vertex time plus one point How many vertices? V. How many times? M. So it is V times M. Because at each minute, you can be at a certain city and decide to wait one more minute to stay the same city. OK Does this make sense? Thank you guys I am really happy we solved the hard problem That is good. 
</body>
</html>