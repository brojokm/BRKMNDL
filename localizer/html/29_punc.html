<html>
<body>
Are people understanding AVLs? That is good, because if everyone raised their hands, we had be done and out of here. So we are not covering new material in this recitation. We are talking about AVLs again, except this time you will tell me how we will do them, and we will look at the code and see how the theory matches the code. And I need one of these. Thank you. So let is start simple. What is a BST? Binary search tree. OK, binary search tree. It is binary because every node has at most two children. Why is it a search tree? It is easy to search. OK. Why is it easy to search? Because you start, is my number greater than this key or is it less than, and then you go from there. OK. So if I would have to state this as a formal rep invariant thing, what would I say it is so that I can do that operation? Node at right is greater than node at key, which is greater than node at left. OK, excellent. So it turns out I can use this argument recursively to say that for a given node, everything that is to the right of that node is greater, and everything that is to the left is smaller. And this allows us to do search quickly because if you are looking for a key, say you have numbers in your tree and you are looking for five point If you arrive at a node whose value is 4, you go right. If you arrive at a node whose value is 7, you go left. OK So what do we know how to do on BSTs? What are the operations that we know? Minimum, maximum. Min, max. Left, right, parent. So those are for the node. I want the queries and the updates for the BST type. Insert and delete. OK. Insert, Delete. Next larger. OK. And then in here, the S in BST. Someone give me the S so we can move on. Find. Find, search, depending on what code you are reading. What is the running time for these guys? Order h. Excellent. So everything has the same running time. Nice and easy to remember. Order h. What is h? . OK. How do we define this height? What is the height for this tree? . Good. What is the height for this tree? What is the height for this tree? Two. So now for a more general case, where this is the height, and the height of my left subtree is hl. The height of my right subtree is hr. What is h? It is the maximum of hr times hl plus one point Nice save. I heard a plus 1 somewhere there. Very good. This is r. So if we look at the first part of the code, lines one through eight, lines seven and eight implement the definition that we talked about here. So in our Python implementation, each node knows the height of the tree that he is the root of. And since we are storing that, we need to update it every once in awhile when we make changes to the tree, like when we insert nodes. And the way we do that is update height, which uses the formula that we came up with here. Now, there is a hack on lines two, three, four, five. Can anyone tell me what the hack is? The negative one point OK. How does that work? Why do I need it? That is so if you are at the root node, you can still calculate the height. Depends on how the root node looks like. If it has no children. That is a leaf. Yes. OK. So if I am in this case or in this case, what is hl, what is hr? In this case, I have this node of height zero, so I can make a small mistake here and it will save me, but here, I have no children, so hl and hr have to be set in such a way that this formula evaluates to zero point If I set them to minus 1, I will have minus 1, minus one point The maximum is minus one plus one equals zero point It is just to check the nodes for AVLs. We use that to update the height. For AVLs, we need to know the height of a node instantaneously. We ca not afford to go down the tree and compute the height every time we need it, so every node gets to store its height. There is a small field in each node that has the height. So we need to update that every once in awhile when we do insertions and deletions. This is how we update it, and in order to update it for this case, where we are at a leaf, we have to say that the height of a non existing tree is minus one point Of course, in theory and in real life, there are no non existing trees, so this is a clever hack to reduce code size. So we said binary search trees would look something like this. Is this guy an AVL? Does anyone think it is an a AVL? Does anyone think it is not an AVL? Can one of you tell me why? The tree with five as its root is not balanced. So this guy here is not balanced. Why is it not balanced? Because it has two on its right and zero on its left, so the difference is greater than one point You are saying that there is something here that is two, and something here that is OK, so height. So then it is almost like that. It is one here and minus one here. So the reason I asked you to clarify is that first you said two and zero, and that is the node count, and AVL does not care about node count. AVL cares about height. So for example, if I have something like this, this is a happy AVL. Three nodes, here one node here. The difference in node count is greater than 1, but the difference in height is one point Therefore, this is a good AVL. So what is a rep invariant for an AVL? The height of the left subtree for every node is within one of the height of the right subtree. Excellent. AVL. The core property is that for every node, the left height and the right height differ by at most one point What else? If we want to be completely rigorous, what else do we have to say? It is a BST. So an AVL is a special kind of BST, and that is why when we write the AVL code, we inherit from the BST and we use some of its methods heavily. Why do we like AVLs? What is so good about them? It is faster because it ensures the minimal height of the entire tree because most of our complexities are o of h, so it would have to be smaller. So we care about this. In a regular binary tree, the worst case that you have is this. Ignoring this part, this is a worst case binary search tree where it is basically a list, so height is order n. In an AVL, you are saying it is better. So the reason why we care about AVLs is that height is order of log n. Now, did people understand from lecture why that is the case? Can anyone tell me why that is the case? Well, it is just like every level you go down, if you split off that many times, of course it is log n. If you have n nodes and they are filled up to the edge, there is going to be log n of them. It is close to a full binary tree, right? For some definition of close. So here is what I use to remember, and I think I can persuade you that the height is log n using the argument that I will show you here. Let is start building a tree this way. Let is say I have a fixed height, and I want to have as few nodes as possible. If I have a tree with a big height and very few nodes, h is going to be bad when you write it as a function of n. So those trees are unbalanced. Big height, small number of nodes. So say we are trying to build an AVL with the smallest number of nodes and a fixed height. What if the height is 0? What does that tree look like? It is not too complicated, right? This is an AVL of height zero point It is the only possible AVL of height zero point Now, what if we are trying to build an AVL of height one that has as few nodes as possible? This is what it looks like, right? Height 0, height one point I could add another node here, but I do not want to because I want as few nodes as possible. Now, what if I tried to build an AVL of height two that has as few nodes as possible? Can I do this? So at the worst case, you have h minus one and then h minus two there. OK. You are moving ahead. You are forcing me to move faster, but you are right. And the reason is this is unbalanced. The height at the left has to be the height of the right plus or minus one point Ca not be anything else. So at the very least, I have to build a tree of height zero here, and I know that the best tree of height zero that I have is this guy. Cool. So for height 3, I would have to do this. And then you are saying, what would I use at the left? You had use whatever height is on the right minus two point The height on the right minus one per side. So on the right, I have a height two point On the left, I have a height one point If I want to go up to height 4, I do the same thing. So if I want to build an AVL tree with as few nodes as possible and height h, I start with the root, then at the right, I build an AVL tree of height h minus 1, and at the left, an AVL tree of height h minus two point And if these have the minimum number of nodes, then it turns out that the whole thing has the minimum number of nodes. I do not want to build a tree where the heights are equal because that would mean more nodes here, so this is the best I can do. This is the best way I can build a tall tree with as few nodes as possible. Suppose I want to write the number of nodes as a function of height. You are telling me what it is. When I was here, you were giving me the answer for this. So suppose I have a height, and I want to know how many nodes I have in my tree that has a minimum number of nodes. What is it? It is N h minus 1, and then plus N h minus two point There might be a constant. There might be a constant. N h minus one is this tree, N h minus two is this tree, so what is the constant? . Yep. This guy. Does not he have height 0, though? We are talking number of nodes. Oh. Number of nodes, yeah. I am not going to solve this now. We learned how to solve recurrences a long time ago, so I will pretend I still remember how to do that, and I will tell you that the solution looks something like this. N of h is roughly 5, which is the magic number that we talked about in lecture roughly, which means there might be some things there that I forgot to the h. What really matters is that it is an exponential in h. If you look at these guys, this is close to the Fibonacci number formula except there is a plus one here. So these guys are bigger than the Fibonacci numbers. This is definitely bigger than whatever the formula for Fibonacci numbers is, which is five to the h minus something over something. What really matters is the minimum number of nodes in an AVL of height h is an exponential as a function of h. If you invert that, you get that the maximum height for a tree with N nodes is log N. This is a way to construct an AVL that shows you that the height has to be logarithmic as long as we can keep this rep invariant true. I have a question. I did not quite follow how you got h minus two and h minus one there. Here, here, here? There. The tree down. This one? This one? This one, yeah. OK. So suppose I am at height four here. What is the best way to construct an AVL that has as few nodes as possible but height 4? If this guy has to be at height 4, then it has to have a child at height 3, at least one child. Otherwise, it is not going to be height four point Now, I need to build something here that has height three point What should I build? The best AVL tree that I know that has height 3, right? I have to get to height three using as few nodes as possible, so I am going to use this guy because it has as few nodes as possible and it has height three point So this covers my right side. Now, for my left side, what am I going to use here? Another AVL tree that has as few nodes as possible, right? So I am definitely keeping that. But what is going to be the height of that? So we want the difference to be less than or equal to 1? Yeah. Otherwise, it is not an AVL. So it would be of height four point So I know for sure that this guy has height four point The difference has to be plus, minus one point So it would be two point 2, 3, four point I know for sure I do not want it to be 4, and now I have to choose between two and three point A tree of height two will have fewer nodes than a tree of height 3, so that is why we are doing it this way. So to build a tree of height 4, build a tree of height 3, build a tree of height 2, connect them together. That is how we get to this, and then this. Cool. Do people remember how to do insertions and deletions in a regular binary tree? Yes? How do I insert six point five here in this one? You take 6. 5, you are like, oh, it is greater than 4, then you move to five point Then you are like, oh, it is greater than five point Go to six point Oh, it is less than 6, and then it goes to the left of six point I mean sorry. I meant left of seven point OK. So it is bigger than Testing you all, guys. Oh yeah. six point five is bigger than 6, so then it goes to the left of seven because it is less than seven point I thought I had my example wrong for a second. I am just tired. Me too, so do not scare me. All right. So suppose we have heights stored in the nodes here, because we want to do that for AVLs. We will figure out why in a bit. The height of this guy used to be 0, 1, 2, 3, right? 0, 1, 2, three point What happened when I added this node? You added one to everything. Yeah. So I went down on my insertion path to find out where to insert a node, and then I added it. I just chose my case conveniently, but in some cases, all the heights of the nodes on that path have changed. So in an AVL, after we insert, we have to make sure that the height of every node on the path is updated. Does this make sense? So the heights will be 1, 2, 3, four point So the way we implemented the AVLs is that we do regular insertions and deletions, and then at the end, we say, well it used to be an AVL. Now we added or removed the node, so it might be a slightly unbalanced AVL, which means it is not an AVL. And we have the rebalance procedure. So if you look at on the second page of the code, insert and delete are really tiny, lines twenty to twenty two and twenty four to twenty eight point And they are really tiny because they call the old code and then they call Rebalance. So all the magic in an AVL is in Rebalance. The first thing that Rebalance does, if you see, it has a while loop there, and the first thing that it does in the while loop is it updates the height, and this is why. The height might have changed after the insert, so any decision based on the old height is bad. That is why we have that there. Make sense so far? So if you look at rebalance, do not try to understand it quite yet, but what it does is it calls Rotate Left and Rotate Right. Well, Left Rotate, Right Rotate. All the magic is in Rebalance, and the tools that it uses are Left Rotate and Right Rotate. Now, I am going to show you what a rotation is supposed to do in and the children of these nodes are a, b, c, d. Also, this node is hanging off of something here, e. If I want to do a Right Rotate here, so if I want to rotate the tree like this, then after rotating, it is going to look like this. So notice that c got moved from B to A, but it got moved in such a way that the whole thing is still a BST. These guys show up in the same order as children, and these guys show up in the same order, so search will still work. This is how it is supposed to look like as a picture. Let is try to write the pseudocode for achieving this. First, you identify the parent node. Step one. Well, let is say we have it. I mean from B. You say, A is my parent. That is now going to become my right child. OK. So what do you want to change? By the way, this whole thing has to happen in constant time, so we are not allowed to go anywhere inside here, here, here, or here. We are allowed to change these links, but if you go inside and try to do more complicated restructuring, that is going to block the running time. We are only allowed to change the links that you see on the board. I know in the BST, not BST node but BST, the delete, if you are deleting the root, they make up the pseudoroot. Let is not worry about it. So Delete already did that magic for you, right? So the pseudoroot would be here, so this node has a root. We are happy. That is not what I am talking about. I am saying that you could do the same with B because you are going to have to break a link with lowercase c onto B in order to flip it. So I am saying you could have a placer, some sort of place to put it so you do not lose it. OK. Let is see if we do that. The new right child of B will be A, and the new left child of A will be C, and the new parent of c is A. OK, let is move slower. I have to write them down. So the new right child of B is? Is A. Also, you probably should do temp variables to store them. I do not think you have to. You can just swap the one connection and swap the other. Let is do it without worrying about temps, and then we can figure out temps later. So B is right becomes A. So it is going to be like this. Let me erase this confusing error. And A is left child is c. A is left child is c. OK. C is parent is A. C is parent is A. OK, very good. So I changed the child, then I changed the parent so that they would match up. So if B is right is A, then what should I do with A is parent is B. Always do them in pairs so you do not lose track of them. And? B is parent is e and e is subchild is B. Sorry. B is parent is e, right? Yeah. So B is parent is e, and e is left. Child is B. Because I drew it like this, right? But if I drew it like this? e is It would have to be the right child, so we have to look at both cases. If B is greater than e, then it would be right child, and if B is less than e, it would be left child. OK. So if B is greater than e, then e is right is B. Otherwise, e is left is B, right? Now, suppose comparisons are expensive and they do not want to do a comparison to find this out. I want to play with the tree instead. What do I do? Can you see which one A was before that? Yep. If A used to be the right child, now B is the right child. Yeah. I have not changed the child yet, so I can do that. That is still a comparison though, right? But now I am doing a pointer comparison and not a key comparison. If e. r is A, then If e. right is A, then it becomes B. Otherwise. OK, this looks good. So there is the issue of temp variables and assigning these in the right order so you do not have too many temp variables and too many lines of code, and the Python code in the handout takes care of that. But this is the logic that you want. So if you have to write it from scratch, you do not have to memorize that. Remember that you want to get from here to here, and do exactly the thought process that we have here. What if I want to do a left rotation instead of a right rotation? You just have to change the r is to l is. Very good. Copy, paste. Swap l is and r is and we are done. Why do we need rotations? To rebalance stuff. To rebalance stuff. OK. Why do we rebalance stuff? Because you do not want your code to crash when you add nodes that are sequentially larger, and then you try to find something, and then it crashes. OK. Why would it crash? Because the recursion depth is exceeded because you are going down the line trying to find something, and you go down too far. OK. So pretending we do not have a recursion depth issue, then it is going to be slow. So you start from a nice AVL, and if you do not rebalance, you get to a BST that is slow, slow, slow, and then you will fail our tests and still get a zero point Yes? But if you just had a carrot like tree, or if you added, for instance, 4, and then you added in 5, and then you added in 3, and then you added in 6, and then you added in 2, you had just get a carrot. So then I feel like AVL would not cover that case. Let is do them in sequence. So what are we inserting? So you said four point So you start with 4, and then you insert 5, then you insert three point Let is see. 4, three point Then you insert 6, then you insert 2, then you insert 7, and then one point You have got to rotate that. Well, the thing is Well, is this an AVL? Well, it is balanced. Is it? No, it is not. five is unhappy. That height of the tree is only one greater than the other height. So the height here is one point What is the height here? There is nothing here, so the height is minus one point I mean, but the other side of the tree. So if you are looking at this guy, things look balanced, but in an AVL, this has to hold for every node. If there is one node where the heights are unbalanced, the whole thing is unbalanced. Otherwise, the construction that we did before would not make sense. It is all within the. Yep. So now that we are going to look at rebalancing, which is the magic behind AVLs, we have to make sure that after we start with something that is slightly imbalanced, when we rotate things around, we have to make sure that everything gets balanced at the end and happy, so that is a good thing to keep in mind. Good. Any other questions? Is it obvious that you can put any number of nodes in an AVL tree? Point any number of nodes? Yeah. It is obvious that you can do one node, or two nodes or three nodes, but is it true that for any number of nodes, you can arrange into an AVL tree? Does that make sense? Yeah. So if you want to have any number of nodes, you call Insert, AVL Insert, and then you will get an AVL. Right. But what I am trying to say is, is it possible to construct an AVL tree out of thirteen nodes? Sure. Or seventeen nodes? Is there a limit for where that property will not fit? Right. Is there some set of nodes I like this question. I like this question. So what would be the perfect binary search tree? An element of log N height. An element of log N height and the complete tree, so something that looks like this. Where did we see this thing before? In the heap. All right. So a heap looks exactly like this, except the values inside do not fulfill the BST requirement. Otherwise, we had know how to build perfect BSTs. It so happens that we do not. But is this an AVL? Yes. That example or in general? Let is start with that example. Is this an AVL? No. The node just to the left of the root This guy? No. That one is of height two, so it has height one. This is beautiful. This is as good as it could get. This is an optimal binary search tree. This is perfect. It better match the definition of AVL, because otherwise, it would mean AVL does not like perfect trees. So the good news is that any complete tree is going to be an AVL because everything is perfectly balanced or almost perfectly balanced. The only thing that is not complete is the last level. So all the paths from the roots to the last level are either height log N or height log N minus one point So wherever you do the height comparison, you are going to get a difference of 1, and we can keep adding nodes to this. This is how I had build a BST of as many nodes as we want. I have a question. For the fixed heights, why we try to minimize the nodes? Would not a better way to build a more efficient tree is to try to minimize the height? So instead of adding nodes up, just fill in the tree? Very good. So you are thinking of how to build an efficient tree, how to build a good tree. Here, I am trying to prove the property about the maximum height of a tree. So here I am playing devil is advocate. I am thinking, what is the worst case for AVLs? How do I make AVLs look as bad as possible? That is why I started this way. So usually, we are the good guy coding, but after you are done coding and you know how your algorithm runs, if you want to have peace of mind and go to sleep well and get full points afterwards, it sometimes helps to think as devil is advocate. How would I break this algorithm? What is the worst thing that I could do to it? And if you can find something that breaks it, well, you probably know how to fix it. If not, you can sleep well at night and know that your algorithm is sound. In that example on the board, where we said the height of the tree on the left side was h minus 1, and then the other side had the h minus two point For that h minus two tree, every node in that has to be h minus two height, every leaf. Is that what we are saying? Otherwise, it falls apart because there would be one that is So we are saying that the root of this tree has to be h minus two point And the way we do this is we copy this guy over, so this guy is lopsided, too. So it is not every path to the bottom, just one path. OK. So it could be an incomplete. Yep. In that case, is that balanced? So this was an AVL of height 2, right? If I stick it here, it is still going to be an AVL of height two point Right. This thing will have height two point This thing will have height three point OK. So it is not everything on the same level, necessarily, that needs to be of the same height. It is only the children. Yep. So the two children, so two nodes on the same level, might have their heights differ by one, but not more than one. If they could differ by more than one, you could have a link list. Because they differ by one, then it is sort of sane. It is almost balanced. Good. I like the questions. It means you guys are thinking. I really like it. Yeah? If they differ by one. So you have an ideal tree up there, and then you have the worst case possible. That would not affect performance at all, right, if you have the worst case? So what we know what performance is we have this guarantee. It is at worst a constant times log n. This is constant times log n. The constant happens to be one point This is a constant times log n. The constant happens to be something bigger than one point I think it is somewhere between two and three point That just varies by the constant. Yeah. And since we only care about asymptotics in this class, we are happy. But we do not know how to build this. This is just something pretty that we draw on a board, but we do not have an algorithm that efficiency builds this out of a random series of insertions and deletions. I hope we do not. Otherwise, I look bad. What do I want to delete? Instead of a binary search tree as the base of the AVL, if you wanted to have four children per node, would this change that much except you had just have twice as many variables? That is a good exam question. So it turns out that there is this tree called a B tree, which has 1,000 or more nodes. B tree? Does not that stand for binary? No. It is B. Just B. That is used for databases on disk. So there, you want to make the height as small as possible, because every time you get a node, you do a disk access, and that is expensive. But once you do a disk access, the nodes can be as big as you want. You can read a few bytes off the disk at roughly the same cost as you can read a megabyte, so you are better off reading a megabyte. I might be exaggerating a bit, but for a few kilobytes, that is true. So B trees have thousands of children, and they keep them sorted. It is sort of like that, but the fan out is huge. And it turns out everything is still log n as long as the number of children you have is constant. But for this rotation thing, though. Oh god, no. We do not have to rotate. It gets a lot more complicated. We have not gotten to rebalancing yet, right? Wait until you see how rebalancing looks like with two children, and then imagine trying to figure out the cases for 1,000 children. That is not sane. In B trees, they use something else to make them balance the right way. And of course, they are harder than this. So let me try to get through rebalancing somewhat quickly. This is where I forget what I need to do. Rebalancing. So suppose we call Rebalance on this guy, and we know that the nodes here have heights k minus 1, this is k minus one or k, and this is k, and I want to call Rebalance here. Let is first figure out if it is an AVL tree or if there is something wrong with it. What is the height here? k plus one point So no matter what the height is here, the height here has to be k plus one point What is the height here? k plus two point OK. What else can you tell me about this node? If I call Check RI on it, it is going to crash because the rep invariant for AVLs does not hold here. This child at the top of this tree will have height k minus one point This will have height k plus one point The difference is more than one point Not good. So this is unhappy. How do we fix the situation? Rotate left around k plus one point All right. So it better be a rotation, because we spent so much figuring out how to rotate. Let is see what happens if we rotate this way, and the way to keep track of this is I am going to label my nodes. B, A, left child of A has height k minus one point This guy is k minus one point So what is the height of A now? k. Oh wait, that is not a node. Just k minus one or k. So this is a tree of height k minus one point This is a height of tree k minus one or k. The height of this guy is? k. k plus one point Or k plus one point The height of this guy is definitely k. The height of this guys is k or k plus one point Is that an AVL? Is it happy now? So this is the easy kind of rebalancing, one rotation and you are done. the difference between k minus one and k minus one over k? It is not k minus one over k. It is either k minus one or k. Bad notation. Thank you for the question. You saved everyone from confusion. No, there is no fractional heights. Anything else? Thank you. That was good. All right. So this is easy, right? This is the easy rotation. Let is do the hard one now. What is the height here? k plus one point What is the height here? Plus two point AVL, not AVL? No. k minus one on the left child, k plus one on the right child. The difference is more than one. Not an AVL. How do we fix this? Make a right rotation. Sorry? Make a right rotation on k first. So make a right rotation where? On k plus one point Let me break this up so we could see how that would work out. So these two are k minus one and k minus 1, and these nodes are A, B, and C. So you are saying do a right rotation here, right? Let is see what that gets us to. So A is the same, and then here I am going to have C instead of B, and B. The right child of B is the same as it was before. The left child of B is k minus one point Then the left child of C is another k minus 1, and this guy is k minus one point OK, what is the height at B now? k. OK. What is the height here? k plus one point And the height here? k plus two point Is this an AVL? So we are not done, but what is the good news about this? Now you can rotate it left around C. Yep. Exactly. That is this, and we know how to fix this in one step. You said exactly the right thing. This is exactly what we do. First, rotate here so that we get to that, and then we are in the happy case. So intuitively, the difference between the happy case and the harder case that is going to be happy eventually is where the heavy path is, so where you have the bigger height. In this case, k plus 2, k plus 1, k. So the heavy path is this thing here. It is a straight line. Because of that, we can rotate here and then redistribute the weights uniformly. In this case, the heavy path is this. It is a zigzag, so one rotation wo not fix it. Instead, we do one rotation here so that we make the weights be distributed in a straight line, and then one rotation here, which makes everything look good. Yes? So that is just a general pattern. And you redistribute? So the first thing we do is say you are at a node and you need to rebalance. First thing, you check the heights and see if it is already balanced. If it is not balanced, suppose your heavier node is on the right. Then you go and see if the right child is heavier or the left child is heavier. So you see if the height distribution is a straight line or is exact, and then you decide whether you are going to do one rotation or two rotations. So this is all nice and good except for one thing. The heights keep changing here, and we are storing the heights in each node. So if we are doing all this rotating without updating the heights, then we are going to have something that looks like an AVL but does not keep track of the heights anymore, so eventually, we are going to make bad decisions. So we need to update the heights. Where do we update the heights? You can look at the code and cheat or you can try to think and tell me the answer, either way. So this only does rotates, right? If rotates would be able to update the heights, everything would be good. I would not have to worry about this. Pretend I had not deleted the original case here, which I think was A, B, C, and then some children. What heights changed here? When I did this rotation, what heights changed? B is height changed. B, A, and C is greater than B. B and potentially A. If I am not sure, then I am going to try to update the height anyway to make sure that I have the right height. After I do this, I have to update the height on B and update the heights on A. Is this correct? And B. And all the way up. Let is assume that happens. Does this look right? Do not you also have to update for C? For c. Did I change anything under c? I think he is talking about capital C. Oh, capital C. Yeah, OK. So the children are the same. They were a and b before, they are a and b afterwards, so I do not have to worry about this guy. The heights here have not changed, so the height here has not changed. But you are thinking of a problem, and that is good because there is a problem here. What if there is a subtree instead of small c? A subtree instead of small c? OK, so yeah, this is a subtree. After rotating, this subtree moves over here. Wait. You have to update A first, and then update B. OK. So the height starts from the bottom. The bottom height zero, the next one up, the next one up, the next one up. Keep that in mind. Nothing changed below this guy, nothing changed below this guy, nothing changed here, so I do not have to update these. But when I compute the height, update height at the beginning of the listing assumes that the height of the children is correct. So when I compute the height of my mode, the height of the children has to be updated. So if I call Update Height of B first, I already know that this might have changed, so whatever answer I get is bogus. So this does not work and I have to do this. This is rotation. That is rebalancing. One more trick to rebalancing. So we talked about rebalancing the subtree at one node. What is missing from this picture? So you check it on all levels? Yeah. So I made some changes here. My tree might look happy starting from here on, but if I did an insertion or a deletion, heights changed all the way up, so I have to go all the way up and do more rebalancings potentially. And that is it. These are AVLs. Any other questions? Did you guys get them? Do they make more sense now? Yes. OK. Good. You will have to play with them on the next Pset. By play, what do you mean? Well, you are not writing it from scratch. You have to modify existing code. What are we going to make it do? So you will have to keep track of something other than heights. You will have to keep track of a new value. Oh, like the minimum or something? Or something, yeah. 
</body>
</html>