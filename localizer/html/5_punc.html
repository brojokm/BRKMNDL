<html>
<body>
Today is lecture is about a brand new data structure that you have probably seen before, and we have mentioned earlier in double 06, called a binary search tree. We have talked about binary search. It is a fundamental divide and conquer paradigm. There is a data structure associated with it, called the BST, a binary search tree. And what I want to do is motivate this data structure using a problem. It is a bit of a toy problem, but certainly a problem that you could imagine exists in all sorts of scheduling problems. It is a part of a runway reservation system that you can imagine building. And what I will do is define this problem and talk about how we could possibly solve it with the data structures you have already seen so lists and arrays, heaps as well as, which we saw last time and hopefully motivate you into the reason behind the existence of binary search trees, because they are kind of the perfect data structure for this particular problem. So let is dive into what the runway reservation system looks like. And it is your basic scheduling problem. We will assume an airport with a single runway. Now Logan has six runways. But the moment there is any sort of weather you are down to one. And of course, there is lots of airports with a single runway. And we can imagine that this runway is pretty busy. There is obviously safety issues associated with landing planes, and planes taking off. And so there are constraints associated with the system, that have to be obeyed. And you have to build these constraints in and the checks for these constraints into your data structure. That is sort of the summary of the context. So reservations for future landings is really what this system is built for. There is a notion of time. We will assume that time is continuous. So it could be represented by a real variable, or a real quantity. And what we had like to do is reserve requests for landings. And these are going to specify landing time. Each of them is going to specify a landing time. We call it t. And in particular, we are going to add t to the set R of landing times if no other landings are scheduled within k minutes. And k is a parameter that could vary. I mean, it could be statically set to three minutes, or maybe four point You can imagine it varying it dynamically depending on weather conditions, things like that. For the most of the examples we will talk about today, we will assume k is three minutes, or something like that. So this is about adding to the data structure. And so an insert operation, if you will, that has a constraint associated with it that you need to check. And so you would not insert if the constraint was violated. You would if the constraint was satisfied. And time, as I said, is something that is part of the system. It needs to be modeled. You have the current notion of time. And every time you have a plane that is already landed, which means that you can essentially take this particular landing time away from the set R. So this removal, or delete we remove from set R, which is the set of landing times after the plane lands. So every once in awhile, as time increments, you are going to be checking the data structure. And you can do this, maybe, every minute, every thirty seconds. That is not really important. But you have to be able to remove from this data structure. So fairly straightforward data structure. It is a set, R. We do not quite know how to implement it yet. But we had like to do all of these operations in order log n time, where n is the size of the set. All right? So any questions about that? Any questions about the definition of the problem before we move on? Are we good on? OK. So let is look at a real straightforward example, and put this up here so you get a better sense of this. Let is say that, right now, we are at time thirty seven point And the set R has 41. 2, 49, and fifty three in it. And that is time. Now you may get a request for landing time fifty three point And I am sorry. I want to call this fifty six point three 41. 2, 49, and 56. 3. You may get a request for landing time fifty three point And right now the time is thirty seven point It is in the future, and you say OK because you have done the check. And let is assume that k equals three point And fifty three is four ahead of 49, and three point three before 56. 3, so you are OK. forty four is not allowed. It is too close to 41. 2. And 20, just for completeness, is not allowed because it is passed. Ca not schedule in the past. I mean, it could be the next day. But then you would not call it twenty point Let is assume that time is a monotonically increasing function. You have a 64 bit number. It can go to the end of the world, or 2012, or wherever you want. So you can keep the number a bit smaller, and do a little constant factor optimization, I guess. So that is sort of the set up. And hopefully you get a sense of what the requirements. And you guys know about a bunch of data structures already. And what I want to do is list each one of them, and essentially shoot them down with respect to not being able to make this efficiency requirement. And I had like you guys to help me shoot them down. So let is talk about an easy one first. Let is say you have an unsorted list or an array corresponding to R. That is all you have. What is wrong with this data structure from an efficiency standpoint? Yeah. Pretty much everything you want to do to it is linear. That is exactly right. Pretty much everything you want to do to it is linear. And so you want to check the k minute check. You can certainly insert into it, and just add to it. So that part is not linear, that is constant time. But certainly, anything where you want to go check against other elements of the array, it is unsorted. You have no idea of where to find these elements. You have to scan through the entire array to check to see whether there is a landing time that is within k of the current time t that you are asking for. And that is going to take order n time. So you can insert in order one without a check. But sadly, the check takes order n time. All right? Let is do something that is a little more plausible. Let is talk about a sorted array. So this is a little more subtle question. Let is talk about a sorted array. What happens with a sorted array? Someone? What can you do with a sorted array? Yeah. Do a binary search to find the. Binary search would find a bad insert. OK, good. So that is good. So if you have a sorted array, and just for argument is sake, it looks like 4, 20, 32, 37, forty five point And it is increasing order. And if you get a particular time t, you can use binary search. And let is say, in particular, the time is, for example, thirty four point Then what you do is you go to the midpoint of the array, and maybe you just look at that. And you say oh, thirty four is greater than thirty two point So I am going to go check and figure out if I need to move to the left or the right. And since it is greater I am going to move to the right. And within logarithmic time, you will find what we call the insertion point of the sorted array, where this thirty four is supposed to sit. And you do not necessarily get to insert there. You need to look, once you have found the insertion point, to your left and to your right. And do the k minute check. So finish up the answer to the question, tell me how long it is going to take me to find the insertion point, how long it is going to take me to do the check, and how long it is going to take me to actually do the insertion. Log n in the search Log n for the search, to find the point. Constant for the comparison? Constant to the comparison. And then the last step? Do the research. Sorry, little louder. Sorry. The insertion is constant. Insertion is constant? Is that right? Do you people agree with him, that insertion is constant? You have got a maximum size up there, right? There must be a maximum.  No, the indices so right now the array has indices i. And if you start with 1, it is 1, 2, 3, 4, 5, et cetera. So what do you mean by insertion? Someone explain to me what yeah, go ahead. When you put something in you have to shift every element over. That is exactly right. That is exactly right. Ok, good, that is great. I guess I should give you half a cushion. But I will do the full one, right? And you get one, too. So the point here is this is pretty close. It is almost what we want. It is almost what we want. There is a little bit of a glitch here. We know about binary search. The binary search is going to allow us, if there is n elements here, to find the place it is going to be able to find and I am going to precise here the smallest i such that R of i is greater than or equal to t in order log n time. It is going to be able to do that. You are going to be able to compare R of i and R of i minus one so the left and the right against t in order one time. But sadly, the actual insertion is going to require shifting. And that could take order n time, because it is an array. So that is the problem. Now you could imagine that you had a sorted list. And you could say, hey if I have a sorted list, then the list looks like this, and it is got a bunch of pointers in it. And if I have found the insertion point, then the list is nice, because you can insert something by moving pointers in constant time once you have found the insertion point. But what is the problem with the list? Yeah. You ca not do binary search. Well you ca not do binary search on a list. There is no notion of going to the n by two index and doing random access on a conventional list, right? So the list does one thing right, but does not do the other thing right. The array does a couple things right, but does not do the shifting right. And so you see why we have constructed this toy problem. It is to motivate the binary search tree data structure, obviously. But you are close, but not quite there. What about heaps? We talked about heaps last time. What is the basic problem with the heap for this problem? The heaps are data arrays, but you can visualize them as trees. And obviously if we are talking about min heaps and max heaps. So in particular, what goes wrong with a min heap or a max heap for this problem? What takes a long time? Yeah. You have to scan every element, which. That is right. I mean, sadly, you know when we talk about min heaps or max heaps, they actually have a fairly weak invariant. It turns out that I am previewing a bit here binary search trees are obviously similar to heaps in the sense that you visualize an array as a tree, in the case of a heap. And binary search trees are trees. But the invariant in a min heap or a max heap, is this kind of a week invariant. It essentially says, look at the min element. And the min element has to be the root, so you can do that one operation pretty quickly. But if you want to look for a k minute check, you want to see if there is an element in the heap that is less than or equal to k, or greater than or equal to k from t, this is going to take order n time. OK? Good. And finally, we have not talked about dictionaries, but we will next week. Eric will talk about hash tables and dictionaries. And they have the same problem. So it is not like dictionaries are going to solve the problem, for those of you who know about hash tables and dictionaries. But you will hear about them in some detail. They are very good at other things. So I do not want to say much more about that, because you are not supposed to know about dictionaries. Or at least we do not want to assume you do, though we have talked about them and alluded to dictionaries earlier. And so that is a story here. Yeah, back there, question. Yeah, can you explain why it is time? So what is a heap, right? A heap essentially a min heap, for example, or we talked about max heaps last time, has the property that you have an element k, and you are going to look at, let is say it is twenty one point Let is do min heaps, so this has to be less than what is here, 23, and what there, maybe it is 30, and so on and so forth. And you have a recursive definition. And when you insert into a min heap, typically what happens is suppose you wanted to insert, for argument is sake, I want to insert twenty five point I want to insert twenty five into this. The insertion algorithm for a min heap typically adds to the end of the min heap. So what you do is you would add twenty five to this. And let is say that you had something out here. So you had add to it. And you had start flipping things. And you could work with just this part of the array to insert twenty five in here. And you had be able to satisfy the invariant of the min heap. And you had get a legitimate min heap. But you had never check the left part of it, which is twenty three point So it is quite possible and this is a good example that your basic insertion algorithm, which is essentially a version of max heap of i, or min heap of i, would simply insert at the end, and keep flipping until you get the min heap property, would be unable to check for the k minute check during the insertion. But what you had have to do is to go look elsewhere. That min heap of i we had never look at or the insert algorithm we had never look at and that would require order n time. All right? Thank you. So that is the story for the min heap. Thanks for the question. And it is similar for dictionaries, as I said. And so we are stuck. We have no data structure yet that can do all of the things that I put up on the board to the left, in order log n time. And as you can see, the sorted array got pretty close. And so if you could just solve this problem, if you could do fast insertion and by fast I mean order log n time into a sorted array, we had be in business. So that is what we had like to do with binary search trees. Binary search trees are, as you can imagine, enable binary search. But the sorted arrays do not allow fast insertion, but BSTs do. So let me introduce BSTs. As with any data structure, there is a nice invariant associated with BSTs. The invariant is stronger than the heap invariant. And actually, that makes them a different data structure, not necessarily a better data structure. And I will say why, but different. For this problem they are better. So one example of a binary search tree looks like this. And as a binary tree you have a node, and we call it x. Each of the nodes has a key of x. So thirty is the key for this node, seventeen for that one, et cetera. Unlike in a heap, your data structure is a little more complicated. The heap is simply an array, and you happen to visualize it as a tree. The binary search tree is actually a tree that has pointers, unlike a heap. So it is a more complicated data structure. You need a few more bytes for every node of the binary search tree, as opposed to the heap, which is simply an array element. And the pointers are parent of x. I have not bothered showing the arrows here, because you could be going upwards or backwards. And you could imagine that you actually have a parent pointer that goes up this way, and you have a child pointer that goes this way. So there is really, potentially, three pointers for each node, the parent, the left child, and the right child. So pretty straightforward. That is the data structure in terms of what it needs to have so you can operate on it. And there is an invariant for a BST. What makes a BST is that you have an ordering of the key values that satisfy the invariant that for all nodes x if y is in the left subtree of x, we have if it is in the left subtree then key of y is less than or equal to key of x. And if y is in the right subtree we have key of y is greater than or equal to key of x. So if we are talking about trees here, subtrees here, everything underneath and that is the stronger part of the invariant in the BST, versus in the heap we were just talking about the children. And so you look at this BST, it is a BST because if I look to the right, from the root I only see values that are greater than thirty point And if I look to the left, in the entire subtree, all the way down I only see values that are less than thirty point And that has to be true for any intermediate node in the tree. And the only other nontrivial node here is seventeen point And you see that fourteen is less than 17, and twenty is greater than seventeen point OK? So that is the BST. That is the data structure. This is the invariant. So let is look at why BSTs are a possibility for solving our runway reservation problem. And what I will do is I will do the insert. So let is start with the nil set of elements, or null set of elements, R. And let is start inserting. So I insert forty nine point And all I do is make a node that has a key value of forty nine point This one is easy. Next insert, seventy nine point And what happens here is I have to look at 49, and I compare seventy nine to forty nine point And because seventy nine is greater than forty nine I go to the right and I attach seventy nine to the right child of forty nine point Then I want to insert forty six point And when I want to insert forty six I look at this, I compare forty nine and forty six point forty six is less, so I go to the left side and I put forty six in there. Next, let is say I want to insert forty one point So far I have not really talked about the k minute checks. And you could imagine that they are being done. I will show you exactly, or talk about exactly how they are done in a second. It is not that hard. But let me go ahead and do one more. For 41, forty one is less than 49, so I go left. forty one is less than 46, so I go left and attach it to the left child. All right? So that is what I have right now. Now let is talk about the k minute check. It is good to talk about the K minute check when there is actually a violation. And let is assume the k equals three here. And so, same thing here. You are essentially doing binary search here. And you are doing the checks as you are doing the binary search. So what you are going to be doing is you are going to check that you are going to compare forty two with 49, with the k minute check. And you realize they are seven apart. So that is OK. And forty two is less than 49, so you go left. And then you compare forty two with forty six point And again, it is less than 46, but it is k away, more than three away from forty six point So that is cool. And you go left. And then you get to forty one point And you compare forty two with forty one point In this case is greater. But it is not k more than it. And so that means that if you did not have the check, you would be putting forty two in here. But because you have the check, you fail. And you say, look, I mean this violates the safety property, violates the check I need to do. And therefore I am not going to insert I am not going to reserve a request for you. All right? So what is happened here is it is basically a sorted array, except that you added a bunch of pointers associated with the tree. And so it is somewhere between a sorted list and a sorted array. And it does exactly the right thing with respect to being able to insert. Once you have found the place to insert, it is merely attaching this particular new node with it is appropriate key to the pointer. All right? So what is happened here is that if h is the height of the tree then insertion with or without the check is done in order h time. And that is what BSTs are good for. People buy that? Any questions about how they k minute check proceeded? Yeah, question. So, what is it called? The what check? The k minute check. Sorry, the k was three minutes k. I had this thing over here, add t to the set R if no other landings are scheduled within k minutes. So k was just a number. I want it to be a parameter because it does not matter what k is. As long as you know what it is when you do the binary search, you can add that in to an argument to your insert, and do the check. OK. So in this case, I set k to be three out here. And I was doing a check to see that the invariant, any elements in the BST already, on any nodes that had keys that were within three minutes because I fixed k to be three to the actual time that I was trying to insert. All right? So there is no way. I am sorry, there is no way? There is no way you could insert the forty two into the tree then? Well, if the basic insertion method into a binary search tree does not have any constraints. But you can certainly augment the insertion method without changing the efficiency of the insertion method. So let is say that all you wanted to do was insert into a binary search tree, and it had nothing to do with the runway reservation. Then you would just insert the way I described to you. The beauty of the binary search tree is that while you are finding the place to insert, you can do these checks the k minute checks. Yeah, question back there. What about 45? What about 45? So this is after we have not inserted forty two because it violated the check. So when you do 45, then what happens is you see that forty five is less than forty nine and you pass, because you are more than three minutes away. We will stick with that example. And then you get here and then you see that forty five is less than 46, and you had fail right here. You would fail right here if you were doing the check, because forty five is not three away from forty six point All right? So that is the story. And so if you have h being the height of the tree, as you can see you are just following a path. And depending on what the height is you are going to do that many operations, times some constant factor. And so you can say that this is order h time. All right? Any other questions? Yeah, question back there. In a normal array. Well, it is up to you. In a conventional binary search tree, or the vanilla binary search tree, typically what you are doing is you are doing either find or insert. And so what that means is that you would just return the pointer associated with that element. So if you are looking for find 46, for example, on the tree that I have out there, typically forty six is just the key value. And there may be a record associated with it. And you would get a pointer to that record because it is already in there. At that point you can say I want to override. Or if you want, you could have duplicate values. You could have this, what is called a multiset. A multiset is a set that has duplicate elements. In that case, you would need a little more sophistication to differentiate between two elements that have the same key values. So you had have to call it 46a and 46b. And you had have to have some way of differentiating. Any other questions? Yeah. Would not it be a problem if the tree is not balanced? Ah, great question. Yes, stay tuned. So I was careful, right? I guess I kind of alluded to the fact that we had solved the runway reservation system. Did I actually say that we had solved the problem? Did I say we had solved the problem? OK, so I did not lie. I did not lie. I said that the height of the tree was h. And I said that this was accomplished in order h time, right? Which is not quite what I want, which is really your question. So we will get to that. So we are not quite done yet. But before we do that, it turns out that today is lecture is really part one of two. You will get a really good sense of BST operations in today is lecture. But there is going to be a few things that we ca not cover all of double six in the lecture, right? We had like to, and let you off for the entire fall, but that is not the way it works, all right? So it is a great question. I will answer it towards the end. I just wanted you to say a little bit about other operations. There is many operations that you can do on a binary search tree, that can be done in order h time, and some even in constant time. And I will put these in the notes. Some of these are fairly straightforward. Find min can be done in heap, in a min heap. If you want to find the minimum value, it is constant time. You just return the root. In the case of a binary search tree, how do you find the min? Someone? Worth a cushion. Yep. Keep going to the left? Keep going to the left. And how do you find the max? . Keep going to the right. All right great, thank you. And finally, what complexity is that? I sort gave it away, but I want to hear it from you. . Hm? It is the height It is the height, order h. All right, it is order h complexity. Go to the left until you hit a leaf, and until leaf order h complexity. Same thing for max. And then you can do a bunch of things. I will put these in the notes. You can find things like next larger x, which is the next largest value beyond x. And you look at the key for x and you say, for example, if you put forty six in there, what is the next thing that is larger and that? In this tree here, it is forty nine point But that is something which was trivially done in this example. But in general you can do this in order h time as well. And you can see the pseudocode. And we will probably cover that in section tomorrow. What I want to do today, for the rest of the time I have left, is actually talk about augmented binary search trees, which are things that can do more and have more data in them than just these pointers. And that is actually something which should give you a sense of the richness of the binary search tree structure, this notion of augmentation. And those of you, again, who have taken double 05, you know about design amendments. And so specifications never stay the same. I mean, you are working for someone, and they never really tell you what they want. They might, but they change their mind. So in this case, we are going to change our mind. And so we have done this to the extent that we can cover all of these in order h time. And let is say that now the problem specification changed on us. There is an additional requirement that we are asked to solve. And so you sort of committed to BST structures. But now we have an additional requirement. And the new requirement is that we be able to compute rank t. And rank t is how many planes are scheduled to land at times less than or equal to t. So perfectly reasonable question. It was not part of the original spec. You now have built your BST data structure, you thought you were done. Sorry, you are not. You have got to do this extra stuff. So that is the notion of augmentation, which we are going to use this is an example of how we are going to augment the BST structure. And oh, by the way, I do not want you to change the complexity from order h. And we eventually will get to order log n, but do not go change something that was logarithmic to linear. That would be bad. So let is talk about how you do this. And I do not think we need this anymore. So the first thing we need to do is add a little bit more information to the node structure. And what we are going to do is augment the BST structure. And we are going to add one little number associated with each node, that looks at the number of nodes below it. So in particular, let is say that I have 49, 46, let is just say 49, forty six for now. And over here I have 79, 64, and eighty three point I am going to modify I am going to have an extra number associated with each of these nodes. And I am just going to write that number on the outside of the node. And you can just imagine that now the key value has two numbers associated with it the thing that I write inside the node, and what I write outside of it. So in particular, when I do insert or delete I am going to be modifying these numbers. And these are size numbers. And what do I mean by that? Well these numbers correspond to subtree sizes. So the subtree size here is 1, 1, one point So as I am building this tree up I am going to create an augmented BST structure, and I have modified insert and delete so they do some extra work. So let is say, for argument is sake, that I have added this in sort of a bottom up fashion. And what I have are these particular subtree sizes. All of these should make sense. This has just a single node, same thing here. So this subtree sizes associated with these nodes are all one point The subtree size associated with seventy nine is 3, because you are counting seventy nine and sixty four and eighty three point And the subtree size associated with forty nine is 5, because you are counting everything underneath it. How did we get these numbers? Well you want to think about this as you started with an empty set, and you kept inserting into it. And you were doing a sequence of insert and delete operations. And if I explain to you how an insert operation modifies these numbers, that is pretty much all you need. And of course, analogously, for a delete operation. So what would happen for, let is say you wanted to insert 43? You would insert forty three at this point. And what you had do is you follow the insertion path just like you did before. But when you are following that path you are going to increment the nodes that you are seeing by one point So you are going to add forty three to this. And you had add five plus 1, because you see forty nine point And then you would go down and you had see forty six point And so you had add one to that. And then finally, you add forty three and you assign since it is a leaf you had assign to value corresponding to the subtree size of this new node that you put in there, to be one point It guess a little, teensy bit more complicated when you want to do the k minute check. But from a complexity standpoint, if you are not worried about constant factors, you can just say, you know what? I am going to first run the regular insert, ignoring the subtree sizes. And if it fails, I am done. Because I am not going to modify the BST, and I am done. I am not going to have to modify the subtree sizes. If it succeeds, then I am going to go in, and I know now that I can increment each of these nodes, because I know I am going to be successful. So that is sort of a trivial way of solving this problem, that from an asymptotic complexity standpoint gives you your order h augmented insert. That make sense? Now you could do something better than that. I mean, I would urge you, if you had wrote something that we asked you to write something like this, to create a single procedure that essentially uses a recursion appropriately to do the right thing in one pass through the BST. And we will talk about things like that as we go along in sections, and possibly in lectures. So that is the subtree insert delete. Everyone buy that? Yeah, question back there. If I wanted to delete a number, like let is say seventy nine Yep? would we have to take it out and then rewrite the entire BST? What you had have to do is a bubble up pointers. So you had have to actually have sixty four connected to what will happen is eighty three would actually come up, and you would essentially have some thing this is not quite how it works but eighty three would move up and you had have sixty four to the left. That is what would happened for delete in this case. So you would have to move pointers in the case of delete. And we are not done with binary search tree operations from a standpoint of teaching you about them. We will talk about them not just in today is lecture, but later as well. So there is one thing missing here, though, which is I have not quite figured out I have told you how these subtree sizes work. But it is not completely clear, this is the last thing we have to do, is how are you going to compute rank t from the subtree sizes? So everyone understand subtree sizes? It is just the number of nodes that are underneath you. And you remember to count yourself, all right? Now what is rank t? Rank t is how many planes are scheduled to land at times less than or equal to t. So now I have a BST structure that looks like the one and I just ended up with. So I have added this forty three point And so let me draw that out here, and see if we can answer this question. This is a subtle question. So I got 49, and that subtree size is six point I got 46, subtree size is two point 43, 79, sixty four point and eighty three point So what I want is what lands before t? And how do I do that? Give me an algorithm that would allow me to compute in order h time. I want to do this in order h time. What lands before t? Someone? Yeah. So first you would have to find where to insert it, like we did before. Right, right. And then because we have the order of whatever it was before not the order, the The sizes? The sizes? Yeah. And then we can look what is more than it on the right, we can subtract it and we get What is more than it on the right. Do you want to say Because, like OK. on the right Right. and then we can take this minus this and we get what is left. That is great, that is excellent. Excellent. So I am going to do it a little bit differently from what you described. I am going to actually do it in a, sort of, a more positive way, no offense intended. What we are going to do is we are going to add up the things that we want to add up. And what you have to do is walk your first step was right on. I mean, your answer is correct. I am just going to do it a little bit differently. You walk down the tree to find the desired time. This is just your search. We know how to do that. As you walk down you add in the nodes that is the subtree sizes you are just adding in the notes here. So if you see depending on the number of nodes that you see as you are going deeper in, you want to add in the nodes. And you are going to add one to that, corresponding to the nodes that are smaller. And we are going to add in the subtree sizes to the left, as opposed to subtracting. That may not make a lot of sense. But I guarantee you it will once we do an example. So what is going on here? I want to find a place to insert. I am not actually going to do the insert. Think of it is doing a lookup. And along the way, I need to figure out the less than operator. I want to find all of the things that are less than this value I am searching for. And so I have to do a bit of arithmetic. So let is say that I am looking for what is less than or equal to seventy nine point So t equals seventy nine point So I am going to look at forty nine point I am going to walk down, I am going to look at forty nine point And because I say I am looking at forty nine and forty nine is clearly less than seventy nine point So I am going to add one point And that is this check over here. I move on and what I need to do now is move to the right, because seventy nine is greater than forty nine point That is how my search would work. But because I have moved to the right, I am going to add the subtree sizes that were to the left. Because I know that all of the things to the left are clearly less than seventy nine point So I am going to add 2, corresponding to a subtree forty six point So I am not actually looking there. But I am going to add all of that stuff in. I am going to move to the right, and now I am going to see seventy nine point At this point seventy nine is less than or equal to seventy nine point So I am going to see seventy nine and I am going to add one point And because I have added 79, just like I did with 49, I have to add the subtree size to the left of seventy nine point So the final addition is I add one corresponding to the subtree sixty four point And at this point I have discovered where I have to insert, I have essentially found the location, it matches seventy nine point And there was no modification required in this algorithm. So if that was seventy eight you had essentially do the same things. But you are done because you found the value, or the place that you want to insert. And you have done a bunch of additions. And you go look at add 1, add 2, add 1, add 1, and you have five point And that is the correct answer, as you can see from this example. So what is the bad news? The bad news was what this lady said up front, which was we have not quite solved the problem. Because sadly, I could easily set things up such that the height h is order n, h could be order n. And if, for example, I gave you a sorted list, and I said insert into binary search tree that is originally null 43, and you put forty three in there. Then I say insert forty six point And then I say instead of forty eight point And then I say insert 49, et cetera. And, you know, these could be any numbers. Then you see that what does this look like? Does it look like a tree? It looks like a list. That is the bad news. And I will let Eric give you good news next week. We need to have this notion of balanced binary search trees. So everything I have said is true. I did not lie. But the one extra thing is we need to make sure these trees are balanced so h is order log n. And then everything I said works. All right? See you next time. 
</body>
</html>