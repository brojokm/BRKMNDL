<html>
<body>
I hope you are all recovered from the quiz. Our apologies for hard questions, but it is just the first quiz. We have a lot more fun things to do in six point So today is lecture today is lecture is a light lecture, I would even call it a recreational mathematics lecture. And so, thanks for coming. I will make it worth your while, all right? So we are going to talk about irrationals. The motivation behind this is really that every once in awhile we are going to have a situation where we want to compute with numbers that are much longer than sixty four bits, which is really the word length in standard computer these days. It used to be eight bits back in the day. For most of my adult life it was thirty two bits. And recently Intel and AMD have gone to 64 bit processors. But sixty four bits ai not near enough if you want to do what is called high precision computation, you want to find precisely the weight of a neutrino, if you are a physicist, for example. And that, you are talking about literally a hundred decimal digits, which is obviously much more than sixty four bits. And that is just one example. So what happens if you want to compute the square root of two to a million digits, or pi to ten million digits? How do you do that on a computer? So that is what we are going to do for this module, which is a short module on numerics. We will have a lecture today and another one on Tuesday telling you about techniques that use, among other things, Newton is method to compute irrational numbers, as one example, to arbitrary precision And for your problem set you are you going to look at different application that corresponds to encryption, RSA encryption, where you have to work with primes. These are now integers, but you work with primes that are thousands of bits long, so again, much more than sixty four bits. And so you have to think about how you are going to multiply numbers that are thousands of bits long, how you are going to divide numbers that are thousands of bits long, and that is really the purpose of this module. So let is start off by talking about irrationals. And Pythagoras, whom I am sure you have all heard of is credited with the discovery that a square is diagonal and its side are incommensurable. So you ca not really express the ratio as a rational number, as a ratio of integers. Now it turns out that the Babylonians and the Indians knew this way before Pythagoras, but he gets credit for the Pythagoras theorem. And there is also a Greek philosopher, in fact, maybe he was first a philosopher and then a mathematician, and he the espoused a philosophy that, I guess, is called Pythagorean mysticism, that said that all is number, so the world is about numbers. And he worshipped numbers, his followers worshipped numbers. And the problem here was that he did not really like the square root of two because he could not express it as a number, of what he thought of as a number, which was 1, 2, 3, et cetera, integers, whole numbers. So he called this ratio speechless, something that he really could not explain. And irrationals were actually considered a threat to the mystics because they could not really explain what square root of two was. They had try and measure it, and they would come up with the right answer because the next time around it would be a little bit different If they did things a little more precisely, or not so precisely. And it bothered them no end. And so they tried to find patterns in irrationals because they considered them a threat. And they obviously did not find patterns, but imagine if we could actually find patterns. I mean, that would be a really big deal, it would be better than p equals np, if you know what I mean. If you do not it does not matter. So that is another of motivation for high precision arithmetic. Let is try and find patterns in irrationals if you go to millions and trillions of digits, maybe it is just a matter of time before we discover that there is no such thing as irrational numbers. Who knows? So let is do that for the rest of this lecture. Let is try and figure out how we are going to compute irrational numbers, or things like square root of 2, to arbitrary precision. So we can go play around, and we will give you some code, and you can play with it. So if you look at square root of two I will just put this up here so it is 1. 414, you probably all know that. Then it is 213,562,373,095,048 et cetera. I mean, I do not see a pattern there. I see a zero, a couple of zeroes here. It is hard to imagine you had probably want to think of a computer program that generates square root of 2, and then maybe a different computer program that is looking for patterns. So let is not worry about the square root of two point I want to digress a little bit. I did say this was a bit of a recreational mathematics lecture. And let is talk about something completely different, which are Catalan numbers. So these are really my favorite numbers in the world. And people like primes, some people like irrationals, I like Catalan numbers. Catalan numbers are they show up all over the place. How many of you know what Catalan numbers are? Oh good. Excellent. So Catalan numbers have a recursive definition. You can think of them as representing the cardinality of the set p of balanced parentheses strings. And we are going to recursively define these strings as follows. We are going to have lambda belonging to p where lambda is the empty string. And that is rule one. Rule two is if alpha and beta belong to p then I am going to put a paren, open paren, alpha, close paren, and then beta. And that belongs to p. So you iteratively or recursively apply this rule over and over, and you start getting strings that are balanced. So this is balanced. Now that is not balanced, this is not balanced, and so on and so forth. Obviously things get more complicated in terms of the parentheses if when you have more brackets or parentheses. And so, the nice thing about this definition is that you can get every non empty balanced paren string, via rule two, from a unique alpha, beta pair. So as an example, suppose you want to generate the string that looks like this So that is a little more complicated than the strings that we have looked at so far then you obtain that by having alpha be this simple string. And then you put the brackets around that, and then your beta corresponds to this. So now alpha and beta were previously generated, so if you applied rule two to the empty string, with alpha being the empty string and beta being the empty string, then you get this thing here. And obviously you could get beta by setting alpha to be the empty string and beta to be this string that you just generated, and so on and so forth. So you just keep going and the strings get longer and longer. The cardinality of the set gets bigger and bigger. And those of the Catalan numbers. OK And so, this is a non trivial question, which is I had like to enumerate the Catalan numbers, and compute, and get an analytical form for the cardinality of the set. And that is really what the Catalan number is. It is a cardinality of the set. And so cn is the number of balanced parentheses strings with exactly n pairs of parentheses. And I have c0 equals 1, which is my base case. And that is just setting it is an empty string. I am going to say that empty string is a string, and that is just setting up the base case. And now I want an equation for cn plus one point And I need to use the fact that I can get cn plus 1, a particular strain that belongs to this set, where I have n plus one parenthesis in a unique way from a string I have previously generated that was part of either the set that had n parentheses or it was combined using strings, where alpha was in some set that was maybe generated awhile back with a small n, or something significantly smaller than n, and another thing that was generated, beta, that was generated later, or maybe at the same time, et cetera. So can someone tell me what an equation would be for cn plus one based on the cis that are less than n? So what about c1? Maybe I will ask what about c1? What is c1? one point c1 is one because all I have is this string, that is the only balanced string. Now I have c0 and c1. What is an equation for c2 in terms of numbers. I want a number for c2 based on c0 and c1. Someone? Yeah. C0 plus c1. c0 plus c1? No, not quite right. How many strings do I have? c0 plus c1. Yeah, actually you are right. Well, the number is right but the equation is wrong. It is not quite that. You get a Yup. So when something like c c1 times c1 plus c1. c1 times c1 plus c1? Yeah. I think you want to use a c0. OK. c0. c0 Well, that is not quite right either. Someone else. Yeah. OK. You. c0 times c1 plus c1. c0 times c1 c2 would be c0 times c1 plus c1 times c0. OK. And if you are setting the alpha So here is the thing, you set the alpha, and you choose the alpha, and then you choose the beta. And there is a couple of different ways that you could choose the alpha. You could choose the alpha from you could make it a string that is empty, or you could make it the one string that you have generated so far, which is the standard simple string, the non empty, the non trivial balanced string. And you could do that in a couple different ways with alpha. And that is why you have two terms over there. So the number, in terms of all of the equations I got, they all came out to be the same. It is 2, and that is correct. But this is the equation for it. And so now, tell me what a general equation is for cn plus one based on what we have learned so far for the c2 equation? Yeah, back to you. So c0 times cn plus c1 times cn minus one all the way to cn times. Perfect. Good. That deserves a cushion. That was not me, it was you. And put it right there, breadbasket. So cn plus one equals sigma, so you give me a summation, k equals zero through n, ck, cn minus k where n is greater than or equal to zero point And you can figure this out, it is not particularly important as to exactly why this is true. You can think about it offline. But the interesting thing is that this is a generator of, obviously, and it is going to give you a nice looking set of numbers. And I came in early and wrote that the Catalan in numbers up on the board going from c0, c1, c2, et cetera, just in case just in case you ever see these numbers in real life, or when you are writing computer programs. Or you are driving on the road, the next time you see a license plate 4862, turn around and tell your mom or dad, hey, that is the Catalan number. And maybe she will be impressed. This, of course, you are not going to see on a license plate, but you can always make up a bumper sticker or something, and you can have the c17 as being a bumper sticker on your car. I mean, that is the kind of thing that I had do. Anyway, so it is just in case you see these numbers we might come back to this a little bit later in the class, but forty two is on that list. forty two is on that list. Yeah, it has to be. forty two is on every list. forty two is the answer to every question. I am glad you guys did not put forty two down in the answer to every quiz question. It does not quite work all the time, all right, but most of the time forty two is a good answer. Most of the time. OK good. So let is get down to business. So we talked about Catalan numbers as a digression. If you see them you will recognize them, I think. Let is talk about how we could compute. Let is go back to irrationals and talk about how we could compute square root of two and other things to arbitrary precision. So what I want to do is to talk about Newton is method. And Newton is method is something you probably learned about in middle school, high school. And let is say you have a function y equals f of x where this is x and that is y, the coordinate axes. And we want to try and find the root of fx equals zero through successive approximation. For example, we might have f of x equals x squared minus a. And if a is two then you are trying to use Newton is method to find the root, and you are going to end up trying to compute square root of two or plus minus square root of 2, in this case. But you can go for a particular root, and you are try and converge to that. So the way Newton is method works is it tries, geometrically speaking, it tries to find tangents and a different color chalk would be useful here but I do not seem to see one So what would happen is, let is say you are sitting out here, and it is successive approximation method, so this would give you x of i. And now you want to compute x of i plus one point And what you are going to do is draw a tangent, like so, and find the intercept onto the x axis, the x intercept. And that is going to be your xi plus one point And you have to write an equation for that tangent. And this is, I guess, trying to figure out how much of middle school math or high school math that you remember. What is the equation for that tangent? Anybody? The equation for that tangent? What do you do in order to compute that tangent? Give me a name. Derivative? Derivative. Thank you. So what is the equation for that tangent? y equals Someone?  It is a good think your middle school, high school teachers are not here. Not you. You already got a cushion. Someone else. Someone else. All right. I will start giving you some hints here. f of xi plus plus ALL f prime. f prime xi. Thank you. Thank you. All right. You get a cushion. I am getting them. Whatever it takes. Here you go. Yeah. That was left handed, by the way. I am actually right handed, as you know. So what do we have here? So we have f prime xi. Now come on, let is finish it, finish it. Times i minus xi. Times xi is xi. Thank you. OK. So now I get it. You thought this was too simple a question. You guys were insulted by the question. So that is why you did not tell me what it was At least, that is what I am going to pretend to make myself feel better. So y equals f of xi plus f prime xi, which is the derivative of f evaluated at xi times x minus xi, that is the equation for the line. And that is essentially what we have to do to compute things like square root of 2, which is iteratively applied Newton is method. The only problem is this is all good in theory that we can do take that equation turn it into xi plus one equals xi minus f of xi divided by f prime of xi. And if you end up doing f of x equals x squared minus a, then you have xi plus one equals xi minus xi squared minus a divided by 2xi, which is the derivative of x squared minus a evaluated at xi. And finally you get this equation, xi plus a divided by xi divided by two point So it is fairly straightforward. xi plus one equals xi plus a divided by xi divided by two point And if you look at this, remember that a is typically a small number. I mean, it is two, in this case, if you are computing square root of two point it may even be an integer, maybe a fraction. But you have to do a division here. And remember that since we want to compute things to millions of digits, potentially, these numbers, the xi numbers, are going to have millions of digits. And so if you end up running this Newton method on a equals 2, then if I simulate what happens without worrying about the implementation, and this is what you will get. You have x0 you start with x0 equals one with a bunch of zeros. xi equals one point five with a bunch of zeros, et cetera. And then, x2 equals one point four one six six six et cetera. That goes on. And we are not talking about fractions here, we are talking about floating point numbers that are integers with a certain amount of precision. So you have decided that you want to compute this to d digits of precision where d may be a million. And so, really, here you would have a representation that is a million digits long that where, basically, everything is zero, and here everything but one is 0, or maybe a couple if you count the one here. And here you have all these sixes here, and so on and so forth. And you keep going, and you get x2 equals 1. 414215686. And I want to write one more because I want to point out something that is important. 1. 414213562. And what is nice about this, if you go compare it with what you have up there, is that you have quadratic convergence using the Newton is method. And what do I mean by that? Well, quadratic convergence is a nice property. It is much better than linear convergence. Linear convergence would mean that you get an extra digit of precision for every iteration. So in this case, actually, a quadratic is better. Usually we think of quadratic algorithms, and we are going to throw up. But linear algorithms is what we like. But in this case it is actually a good thing. You have this extended this quadratic rate of convergence where the number of digits that are correct doubles with every iteration, as you can see. So here you have you start with, roughly, if you rounded this up you would get five point So you are saying that that is one digit of precision in terms of the decimal. And then, now you are talking about 41421356, so that is 1, 2, 3, 4, 5, 6, 7, 8, so that is eight digits of precision here, four here, and so on and so forth. So that is nice. That is why the Newton is method is actually used in practice because the number of digits doubles. This is a precision. So now you do not get too scared about calculating things that are a million because you kind of go and say, whoa, I mean, that is not so bad, that is only a logarithmic number of integrations. And it is not like you have to run for a million iterations. You go 2, 4, 8, 16, and now that exponential helps you, the geometric series helps you. So that is the nice thing about the Newton is method. Have not quite told you how we are going to compute the most important thing here with respect to a divided by xi. So this is just additions. You can imagine that if you have long numbers you had end up doing addition fairly straightforwardly because you only have to worry about one carry, and so you go off. And I am sure you have added up numbers that are in tens, if not hundreds, of digits long but I am guessing you have not manually multiplied numbers that are hundreds of digits long. And if you have I had be impressed, though I wo not believe your result. But that is something that is kind of a painful thing to do. And so that is why we need computers. And that is multiplication and has anybody divided a hundred digit number by another 50 digit number? No. So you need computers. So we have got to be able to do that division there, a divided by xi, using computers. And so that is really the purpose of this and the next lecture If you are only going to do a high precision multiplication here. And try see what an algorithm would be for high precision multiplication because what we are going to do is, essentially, take the reciprocal of one over xi and then multiply that by a. And we need division is going to require multiplication. You do not really see a multiplication there other than a times one over xi. And you can say, well, do we really need multiplication? Well, the answer is the division algorithm that is used in practice in most division algorithms have multiplication as a subroutine. So we are going to have to figure out high precision multiplication first It is a little bit easier than division and use it as a subroutine for high precision division, which we will do next time. So now we are sort of back in six land, if you will. We have a problem that is high precision multiplication, and we want to find an algorithm for it. And there is the vanilla algorithm that is going to take certain amounts of time, asymptotically speaking, and then there is better and better algorithms. As you can imagine, multiplication is just such a fundamental operation that people have looked at trying to reduce the complexity of high precision multiplication. So if you have n bits So what is the standard algorithm for multiplication take if you have n bits of precision? N squared. n squared. But you can do better. And the people are work on it. You can do fast Fourier transforms. We wo not quite do that here. If you take six point zero four six you will probably learn about that. But we will do a couple of algorithms that are better than the order n squared method, and we will do one of those today. So the way they are going to work with integers one little point that I need to make before we move ahead here is, generally, we going to say, for the purposes of 006, that we know the digits of precision up front because we want d digits of precision, maybe it is 42, maybe it is one hundred and twenty five point In the case of our problem set in RSA we going to have it 1,024 bit numbers, maybe 2,048. So we know d beforehand. And so what we want is an integer, which is ten raised to d times the square root of 2, a floor, and which is essentially the same as that, two times ten raised to two d. So we are going to treat these as integers, so we do not want to worry about decimal points and things like that. All of these things are going to be integers. And there is no problem here. We can still use Newton is method. It just works on integers. And let is take a look at how we would apply Newton is method in standard form. And we wo not to really get to the part where we are going to go from division to multiplication today, as I said, we are just going to look at how you can multiply two numbers. So I did not mean to say that we are going to look at Newton is method. We are going to look at high precision multiplication, and then, eventually, we are going to use that to build Newton is method which requires the division. So I have two n digit numbers, and the radix could be the base could be 2, ten point Normally, it does not really matter. zero less than x, less than y, strictly less than r raised to n. That is standard for the ranges. And what I have here is the way I am going to do this is use our favorite strategy, which is divide and conquer, because I have n, which is large, need to break things down, break it into n by two digit multiplications. And when, finally, I break things down, I get down to sixty four bits, I just run one instruction on my computer to multiply the 64 bit numbers. And the standard machines, you would get one hundred and twenty eight bits of result back when you multiply 64 bit numbers. So in some sense you only go down you do not go down to one bit, you go down to sixty four and your machine does the rest. So what we have here is you set x to be x1 where x1 is the high half, r raised to n over two plus x0. So x1 is the more significant half and x0 is the low half. And the same thing for y. y1, whoops, r raised to n over two plus y0. Now the ranges change. x0 and x1 are smaller, so that is what you have for x0 and x1. Same thing for y0 and y1. So that is a fairly straightforward decomposition of this multiplication operation. And again, if you do things in a straightforward way you will create a recursive multiply, as I will write here. And what you do is you say let z0 equal x0 times y0, z two equals x2 times y2, and I missed z1, but z1 equals x0, y1 plus x1 y0. And I have, overall, z equals y equals x1 y1 times r raised to n plus x0 y1 plus x1 y0 times r raised to n over two plus x0 y0 zero. And this part here was z0, this part here was z1, and this part here was z2. And if you look at, it you need four multiplies, 1, 2, 3, four point And you need four multiplies of n by two n by two digit numbers. And by now, after you have prepared for quiz two, I will just say that it would take theta n square time because you are recursive equation is tn equals 4t of n over two plus the linear time that you take for addition. So this is tn equals 4t of n over two plus theta n. And you are assuming that the additions here take linear time. So that is how you get your theta n square algorithm. And we are not happy with that. We had like to do better. And so how do you do better? Well, there is many ways of doing better. The simplest way off fairly, substantially lowering the complexity is due to a gentleman by the name of Karatsuba. This is one of those things where if you were born early enough you get your name on an algorithm. And what happens here is, using the z is that I have out there, you essentially say, look, I know z0 equals x0 and y0, I am going to go ahead and multiply. z2 equals x2 and y2, go ahead and do that. And now I am going to write z1 as x0 plus x1 times y0 plus y1 minus z0 minus z2. So you are actually computing z0 and z2 first, and then using them to compute z1. So someone tell me why this is interesting? And just take it all the way to the complexity of an algorithm. Explain to me why this is interesting and why Karatsuba is algorithm has I will give it away a lower complexity than theta n square? But tell me what it is. Someone? Someone other than you. Someone way at the back. Yup. Out there. It is n to the log base two of three point n raised to Log base two log base two of three point That is exactly right. And now, why did you get that? Explain to me how you got there. If you are using three products That is right. So first insight is that we are only doing three multiplications here. Additions are easy. And we are doing three multiplications as opposed to four. So tell me how that equation changed, of tn. tn equals three. three times t of n over two plus theta n because you are doing three multiplications rather than four. Multiplications are the complicated operation. Divisions are even more complicated, but additions are easy, and you could do those in linear time for n digit numbers. And so, if you do that and then you go off and you say, well, that tells us that tn equals theta of n raised to log two of three, which is, by the way, theta of n raised to 1. 58, roughly speaking. And I do not want to compute that to arbitrary precision, though I could. But that goes on and on. Why do not you grab this after you are done. But that just goes on and on. one point five eight is a rough approximation. That is an irrational number too, assuming you think that irrational numbers exist. That is an irrational number. So good, that is really all I had. By the way, it is 1. 58490625. I really should have written that down. one point five eight in the context of this lecture I think it is important that we get at least a few digits a precision. Now you can imagine that you could do it better than this. And it turns out that we will talk a little bit about this next time But you can imagine breaking this up into not n over two chunks, but n over three chunks. Why do not I just break up x into the top third, the middle third, and then the bottom third, and then try and see if I can get away with fewer than eight multiplications? Because the original thing would have taken eight, and if I can do less than eight, maybe I can reduce that one point five eight number. So that is a little bit of a preview for what we will do next time. But what I had like to do is do a demo. And I want you to run that it is out there so blank that out for a second. What I had like to do is really look at a different problem than square root of 2, and show you a demo of code that Victor wrote that computes this particular quantity that, you would argue, is irrational, to arbitrary digits. Though we will probably only go up to about a thousand today. And if we just look at root two is kind of boring, right? It is been around for a while. Let is go back and remember high school geometry. So I think your high school teachers would like this lecture. Nice little review. So what is that about? That is supposed to be a circle, I think, as you have forgotten. That is supposed to be a circle. And the circle here is a really big circle. It is a trillion units long. I am into big numbers today, big numbers. And the center of the circle is c, c for center. That is what is called a radius, in case you had forgotten. And that is b. And this is also a radius, and that is a. And what I am going to do is I am going I want to make a drop a little, I guess, perpendicular down, which is one unit high. So the way that this is structured is that this is one unit high, this obviously is someone tell me what that is, CB. . Half a trillion. That is half a trillion. And obviously, CA is half a trillion. And if I call this D, somebody who remembers high school or middle school geometry give me an equation for AD. And that is definitely worth a cushion. so what is an equation for AD guys? Yeah. Go ahead. The radius, half trillion minus the square root of Square root of Yeah? Minus the square root of square minus 1? Perfect, perfect. OK good. So AD equals AC minus CD, and that is going to be half a trillion that is five hundred billion, a little bit less than bailout money, but it is close five hundred thousand minus square root of five hundred this, when you start squaring this, of course, is not even real, real big money. But five hundred thousand squared minus one point So forget the square root of two. You can put the screen down. So is it on, the projector? It is on, it just needs a. OK. You can turn that on. Rolling. So what we are going to do is, I am just going to show you the digits of this crazy quantity being computed to tens of thousands of digits. And you argue that this is it something clearly that is not a perfect square. You took a perfect square, subtracted one from it, and so you have an irrational quantity that is going to go on and on. And let is see what that number what it looks like. OK? Get out of the way. I hope you can see from the back. Oh man, really? Looking pretty good so far, looking pretty good. That is crazy. Somebody see the numbers somewhere else? Have you see these numbers before? Like twenty minutes ago, like right in front of you? OK All right. So I think that is a good place to stop. If you want an explanation for this I think you can go to section tomorrow. I am going to use a some attendance tomorrow. All right. Happy to answer questions about the rest of the lecture, and thanks for coming. 
</body>
</html>