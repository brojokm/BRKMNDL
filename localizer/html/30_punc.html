<html>
<body>
VICTOR COSTAN Any questions about the sorting methods that you want me to go over in that while I revise? OK. All right, sorting. What sorting methods have we learned? Let is start from dumbest to smartest. Merge sorting. VICTOR COSTAN OK, somewhere in the middle. Merge sort is not very bad. What is the easiest method to sort? Insertion. VICTOR COSTAN Insertion sort. Excellent. All right. What else? Heapsort. And? I gave two away now. Counting. VICTOR COSTAN Counting sort. Very good. And? Oh, wow. If you do not even have the name of it. So the last one is radix sort. What are the running times for these three that you guys remember? Insertion sort is linearly one more. It is bad. VICTOR COSTAN I want to see our pseudocode for insertion sorts. n squared. Now that is really bad. VICTOR COSTAN So linear is as good as you could possibly get. So sorting takes an array of random stuff and outputs an array of things in a sorted order. The array is size n, so it has to output an array of size n. If you can do an algorithm that runs in order n time, then that is the best you could possibly accomplish, because you have output n elements. So the best possible time you could get for sorting is theta of n. All right. How about merge sort? . VICTOR COSTAN Thank you. Heapsort. Order h. Order h is log n. VICTOR COSTAN Order h where h is log n. OK. And you are missing a factor. So a heap operation takes order h, which is log n. So if I have to insert a numbering in a heap or extract a number from a heap, that is log n. In order to start an array, how many insertions do I do? I think now I do not know. VICTOR COSTAN OK. Wild guess. n. VICTOR COSTAN Very good. See, there you go. So you need to insert all your numbers in a heap and then extract them one by one. And you will get them in the correct order that gives you the sorted results. So n log n. Does anyone remember what is special about these three sorting methods that does not apply to the other two? They are in place. VICTOR COSTAN Merge sort is not quite in place. If it would be in place, it would be perfect. There is actually a way of making in place merge sort, but it requires a PhD degree to understand that. So we will not cover it in 6006, because I do not understand it. So I could not explain it. So merge sort is not quite in place. Which one is in place? Heapsort. VICTOR COSTAN Good. So heapsort is in place. Merge sort is not in place. And insertion sort is really slow, so we do not care that much about it. So what is special about these three that does not apply to these two? You do not have to use integers. VICTOR COSTAN OK. You do not have to use integers. What do they want to know instead about the things you use? So we will call them keys. You need to be able to compare them. VICTOR COSTAN All right. You do not need to have a minimum and a maximum integer. VICTOR COSTAN So turns out, if you have a comparison operator, you will have a minimum and a maximum. But that is complex abstract algebra that we do not need to worry about. So you gave me the good answer, which is we use something called a comparison model. And in that model, you do not need to know too much about your keys. So the elements in the area that you are sorting. Your keys are blobs. And all they have to be able to do is know if you have two of them you have to know which one is greater. That is it. Nothing else. What is the problem with the comparison model? It takes time to compare things. It is like with everything. VICTOR COSTAN Yeah. So we learned in lecture that there is a lower bound for the comparison model. And if you want to sort using nothing but this information, that will take you at least n log n time. You cannot do better than n log n if all you are using is comparisons. So in that respect, merge sort and heap sort are optimal. If you want to stay within this model, this is the best time you are going to get. Does anyone know how you can implement this comparison model in Python? So numbers respond to these operators, right? Actually, in Python this is equals equals. What if I have a random object and I want to make it respond to these operators? So for example, I write merge sort. We wrote merge sort. And now I have my own objects, my own keys which are not necessarily integers, because that is why we like this. And we want to make them respond to these operators. So I can call merge sort on an array of them and it will crash. What do I have to do? I mean, you have to give the keys values that can be compared. VICTOR COSTAN So suppose this is my key class. This is lad, the lt, and gt. VICTOR COSTAN All right. There is a magical method in Python. So there is the old school model, which you might see in legacy code, which only works in Python 2. x, which is you define the method called cmp that takes self and other. And it has to return a number that is either smaller than zero, equal to zero, or greater than zero. And this maps to this. So you will see this in old code. But you should not use it in new code. On this, you have a very good reason to. Instead, the new model says that you define special methods called lt, which stands for less than. So it is this guy. le, which is less or equal. gt, which is greater than. And ge, which is greater or equal. And if you look at our code for pieces two and three, we have some objects that pretend they are keys. And we have to define these methods. Also, when you define these, it is a good idea to define eq for equality comparison. And ne, which is this guy. So these also take self and other key that you are comparing with. And they return true or false. So this will help you understand the code better. All right, so with relatively little work, you can have any wild object you want act as a key. And then you have insertion sort, merge sort, heapsort, heaps, binary trees, AVLs. Everything works, because everything uses the comparison model. The problem is this n log n bound. It is not as fast as the best possible sorting algorithm you could come up with. This is slower than this. So that is why we have to break out of the comparison model. And we have to look into these boxes and get more information, so that we can write faster sorting algorithms. Does anyone remember the running time for counting sort? again? VICTOR COSTAN OK. n plus e. VICTOR COSTAN OK. Let is remember how counting sort looks like. Let is get this array that that should be enough four, one, three, two, three. How do we sort it using counting sort? We initialize an array of all the possible values. VICTOR COSTAN Very good. Very good. So counting sort needs to know something about your values, right? It makes an assumption. And the assumption is that these values are integers from zero to, say, k minus one point So you have k possible values. And they do not really have to be these as long as you can map them to these numbers. So we are going to initialize an array. Let is say this is an array. And zero, one. So zero, one, two, three, four, five. So we are going to initialize it with Oh, zeroes. VICTOR COSTAN All right. And then? Iterative over our list sort incrementing the corresponding value to each key in your VICTOR COSTAN So which one am I incrementing here? Pardon? VICTOR COSTAN Which one am I incrementing here? Zero ne through four. One. VICTOR COSTAN Three, two. And then? Three n. So this becomes a two. And what do I do now? Reiterate over that I do not know. I do not know what to call that identity almost? OK, an array. Printing into your output array one one, one two, two threes, one four. VICTOR COSTAN All right. So there is no zeroes and now fives. So one one, one two, one three, and one four. OK, so far so good. This is great. There is one thing that is missing. For counting sort and for other sorting algorithms, we care about the property called stability. And stability means that if you have two equal keys, or at least two keys that look equal to the sorting algorithm, they might be different objects, because they might be implementing that. The one that shows up first in the input should also show up first in the output. And that requires particular care, because you ca not just look at the keys from your sorting perspective and know which one is supposed to go where. You have to remember where they were in the input. So if this guy is 3a, and this guy is 3b, I ca not use this approach anymore, right? Because when I am outputting here, all I know is I have to output a three. I do not have any other information associated with the key. So instead, I have to do something smarter. Either replace your array with a 2 D array. Or I think better would be to replace each value with a length list. VICTOR COSTAN OK. So we can replace each value with a length list, which would have the keys that map to it, right. So here I would have a one. Here I would have a two. Here I would have 3a, and then 3b. and here I would have a four. So then I can go through these and output them the right way. OK, now suppose I am writing this in C. Suppose I am in a low level language. And I am in a low level language because I am hired by one of these startups that are doing NoSQL databases. And they are writing everything in C to make their things really fast. So I am writing an index that uses counting sort. I do not have length lists, because if I am writing in C, I have to write my own. And that is hard. So I want to implement this in another way. Length lists are hard. What would I do instead? Can anyone think of another way? I think you can decrement the values for the C in the array that you have, where you have to type the culture of each anyway. VICTOR COSTAN OK, so you have the right idea. You are missing one step. So I will give everyone else a hint so that everyone can catch up. So what I want to do is I want to take this and transform it into something that allows me to go through the keys. So I know I have five keys here. I am going to make an output array of five elements. And I want to be able to see four and know that it belongs here. See one, know that it belongs here. See 3a, know that it belongs here. Then probably update the value associated with three. See two, know that it belongs here. And then when I see 3b, know that it belongs here. So I want to look, when I get to 3a, I want to look inside here. And I want this to tell me that three belongs here, 3a belongs here. So what would the position of 3a be? That is not good, right? Let is call this c instead so that I can say 3a be. So how would I define the position using the sorted property? 3a should go in the index that is how many keys smaller than three there are. So if I can look through here and see how many keys do I have that are smaller than 3, this is where 3a needs to go. If I look at four, there are four keys that are smaller than four. So it needs to go in position four. Well, that almost seems more like a compare. I am guessing that makes it I think it is kind of a comparison model. But you are saying is it greater than. So it is not really counting sort anymore as much. VICTOR COSTAN Well, I am telling you I can compute that using this. So I can use the counting sort algorithm and change this array a little bit so that I can do this trick and know what goes where. You already mentioned using a 2 D array. VICTOR COSTAN But a 2 D array would be too much. In the end, I will be changing this in place. So no extra space except for this array of size k. But let is not worry about changing it in place right now. Let is say we are going to make another array of size k. So I want it to tell me that I guess I do not care about this but I want it to tell me that one, the first one should go here, the first two should go here, the first three should go here, the first four should go here. How do I do that? Well, you could make that array, right. VICTOR COSTAN But how do I compute it? While you are making this one, you can start filling that one in. But while you are making the top one. VICTOR COSTAN Can I? It would be like insertion sort though, kind of. So you come across the four. You put it in there, because you know how many there are. But that does not make a lot of sense. VICTOR COSTAN Yeah, OK. So let is abandon that route. Let is think of something else. Could you populate the array with the number of elements that are less than that? VICTOR COSTAN So intuitively, I want this to tell me how many elements there are that are smaller than two. This should tell me the number of elements there are that are smaller than three, so on and so forth. OK, how would I compute that? Let is see what it is supposed to be. Let is fill it out with real values. Zero. VICTOR COSTAN Zero. How many elements smaller than one? Zero. VICTOR COSTAN How many elements smaller than two? One. VICTOR COSTAN How many elements smaller than three? Two. It is a cumulative sum. VICTOR COSTAN OK. On the array above. VICTOR COSTAN So this is how many elements smaller than four? Or how many elements smaller than five 4? OK. what is the difference between these two guys? One. VICTOR COSTAN What is the difference between these two guys? One. VICTOR COSTAN Yeah, you are right. Sorry. Thank you. What is the difference between these two guys? Two. One. VICTOR COSTAN And what is the difference between these two guys? Zero. VICTOR COSTAN OK, What did I just write here? Same series up there. Array. VICTOR COSTAN All right. So this guy is zero, right, because there is no element that there is nothing that is smaller to the smallest key. And then this guy is whatever was here plus this almost. So the difference between this guy and this guy is this. So why go through an array? I mean, why did you bother? Why do we make a new array? Because we could just get that information. VICTOR COSTAN Making a new array so that we can see how to compute it. So now we are going to try to right pseudocode that does this in place. So suppose this array is a and this array is pass for position. And suppose sorry, not this array. This array is a. This array is pass. And I start with this. And I want to end up with this. So let is try to write the pseudocode for counting sort. Counting sort with an array a. I am not going to write the first two lines that produce this. Let is transform this to this. How would I do that? Initialize an array of the same size. VICTOR COSTAN OK. Can we try to do it in place? Sure. VICTOR COSTAN How do we do it in place? You could, well for four, you get the four. You are like, oh, I have not encountered anything below me. So you put it in zero initially for four. And then you get a one. And you are like, oh, I have not gotten anything below me. But I forget to keep track of the fact that you have to iterate a whole list ever single time you get a new input. VICTOR COSTAN So I do not want to do that, because that is n squared. What you need to do is keep a running sum. Is it a register? Is that what you do call it? VICTOR COSTAN Running sum. I like running sum. OK. Keep a running sum of VICTOR COSTAN Sums always start at zero, right? Right. So you keep zero at you take the value in each index of that array and add it to sum. VICTOR COSTAN OK. So for i iterating from zero to so you want each value in this array, right? Yes. VICTOR COSTAN So it is going to iterate from zero to what? How many elements do I have there? Length k. VICTOR COSTAN OK, almost. So we are using Python numbering, which is zero base indexing. The indices look like this. So it is zero to . VICTOR COSTAN Very good. Thank you. And you said I am going to add the elements to a sum. So sum is sum plus position of i. OK. And then? The replace is the. So zero should be zero still. One should be the sum after evaluating zero. You will need a temp variable. VICTOR COSTAN OK. You will need to graph position i when in temp. VICTOR COSTAN Temp is position i. Then say position i is sum before incremental sums. No. That is not it at all. VICTOR COSTAN Really? We will have to say that sum is sum plus temp. That is going to work. VICTOR COSTAN OK. How does everyone else feel about this? Does it make sense? Not really. temporary blast previous adjuration, because so when you first started, it is the very initial case that does not work. So like, if you are in the first column, everything is fine. Then you go to column one. You are looking at everything to the left of it. It is still going to be zero. Then you go to the second column, but you already overwrote the previous column. So you need to store somehow the I do not know. It is just the initial case from when it first goes from zero to an actual qualified number. Because otherwise, you are just going to get like zero, zero, zero. And you just overwrite. Can you start? Was that before you changed? VICTOR COSTAN OK. Sorry, I am getting confused. This is getting hard. I will show you a trick to make life easier. I am going to put how many elements do I have here? Five, right? So I am going to put a five here after the array. And then I am going to ask you, what is this difference. Zero. VICTOR COSTAN OK. So now we have this whole array. Can people see what is going on here.? So instead of starting at the beginning, I am going to start at the end. And I am going to know I know for sure there are n elements. Therefore, the index of this guy is n minus so the index of the last key is n minus how many keys I have with this value. Does this make sense? But you are iterating over an order, right? So we ca not just take the whole thing and say we are going to shift it over to the right. VICTOR COSTAN How about And you are going through left to right. You will only know what you see thus far. VICTOR COSTAN How about going it for ai from n minus one to zero point Will it work then? So what would I write? But is not that super inefficient? Because then you are starting looking at the whole list. And then you are sort of, rather than just looking at the previous sum that you just the cumulative. So your first adjuration, you have to add up everything that you see. Like adjuration, you have to add everything up. VICTOR COSTAN So if I add everything up here, what is the result going to be? Five. VICTOR COSTAN OK. What is five? So this counts how many zero keys I have seen, how many one keys I have seen, how many two keys I have seen, so on and so forth. So in total So you are subtracting VICTOR COSTAN It is how many keys I have seen. All this, the sum of all these, is how many keys I have sent. How many keys do I have? Five. For each one you see, you can just VICTOR COSTAN So who is five? It is the length of this guy, right? And we usually call that n. So when we are doing sorting, this is n. So maybe it is less confusing. Oh, I already used n in two places. So I guess that is it. I could say the length of a, but there you go. So I could do the thing that we are going through before. I could figure out my temp variables. And I could make it work. Or I could do this. I think it is the same though, is not it? VICTOR COSTAN Yup. It is the same thing, except I think this is easier to write. Does anyone want to help me write this? Maybe doing once you are starting with the top array, and then finding the bottom one. VICTOR COSTAN Yeah. Oh, OK. Well, you just you start with the first one and the one ahead of it. And oh, I mean starting with the top right. Sorry. VICTOR COSTAN OK, so I have this. And then what do I do? ? Oh, so you are starting from the back. VICTOR COSTAN Yep. Well, then you just compare that to I mean, you are going to start with zero difference. If you have well you do not have any of those last keys, so you had be able to start with a zero. VICTOR COSTAN So what is the difference between five here, which is n, and this guy? What is this? It is going to be zero. VICTOR COSTAN But what is it? Why is it zero? So this one is zero, this one is one, this one is two. What is this? It is the last guy here, right? Yeah, yeah. VICTOR COSTAN So this is pass of n minus one point And this is pass of n minus 2, so on and so forth. So to get from n to the value here, I have to subtract this guy. Pass of i. VICTOR COSTAN Pass of i. . VICTOR COSTAN OK. Very good. And then update sum. Sum equals a pos value. VICTOR COSTAN Sweet. No temp variables, aside from this, I guess. How does this look like? Do people get it? You are subtracting positive i, or you are subtracting a of i. It is all one array. It is the same thing. That is right. VICTOR COSTAN So a is this array. a is the input array. And pass is this guy. And this is pass before the four loop. And this is pass after the four loop. So I guess this is pass zero. And this is pass one. And here, we start with pass zero. This, we end up with pass one. OK So we are able to compute this. There are many ways of doing this, but in the end, you want an array that looks like that. This is counting sort. This is the hard part of counting sort, coming up with that array. Once you come up with that array, you are golden. So let is see that we are golden and produce an output array with the keys in the right order. So say we have an array called output. And this is going to have these keys in the right order. What is the pseudocode for that? First, I am going to create a new array. And I am going to initialize it with n NIL values. Then what do I do? Iterate over a. VICTOR COSTAN Very good. For nah, it is too low. Let is do it here. i of a. From zero to n minus one point VICTOR COSTAN OK. What do I do? Out of has to be oh, can we modify pass one as we go? VICTOR COSTAN Yeah. So you could say, out of pos one VICTOR COSTAN So by the way, this is pos. The reason I label them with zero and one, so we are doing the change in place. Right. VICTOR COSTAN The reason I labeled them is to say that this is what pos is before we going into the loop. This is what pos is afterwards. But it is a single array. So let is call it pos. So out of pos of Pos of i equals a to the i. Positive i plus pos squared. VICTOR COSTAN Yup. And I am going to use the CLRS, the way which makes me write more. So how this work? I have the survey here. I start at four. What is pos of four? Four. VICTOR COSTAN All right, so I am going to write this as position four. I should probably make this a proper array. One two, three, four, five. So at four, I write four. And then I increment this guy to become five. Then I get to one. So I look at pos of One. VICTOR COSTAN And that is zero. So I am going to write one at position zero. And I am going to increment it. Then I get to 3a. I look at positive three point It says two point So I am going to write 3a here and increment this. Then I get to two. Pos of two is One. VICTOR COSTAN One. So I write two here. Pos of two becomes two. Then I have 3c, which is pos of three is now three point It is not two anymore. So yay, I am not overwriting 3a. That is good. And this becomes four. Are people getting what just happened here? Wait, why did not to just basically train the next array into an index binder? VICTOR COSTAN Yep. So this guy tells me if I have a key, where do I write it in here? So these start out with pointers to the first element that would store that key value. And when I store a key, say when I start 3a, when I get to 3c, I do not want to store it in the same place. So I have to increment that. I have to say, yo, I wrote 3a at position two. So next time, write it next time you see a three, right it at the position following that. And that is what this guy does. So this is the relatively easy part. And this is the hard magic in counting sort. So how are people feeling about it now? Any nods, or is still confusing as hell? It is a lot. I am confused. VICTOR COSTAN OK. Well what should we do? Do you guys want to ask more questions? Do you want to run through another example? Do you want to try to see how this becomes useful in radix sort, so that you are motivated to figure it out on your own? What would make more sense? All right. Who wants to do more count sort? Who wants to do some radix sort. All right. Radix sort it is. Next time you want to move on, tell me understood and I will believe you. And it will look good on tape. Two, three You are not supposed to tell us that there is a camera in here. VICTOR COSTAN One, four. I think you are supposed to know, because otherwise you do not know that we are violating your rights. Two, four This is out the door. VICTOR COSTAN One, two, four, three, two, one, four, three. And one more. One, two, three, four. So this is to refresh your memory. What do keys look like in merge and radix sort? So in concert, the keys have to be numbers from zero to k minus one point How about merge sort? What do keys look like? So radix sort says that a key is a sequence of digits. Say you have d digits in a key. But then each digit is not necessarily a base ten digit like we are used to. Each digit is in base k. So each digit can be from zero to k minus one point And we are using base k. How many keys can I represent this way? So if you have numbers of n digits in base k, what is the biggest number that we can represent, or how many numbers can we represent with that? n to the k. No, d to the k. Right? VICTOR COSTAN Almost. the d. VICTOR COSTAN All right. So if our base is two, like if we are using bits, then our base is two. And if I have eight bits, then two to the eight. Cool. So if I add one more digit, I get to multiply the number of keys I represent by k. How do I radix sort? Does anyone remember? We checked the log base k of everything. I guess log base d. Oh, k. It is based in VICTOR COSTAN No. That would be hard math. We do not do hard math. In sorting, if you have integers going into your sort, you only do integer operations. You do not do anything math beyond them. So what we do is we have broken up the keys into d digits for a reason. We are going to have d rounds in the sort. And in each round, we are going to take all the keys that we have. And we are going to sort them according to one of the digits. So in one round, we will sort them according to this digit. In one round, we will sort them according to this digit, this digit, this digit. Which digit do we start with? What do you guys think? To least significant digit, right? And most significant on the left. VICTOR COSTAN So this or this? The right side. one hundred is bigger than 1, even though the one is greater than the zero in one hundred point VICTOR COSTAN You are helping me out. So the point I am trying to make here is radix sort is unintuitive. If we ask you on a quiz what do you start with, your intuition will tell you to start with the most significant digit. Go against it. In radix sort, you start with the least significant digit and then move your way out. So radix sort goes like this. I mean, it does make sense, because you do not have very much information unless you are looking at bits. You can get a bunch of twos, but that does not give you much information. The most information is the smallest bit. And then you move up from there. VICTOR COSTAN It depends what information you are trying to get. But maybe you know the algorithm, so you are thinking, oh, by knowing the algorithm, I know that I will have the most information by looking at it this way. All right, so let is sort these by the last digit. Sweet. Let is sort them by the digit, by the digit before the last digit. What do I have to do in my sorting? What do I have to pay attention to? So the sorting method that I use has to have a property. It ca not be any kind of sorting. Stable. So the reason we went through all this pain in counting sort is because we want to have a stable sort here. Now, let is try to sort these in a stable manner. This is the first one, two, four, one, three. Then I have two threes, so one, four, three, two, one, two, three, four. And then I have three fours. Two, three, four, one. Two, four, one, three. Two, one, four, three. Way this is not good. Two, three, four, one. One, two, four, three. You should cross them off if you write them down. VICTOR COSTAN I should. I was hoping you guys would help me if I mess up. So now these are sorted stably. Let is look at these last three that have the same digit here. So they have the same four. If you look at the last digit, because I used a stable sorting, they are also sorted according to this last digit. So they are sorted according to these last two digits, because the sorting that I used is stable. So now if I sort according to this digit, then if my sorting is stable, they are going to be sorted according to the last three digits. So as I go from my last digit to my first digit, the keys are going to be sorted according to the last digit, the last two digits, the last three digits, and then all the way up to everything. This is why I need a stable sort. And also, this is why I need to start from the end. Does this make some sense? What stable sort did we just learn? Counting. VICTOR COSTAN Counting sort. All right. So we are going to use counting sort for this. What is the running time for one round? So for one sorting. One counting sort takes how much time? This is a radix sort. VICTOR COSTAN Yes. So radix sort is d rounds of counting sort. Count sort this, count sort this, count sort this, count sort this. So one round, one counting sort, what is the running time? . VICTOR COSTAN Thank you. Now how about d of these plus the running time? dn plus b. VICTOR COSTAN OK, but I want to come back here. And I want to be able to say that radix sort is optimal. I want to be able to say that it is order n. So what do I have to do in order to be able to say that? k equal to m. VICTOR COSTAN So you are going from you know the answer. You are going from the fact that you know the answer. . VICTOR COSTAN OK, very good. What if we would not know the answer? What do I need to do? Well, we know the first part is order n. So VICTOR COSTAN So d has to be We want dn to be greater than dk, right? VICTOR COSTAN Well, so dn. dn has to be, at most, o of n, right. Because otherwise, the whole thing would go above. So that would not work. So then what can I say about d? Constant. VICTOR COSTAN Very good. And how do you write constants in math mode? Order one. VICTOR COSTAN Very good. So d has to be order one. Otherwise, it is not going to come out to that. Now, what else do we know? We have this that is order n plus k. If I said this to be a lot smaller than k, if I set it to be log n, it is going to be order n. If I set it k to be a constant, if I use bits, if I use base two so I said k equal two this is still going to be order n. So if k goes way below n, this step is still going to be order n. So I might as well set k as high as possible. So k is order n, because that is the highest thing I could set it to. Now why do I want to do that? Yes, you have a ques represent in counting sort again? The length of what? VICTOR COSTAN So in counting sort, n is your input, how many keys you have. And k is the size of this array. Oh, OK. VICTOR COSTAN So you have to be able to map your keys from zero to k minus one point It is set by n, basically. Or it is set by the elements. VICTOR COSTAN Yeah. It is set by the nature of the keys. OK. Got it. VICTOR COSTAN So in real life, we are thinking maybe we have some huge numbers that we want to sort. And we are going to chunk them up into when we are writing on the board, we always have to chunk them up in base ten digits, because that is the only way we know how to write. But in a computer memory, we can chunk them up into, say, base 10,000 digits. And the fewer digits you have, the faster this is going to run. So we have to figure out what is the base. And it turns out that if you want to have radix sort run in order and time, well, the number of digits has to be sort of constant. I know that k should be order n, because I have no interest in making it lower than that. So these two bounds together tell me that the keys that I can sort are from zero up to order n of order one. And this looks terrible, but what it comes up to is that you can sort keys that look like n to some constant for any constant. So you can sort huge keys, as long as huge still means finite. And as long as you can figure out how to map them to numbers. Does this make some sense? Would we ever want to use merge sort instead of counting sort? Suppose we had a stable merge sort. Would we want to use that instead of counting sort here? What would happen? So suppose it is stable. So it is correct. The algorithm is not going to blow up. What is the running time for merge sort? So if I use a merge sort. So if I use the merge sort, it is going to be d times n log n. So no matter how small d is, I am still not running in linear time. So merge sort does not go well with radix sort. So from my end, we are pretty much done. We started with n log n. And we got to a sorting algorithm that is order n. We started at the beginning of, saying that the best thing we can do is omega is that omega omega of n. We got to that limit. We are happy. We are going to be done with sorting. Any questions from you guys? That means everyone is confused, right? Yes, thank you. Can you explain what the stability criteria is again? VICTOR COSTAN The Stability for these sorting algorithms. Which ones are stable and what makes it unstable? VICTOR COSTAN All right, very good. Thank you. So I like especially the last part, with which ones are stable. I had like to go through that. So a stable sorting algorithm means that if you have two keys that are equal, the key that shows up first in the input is the key that is produced to the output. So in this model, your keys are not necessarily integers. Your keys might be those weird classes that implement some method that maps them to integers. So say there is a method there, int, that gives you the integer for that. So the sorting algorithm would only see a three here. But in fact, this is a complex object. And this is another complex object, but the sorting only sees the three. If this guy shows up before this guy in the input, they have to show up in the same order in the output. Why would that be bad if they are switched? VICTOR COSTAN It is not stable. If they are switched, then when we are using a stable sorting algorithm here. So here, the key is this complicated object. But say we are in the second round. We are in this round, which we played with. Even though the key is this whole complicated object, the only thing that the counting sort sees is this number. So this guy looks like three. This guy looks like three. And these three guys, although they are different, they look like four. If I do not output them in the right order say I output this one all the way at the end then I am going to get two, three, four, one to be down here. And now my numbers are not sorted by the last two digits anymore. So it breaks any algorithm that assumes stability. So stability is something that you get from a sort, because it is convenient to assume it in some other algorithm that builds up on that sort. If you do not need it, you do not care about it. But in some cases, you need it. And for the second part, which algorithms are stable. Is insertion sort stable? I assume so. I mean, stable is being correct, right? VICTOR COSTAN No. We mean that property there. Oh, I see. You mean in order. VICTOR COSTAN Yep. Oh, OK. Insertion sort goes in order. But I guess it could push other things out of order. VICTOR COSTAN So insertion sort, you are doing swapping to move things to the left. But if you find two things that are equal, you are never going to swap them. So insertion sort is in order, is stable. Merge sort, the one we gave you in that list is not stable. But there is the one character change that makes it stable. And you should look at today is lecture notes to find out what that is. So merge sort can be stable. Heapsort, stable or unstable? Unstable. And there is a really small example that you should look at. Counting sort, stable or unstable? Stable. VICTOR COSTAN Thank you. It would have broken my heart if this would have come out wrong. And radix sort? Probably. Yes. VICTOR COSTAN Probably stable, right? All right. Any more questions? I like that question by the way, because you made me do this. I like that. Any more questions? All right, thank you guys. 
</body>
</html>