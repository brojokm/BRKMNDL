<html>
<body>
I want to talk about two things, maybe, depending on the level of interest. We can talk a little bit about PSET five and the things that I think are weird in the coding part of PSET five. By the way, how many people started PSET five?  I downloaded it. Hmm, maybe we are not going to talk about P set five. You guys need to start early I did. You did. Yeah. I guess I ca not punish you for everyone else. So P set five, and I can talk about graphs. I can talk about whatever did not make sense in class and I can talk about background stuff for graphs. So how do people feel? Who wants talk about the PSET that we have not read?  Who wants to talk about graphs? It is really easy. We took six hundred and four two. Yeah, if you took six hundred and four two, nothing here is new. I mean nothing in the recitation is new. We are going to take it to new heights of graph knowledge, and you will be able to do many more cool things that you are able to do before. OK, so PSET. For people who started early, what was the gist of the coding assignments? So we have to speed up something. When I ran the tests do I say what I got as results? The time is not on the PSET so you can say what you got as Pardon? The time is not on the PSET so you can say what you got as a time. OK, the slowest was like add for me. You should look to see add is a valid answer. Look at the questions and see if add is a valid answer. OK. It is not like what was lowest function, right? There is more text there. You should read the rest of the text and see if add makes sense as a valid answer. Sure. OK. What you are doing big picture is you have some processor, that is not a real processor, and it can do arithmetic with bytes and 16 bit words. And we give you the basic operations and then they give you a library for large number arithmetic because, guess what? sixteen bytes addition, subtraction? Not going to cut it for science applications are for cryptography, what we want to play with. What are the basic operations that that processor can do? Front of the PSET, so even if you did not get to the coding assignment you can still tell me. Divide, and zeros, I think. Zeros. Plus, minus, multiply, divide, and mod. Let is start to these. So you have two primitives in that processor. You have have bytes, which are basically 8 bit digits. There is two hundred point The range is zero to two hundred and fifty six point And the word is 16 bit, from zero to the sixteen minus one point If you care to know this is 6, 5, 5, 3, five point So, if you take two bytes and add them together what do you get? . Not right. It is a trick question. You get word. The processor cannot do simple math on bytes. It converts them up to words and all the math happens on words. Now if you guess two words, and add them up together what do you get? Two words? You do if we are not that nice. A world in carry bit? Sorry, you just get word. At least nobody said a byte. I was like, please do not say byte, please do not say byte. You said carry bit. Why do we care about the carry bit? What is the problem if you do addition this way? If you are going too high. If the highest bit is one on both of them. Then it is like overflow, kind of. Yep. Suppose we are trying to add two to the sixteen minus one plus two to the sixteen minus one point By the way, does anyone remember hex notation? Hexadecimal? OK, people who started the PSET remember. That is good. It will be easy to write things hex for the PSET. If you try to add these numbers you are going to get 1, F, F, F, E. You can use the math here to see that this is more than the words. So you would like to know that this thing overflows, right? You like to know that there is. Well we do not give you that. All you get to this. So addition happens, modulo two to the sixteen point If you want to be able to detect overflow what they have to do? Just tests those bits. That one way of doing it. It would take quite a few instructions, though. If you want to do overflow detection, the easiest way I think of doing it this to use this form. So suppose you have two bytes. This is the maximum value in a byte, right? 255, two to the eight minus one point If you have two bytes and you add them all together you are going to get 1, F, E. Right? It is just like the case here, except you have a fewer F is. Where is the carry here? Could be the 1, right? Yep. This guy here is the carry and this guy is the low result. Does anyone know how these are called? If you have a word and you have two bytes, what is the first byte, what is the second bytes? . Most significant byte, M, S, B, and least significant byte, L, S, B. If you want to figure out your carries, then you should do your math this way. You are going to have byte one plus byte two point Add them together. And then you call L, S, B to get the byte result. And then you call M, S, B to get the carry. This is addition. Everyone with me so far? By the way, are these numbers signed or unsigned? . No negative numbers, right? So no support for negative numbers. Everything is going to be positive. And we are going to build everything we need off of positive numbers because they are easier to deal with. What if I have two words and I subtract them? What do I get? Word. OK. What if I have zero minus 1? What do I get? zero point Not quite. If you are not using signs? Do you get O, 1? O, 1 is, OK. Ya. Wait So, O 1 is would be this, F, F, F, F. That is assuming if you signed then. It will overflow. That is a really big number then. So fancy CS, 2 is complement. For people who think in math mode, what is this? I think. It is minus one mod two to the sixteen point Remember, when we were doing modular arithmetic before, to figure out a number is multiplicative inverse? And when we were doing rolling hashes? We did not want negative numbers. We made them positive. So minus one lot to the sixteen is two to the sixteen point Minus 1, and comes out to this value. So you get minus 1, it is just that you have to know your basis. So we got the addition and subtraction. Let is talk about multiplication. What do you do for multiplication? What can you multiply? Two bytes, very good. Just two bytes. What do you get? A word. Thank you. You multiply two bytes, you get a word. What if there is overflow? It is a trick question. There is no overflow. There is no overflow. So two bytes, two to the eighth minus one times two to the eighth minus 1, is two to the sixteen minus two to the 8th minus two to the eighth plus one point You can say this safely without doing the arithmetic, right? This is how much you can hold, in other words. This is how much you can holding in a byte. Why do you minus 1? Ya, minus one point There is a minus one here, and there is a minus one here, but I ca not find it here, so roughly this. But there is an overflow. But where did you get the minus one from? Where do you get the so, this is how much you can hold in a byte. Byte has eight bits, right? From zero zero to F F. This is two to the eighth minus one point OK. OK, so multiplication? There is an overflow. I do not have to deal with that. You guys have to figure out how to deal with it. How about division? What can you divide? Some words? Almost. Words like A word divided by a byte. What do you get out of it? Words? That would be nice. Nope. Sorry, you get a byte. And if you do module, you also get a byte. What if there is overflow in the division? What happens? What would you expect to happen? We do not have any best flowing point numbers, so, we should not get overflow, right? How about two to the sixteen minus one divided by 1? So what do get? Same thing? Will this fit in the byte? Yes? No.  No. Well, that time I do not get a word. You do not get a word. I promise you get a byte. What will that byte be? It is going to be modulo something. Most significant That is reasonable, right? Modulo to fifty six because that is what it can carry. What about modulo? What happens there if you get overflow? The same thing. It is just going to loop, right? 0? So if you do a modulo, this is going to be, at most, two hundred and fifty five right? If you do modulo 255, the remainder is going to be between zero and two hundred and fifty four point Will that ever overflow byte? No overflow. No need to worry about it. Word addition can overflow. Subtraction can overflow. Multiplication does not overflow. Division overflows, modulo does not. What do you mean, like will it see the space confined? Yes. It sees the space of the result. Because here, if you are adding two words, the result exceeds the space of a word. Which is what you get. Is it just in all cases it is just. Exactly. So the reason you have to deal with this weird system is this is, pretty much, how Intel does their arithmetic. If you look at old school, 16 bit Intel processors, you have registers and you have exactly these operations. For newer processors, there are thirty two bits, but then it is just, you write more F is on the board and you get the same thing. Is it most significant bit, or most significant byte? Most significant byte. On a real processor, you have registers that are the size of a word and then you can pull out the bytes in constant time. What constant do we have? These are the operations. What constants do we have? Only two constants, zero and one point What if you want to get something bigger? What if you want to get 2? How do you get 2? Two 1 is? one plus 1? Yep. What if you want to get this number? Do that several times?  It is kind of painful to type, even if you copy paste. There is a method on Word called from bytes. And it takes an M, S, B and an L, S, B and it gives you a word. So what would I give it? . Let is give it a one and let is give it a zero point So this will get 1, 0, zero and then minus one point Yes? OK. Intel is pretty nice about constants, but some other processors are not. So I figured, why not let is get you acquainted to these kind of tricks, to too. Let is make the PSETS more interesting. All right, so any questions on this fake processor that you have to code for? Can you explain the last one again? Here? Yeah, Word from bytes. So in Word from bytes a word is two bytes. One next to the other. It gives you the first byte, and gives you the second byte. In this case, the first byte is one point The second byte is zero point Right? So two bytes. A one and a zero point How do you write this in hex? 1, 0, zero point One byte, second byte. And then I subtract one and I get this. While I erase the board, I want you guys to think of graph questions because this is the other topic we are looking at today. What was unclear about the lecture? What is unclear about graphs in general? Do guys remember the handshaking lemma? What does it mean? How do you prove it? Things of that sort. What do you guys want to cover today? Handshaking, that is the thing where you have a bunch nodes and they are all connected, like they are all in a closed graph, that the number of edges is equal to twice the number of vertices? OK. That is all it is, right? The number of vertices? No. The number of handshakes that occurred are twice the number of edges. You said the number of vertices, wait No, vertices and edges are not related in here. Yeah, think of a triangle, right? That is three edges, three vertices. Which is like not two times, which is what you said. It is the number of degrees is twice the number of edges. That is what I was thinking of then. All right, so let is start with simple stuff. What is a graph? Nodes and edges? All right. Fancy word for nodes? Vertex. Vertex. Vertices and edges. How do I draw vertices? How do I draw edges? Circles and lines. Circles and lines. 0 is and 1 is. Possibly arrows. Possibly arrows. I like that. You want to get fancy. LAUGHTER When do I draw an edge as a line? When do I draw it as an arrow? Directed under. Which one is which? Directed as an arrow. Character number. Cool. Let is draw this graph here. Yeah, looks like a pretty boring graph. Is this graph connected or not? Yes. What is a connected graph? I think that we can get to any other node following some path. There is a path from any to any other node. How do I make this unconnected using the least amount of effort? It is a bit of a trick question. Any guess is fine. What was the question again? How do I make this unconnected using the least amount of effort on my behalf? Just add a node? I heard you move pages. I do not like you racing because I do not like the So I like that answer out of the two I heard. Now it is not a connected graph. How many connected component does it have? Two and five. Or one connected component, but there are two components? OK, what is a connected component? It is like in that part of the graph the neck follows the prognito beacon and puts them in two parts two connected components So, a connected component is a bunch of vertices such that you can get from one vertex to all the other vertices. If the graph is undirected, that is true for any vertex in the set. We also want the sets to be maximal because, if we say this is a connected component, it is not very useful. Noticing that this whole thing is a connected component is useful. So this is one component. This is the other component. Make sense? So, we have the world. We have cities. You can bike from a city to another city and that is it. No other a route of transportation. How many connected components? Seven? OK. Roughly seven. Why? OK, so it only seven? Seven continents? OK. Let is say roughly seven. So this is what I wanted. I wanted some thinking. If you try to get from a continent to another continent, presumably you had go through some patch of sea. Otherwise, why are they calling them continents? Does anyone want to give out another answer? I asked this in the previous section and some people there give me some very precise answers that are not continents. This is what I had in mind, by the way. As far as I am concerned, this is a good answer. Come on guys, world. Two things, islands and Europe and Asia are connected, so you can go from one to the other. They are weird. Why are they separate continents? I have no idea. The geography people might . Sorry? You roll mountains? OK, so it would be a pain bike through them, but presumably you can. If you have a robot that does not get tired or something you can bike. It does not mind falling off cliffs. The answer, depending on my geography, we know is somewhere between seven and 10,000, or whatever the number of islands is. There are a lot of tiny island somewhere, right? Anyways, between seven and a big number. These are connected components in the world. What is the degree of A? two point What is the degree of the D? . Very good. Let is make this. The degrees of F, G, H are 2, 2, two point The degree of C is two point The degree of B is? two point Thank you. And the degree of E is? two point If you add up all these numbers together what you get? eighteen point I ca not do math, so I could not possibly have added all these numbers together, right? I used something else. How many edges do I have in the graph? 1, 2, 3, 4, 5, 6, 7, 8, nine point Do you see your connection here? Yeah. This is the handshaking lemma. That is all there is to it. So if you look at the degrees of a node each edge adds one to two degrees. For instance, this edge adds one to C is degree and adds one to D is degree. If you are a math person and you write this up, you have to write sums. You have big sums using intimidating notation, so it is not as obvious. But this is really all there is to it. Each edge contributes one to two nodes degrees. If you add up all the degrees, you are going to get to times the number of edges. So far so good? What if we have directed graphs? What if I had this? A, B, C, D, E, F. What is the degree of A? 2? Not quite. Sorry, that was trick question. A does not have a degree. If you have directed graphs, you do not have degrees. You have in degrees and out degrees. Now that I have said that you have no idea, right? What is the out degree of A? . Sometimes this is known as the degree of edges. This is two point What is the in degree of A? . So A has two edges going out, zero edges going in. How about D? What is the out degree of D? . Come on guys. Do not scare me. LAUGHS What is the in degree of D? 2? 2, very good. So what is the equivalent of the handshaking lemma on oriented graphs? The sum of the in degrees and out degrees? OK, what about them? They are equal to twice the number of vertices? Not quite. They are equal to? You had eighty percent of the answer. Oh. LAUGHS So the sum of the in degrees and the sum of the out degrees. So add them up? If you add them up, you will get two times the number of edges. That is correct. But, I want something more They equal each other? Yep. This is cooler, right? So why is that? Does anyone see why that is the case? Each edge Come on, guys. So what does each edge do? . So if I look at this edge here, this edge is going to contribute one to B is out degree, and one to D is in degree. Each edge contributes one to an out degree and one to an in degree. That means that total sum of out degrees equals the total sum of in degrees. Both of them are E and they combined to E. Sorry, eyed I do not know why that did not click to me right away. OK. The intuition behind this is, that for every node, if you take an edge you are going to get somewhere else. If the sum of the out degrees was bigger, then you have a black hole somewhere. If you go on an edge you do not come back. Same four in degrees. OK, how do we represent graphs? I think we just did. Sure, if you are drawing them on the board that is what you do, but if you are in Python what do you do? You can have a link list. Of? Of each node having its neighbors linked with. OK, so I have one big link list? Or how does this work? You had have a starting point of some sort. A starting node. Then from that node you can have its neighbors connected to it. So it was a link list, I guess. I was not precise. That is not trivial to build. By the time we build that we are done with this recitation. What do you get is the vertices and the edges. We want an easier representation that just looks at the vertices and build something, then looks at the edges and builds something. You could have a table of values. Like, A has these neighbors a dictionary. Let is go for that. So we have a dictionary. For each vertex you have the list of vertices that are connected to it. What is the list for A? B and C? OK, what is the list for B? A, D, and E. All right. For Python this would be a dictionary, right? So how much total space does this take? The number of nodes? The number of nodes. Well, then there is also the space you made for the list, though. If these were actual slots in an array so this would be an array I would have the number of nodes. You are giving away the answer to my next question. So I have these slots here. This would be an array. It is order V just to store this. The thing in Python is that have these dictionaries that are fancy hashes where they grow as you need them. For example, you have 10,000 vertices but you do not have any edge. Your dictionary size is going to be order one because it only grows as you add edges to it. So this is assuming that I do not store empty lists. If I have a stray node here, if I have a node I say this is I if I do not store anything, I do not have to pay for it. If I store an empty list here, then I have to pay for it. There is an order V component that you mentioned. Let is say, if there is a graph there, everything is not connected so there are a bunch of words instead. Then in that case it would be order V, right? It is order V if we store empty lists for the nodes that do not have edges. Right. And if none of the nodes have edges, they are all unconnected On the other hand, if I do not store anything for the nodes that do not have edges, it is order one point If you get no edges do we do an empty list or do we not store it? Depends on what you want. So if we store empty lists you are going to have an order V cost here. But your code is going to be simpler, presumably, because you do not have to check if something is or is not in the dictionary. How about this stuff? What is the total size of this stuff here? . OK. Order E. How many elements do I have in here in total? In this thing here. So what is the sum of the length of the lists? Average value of E times the number of vertices? Let is go over something else. The degree All right. That is what I wanted to hear. A lists its neighbors, right? The number of neighbors that A has is the degree of A. B lists its neighbors, so this is the degree of B. If you sum up over all of them, what is the sum of all the agrees in the graph? 2, E. 2, E. We learned about this, right? The handshaking lemma, 2, E. So what is the total cost for storing this data structure? . So V plus E, assuming empty lists. Let is look at another data structure for storing things in a graph. So instead of using lists, let is use a matrix. A, B, C, D, E on top, and A, B, C, D, E on the left. Let is pretend our graph is just that component over there. Otherwise, it just gets big and there is no extraneous site. Does anyone know how this is called? If I put numbers here, does anyone know what this is called? Is that a matrix? There is a fancy name for it. It ends with matrix. OK. I do not think we taught it to you, so do not worry. The fancy name is maybe it is misspelled, but something that looks and sounds like this., adjacency matrix. Misspelled? . I hope someone will help me. OK so if this is an adjacency matrix, what should this element between B and A tell me? If it is an adjacency matrix, it better tell me if they are adjacent. They are adjacent if they have an edge between them. For A and B, what does it happen to be? One? OK. A and A? What do we do? What with 1? It is adjacent to itself. What is easier for the algorithm that you are trying to implement? 1? So it does not really matter. We use 1 is most of the time, but sometimes it is easier to use a zero point Then you can get to A from A, right? Yeah. So that is why you had use a one point Sometimes, though, you do not want to in code. So someone dictate this to me. Or, everyone dictate this to me so I know it makes sense. A and C, is there an edge between them? Yes. What do I write? one point A and D? A and E? zero point B, A? one point B, C? zero point B, D? one point The E? one point OK. C, A? one point C, B? two point C, D? one point C, E? zero point All right. Now I am going to use the bits you gave me to come to get this. Let is see if I can do it correctly. And D? I am not looking at the graph, by the way, I am trusting you. So you better give me the right answer. D? one point How many 1 is do I have in this? . To see if you guys are thinking. 2, E?. Each edge contributes to two 1 is, right? And that accounts for most of the 1 is. O plus V. So this is how many 1 is I have. How many 0 is do I have? V squared minus 2, E plus V? This is a non boring way of asking how many elements I have in this matrix. This is what I was looking for. So V columns, right? Zeros V squared is total elements. How much memory do I need to store this? V squared. V squared. what? If I want to store it as compactly as possible? I want to pack these as tight as I can. You mean you need the entire array arranged? Yes, so what do I store? V squared what? Oh, you mean units. Yeah. What is the unit? one bit? All right So V squared bits Whereas, this is V plus E words because you have to store pointers everywhere here. So sometimes if your graph is really dense you might prefer this representation. Let me see, how much do I have? Oh, plenty of time. Who remembers breadth first search? Yes? Basically you just start at some node and you check all its neighbors, and check all those neighbors. All right. In breadth first search we have a graph. What did I draw there? A. B, E. So suppose this is our graph. And I do a breadth first search starting at A. How does that work? I started with the list of the nodes that I am going to visit. I initialization it with A because this is the only node that I know about. What happens next? It goes with B and C. All right. So I take out of the list the first thing that I can. This is my current node. You said I visit B and C because they are the neighbors. Right. I took A out of the list. A was definitely visited. And I am visiting B and C. What do I do when I visit them? Put them in the list. Put them in the list. This means I discovered them and I am going to visit the later. So I discovered them and I know of their existence. What happens next? Check if B is what you want. So B gets out of the list, and what do I do? Discover it is neighbors. All right, so its neighborhoods are A, B, and E. What Now? If they have not already been on that list then add a. A was already visited. D and E were not. D and E, then what happens? Then you check C is neighbors. Any neighbor is that I have not seen? Nope. Then? D? D and? E. OK. And then? I guess you could go to F, but it is not connected to anything. But how did you get A then, right? So A is the first node. I started with A because I said I am doing a breadth first search starting from A. So BFS starts from somewhere. A BFS has a source. We will see why that matters in a bit. So you ever get to see F? No. Nope. So if I start at A what are the nodes that I visit and what are the nodes that I do not visit? Well you visit all the ones in the connected graph. All right, in the connected component. So the whole graph can be connected or not connected. The nodes that I visit are the nodes in A is connected component because, by definition, those are the nodes that I can reach from A. If I have many kind of the components and I use BFS starting from one node, I might not visit the entire graph. How do I keep track of what node that I have discovered and have not discovered? What data structure do I use for these smiley faces? . So for the smiley faces. For this thing I probably want a queue. We had teach you something simpler, but most of the time when you write the code you actually use queue. What do I want for the smiley faces? When I pull a node out, say I pulled out B, and I see A, D, E, I want to know that I visited A and I did not visit the D and E. You guys remember that we did not visit D and E, right, by the time we got to 2? OK. So I want to be able to check whether I visited a node or not really fast. What data structure should I use for the smileys? A hash table. A has table. Cool. What is a hash table in Python? A dictionary. A dictionary. All right, so this is going to be a seen, which is a dictionary, and it maps vertices to maybe true. . Yep. Python has a set, right? So you can use that. The smileys needs to be some sort of a dictionary. So given that, and assuming that this is a queue that we can extract and you can start from in constant time, what is the running time of BFS? Let is make life easy. Let is assume the graph is connected and let is assume just does not exist. BFS was the running time. visiting. So you visit every node once, so it is at least V. That is a start. Now what do you do when you visit the node? Check out all the All the neighbors, right? Given the node, you have to go to the data structure that you have that is either this or this, and you have to get a list of neighbors. If I have this data structure, how fast do I get a list of neighbors for a node? Order of the degree? Yep. Order of the degree of the node. That is good. How about this data structure? Same oh, no that is order of V. Yep. So in this data structure, for example, C only has two edges coming out of it. But I have to go through the entire lining of the matrix to see where I have my 0 is and where I have my 1 is. In order to list the neighbors, here is straight up order V, whereas this is order of the degree of the node that I am looking for. So for this, where it is nice and simple, order of V, what is the total running time? Wait, because it is B plus B. Oh no, it is the same one. So for each node I have to? V squared. OK. So we are up to V squared already. What else do we need to do? Anything that they need to do on a node is order of V, so V squared is going to be the total running time. That is it. So if we use an adjacency matrix we get order of V squared as the total running time. What about if we lists, what the running time? I will give you a hint. You have to use amortized analysis. Shivers anyone?  We know it is order V because we are going to visit every node. And you guys did not see what I was going to write here.  OK. So for every node I go through the neighbors and I do something to them. Right? I check if they are in seen, if not then I add them to the list. So for every node the work is? it is degrees. Yep. So if I look at all the nodes? That is E. Yep. For every node I have to look at its neighbors and I have to see which neighbors are in seen. For the neighbors that are not in seen I have to add to my queue. Checking if a neighbor is in seen or not is order one point Adding it to the queue is order one point So the total work for a node is order of neighbors because of the adjacency list, not matrix. If I look at the entire graph, here I ca not do a local analysis like I did before. If I look at the entire graph and I look at all the nodes slash vertices, then the total work is the sum of their degrees. For each node is degree. For total work, sum of the degrees. And I have that nice handshaking lemma that says that the sum of the degrees is 2, E. So order E. So total running time? V plus E. OK, can I say that the running time is order E? With no V is? No, because you have to look at every Is it? V greater than in case of not connected components? . It is possible that you could have more vertices than edges OK. So it is possible that I have more vertices than edges. I agree with that, but I do anything to the vertices that I have not seen? So this is subtle. The difference between this and this is a matter of how you implement everything. In CLRS they assume that the seen is an array. So all of their nodes have numbers from one to V. So then they initialize an array, everything is false, and then they set the true elements. In Python we can use a dictionary and not initialize it with anything. So if you do it that way in Python and code carefully, you can get to order E. The parts of the graph that you do not discover, you do not have to pay for them. If you look at CLRS code, it is definitely V plus E. The difference between this and this depends on the code. What is the point of BFS, by the way? Why do we care? What does it give us? The shortest word path. The shortest path from point? From your start to where you are going. So it gives you the shortest path from the node that I am starting the BFS from. So only from this node? If I start BFS at A it is going to give me the length of the shortest path from A to which node? . All the nodes? Yeah. All the nodes that are visited by BFS are reachable and we have a path from them. How do you compute this distance? Let is see, so what is the distance from A to A? 0? zero point When I start from A and I see that its neighbors are B and C, what is the distance from A to B and from A to C? . OK. Now I look at B. What is the distance between A and A? A is B is neighbor. With A and A? Yeah. So I have three neighbors. B has three neighbors, A, D, and E. So I care about the distances between A and A, D, E. Distance A, A, distance A, D, and distance A, E. This one is zero point How about the distances between A and D and A and E? They are two point So the way I would compute these distances is that I start with A being zero point The distance from A to A is zero point And then when I look at a node, when I discover the neighbors, all the neighbors that do not have smiley faces on them get the node is distance plus one point You can get to them by getting in the current node and then traversing an edge. When you do that it is important that you do not update the distances of the nodes that have smiley faces. If you do, you are going to say that the distance from A to A is two and all hell breaks lose from there. Wait, why would you say it would be 2? If I forget the fact that it has a smiley face. So if I go through all these neighbors and I say the distance from A to B is one then the distance from A to all of B is neighbors has to be two point That would be wrong. Wait, from A to all of B is neighbors. From A to all of Oh, because A is one Of B is neighbors. Yeah OK. The smileys tell me which vertices I have already seen and I have already, presumably computed distances for them. We do not want to update those. OK this is BFS in essence. One question. Between Facebook and Twitter, which one is directed and which one is undirected? Facebook is undirected. OK. Facebook is undirected. Why is it undirected? . . When you follow someone they do not necessarily follow you. OK. So this is Twitter, right? Twitter, directed because of follows. Has anyone used Facebook recently? Did you guys see there is a new option? The little scroll bar on the side? Subscribers. Oh, ya. OK, so how do subscribers work? You subscribe. It is like google plus.  OK. Directed are undirected? If I subscribe to you do you have to subscribe to me? Directed. So which one is it? I guess Facebook is kind of directed now because you can unsubscribe from people. Is it? So Facebook has two graphs in it. They happen to have the same vertices. The people are the vertices in both graphs. But the friends relationship defines an undirected graph. The subscribers relationship defines a directed graph. The graphs are completely different. And there are two graphs. That is the right way to reason about them. that is why it was slightly tricky. Can someone think of a cool way to use BFS on Facebook? That is networks, right? Figuring out how many people are in the first degree or second degree. MySpace was really into that. Lincoln also does that, right? How many people are your friends? How many people are your friend is friends? So and so forth. Now suppose you want to get to someone in Facebook and you do not know them directly. They are not your friends. Presumably, you want to get to them through the minimum amount of effort. So you want to see do you have a friend that knows them? If not, do you have a friend that knows a friend that knows them? Do you have a friend that knows a friend that knows a friend that knows them? So and so forth. So BFS will give you that minimum path. OK. do the graphs make sense? So by the way, the BFS on Facebook is just the beginning of a ton of cool things you can with graph algorithms. 
</body>
</html>