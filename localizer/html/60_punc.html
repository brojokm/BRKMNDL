<html>
<body>
In today is class we are going to be talking about 2 4 trees. This is another way of representing a dictionary. So we are going to see the operation of insert, search and delete on this data structure and we are going to have the same kind of performance guarantees as the case in AVL trees. But in later classes we are going to see how this data structure is useful. So today I will just begin with this. What are 2 4 trees? They are search trees, they are a kind of search trees but they are not binary search trees. So recall in a binary search tree what was happening? The tree was a binary tree with each node at most two children. So this not going to be a binary tree. That is a first point. Nodes can have more than two children now. So these 2 4 trees are also called 2 3 4 trees. I will tell you what this really means. So 2 3 4 actually refers to the number of children and node can have. So a node can have either 2, three or four children. Such trees in which a node can have many children but satisfy a certain kind of search properties are called multi way search trees. So each internal node of a multi way search tree has at least two children. It will have at least two which means it could have more than two children. Any number of children more than two. Each node of a tree also stores a collection of items of the form key, element. In the binary search tree, each node was storing one key and the element there was let is say a reference to the element or the element itself could be stored there. If the key was a student entry number, then the student record associated with the key could also be stored in the node itself. So in the similar way, we have that in the multi way search tree you will have each node containing a pairs of this kind that is key, element. And how many pairs there could be? It is more than one. In the binary search tree there is only one such pair in each node and in a multi way search tree there could be more than one. In particular there could be d 1 such pairs or items, where d is the number of children that particular node has. So we are just generalizing the binary search trees. In the binary search trees each node has two children. Each node could have two children and then there is only one key that is kept in the node. Because that key helps us to determine whether we should go left or right. Similarly here we have d children, if d is the number of children then you really need to know in the search process whether you should go to the first child, second child, third child, fourth child and so on. So you will have d 1 different keys sitting in the node to help you determine that. I will soon show you an example and that will be clear. So this is an example of multi way search tree. As you can see this node has two children. This has three children, this node has two children and this actually has six children. How many keys are there in a node? The number of keys in a node is one less than the number of children that node has. And why is that? So for instance this node has three children and you need two keys in the node. The keys in the node determine what set of keys the various sub trees are going to have. So what I am trying to say here is, this is key twenty two point So this is also in the left sub tree. So everything in this left sub tree here is less than twenty two and everything here is more than twenty two point Everything here is more than twenty two and everything here is less than twenty two point If you look at this key everything to the left of this is less than 5, so in the right sub tree we now have three children. So in this first sub tree everything would be less than five point In the last sub tree everything will be more than ten and those in between five and ten would lie in this middle sub tree. So that is a concept. Now you understand why you need d 1 keys if you have d children. So everything less than the first key would be in the first sub tree. For that you have to follow the first child. Everything between the first key and the second key you will have to follow in the second child and so on. With that let me go back to the previous slide. So the children of each internal node are between the items. This is what I mean by between in code. So you have a certain node it has various keys or items. If you look at two consecutive keys then all the elements or all the items which have key value between the consecutive pairs would be in one sub tree. For that you will have to follow one child. So let is get back to this. This is an example of a multi way search tree. And how do you search in such a tree. Searching is similar to the binary search procedure as you did in the binary search tree. So suppose we are searching for eight point You come down here, compare eight with twenty two so eight is less. So you go here, now you will have to find, so eight is not less than five and eight is not more than ten point But eight lies between five and ten point So you will follow this and then you will find that eight is sitting here. So it is a successful search. So when you are searching for a key s you will compare it with k1. k1 is lets say the very first key in that node and k lets say kd 1 is the last key in that node. So you compare it with the very first key if it is less then, that means you have go to the left most sub tree. If it is more then kd 1 then you have to go to the right most sub tree. So when you are searching for the node, for instance when we are searching here for 8, we came down, we went left because eight is less than twenty two point Then eight lies between five and ten point So we came down here and then we found eight here. So when we are searching for 22, we came down the sequence of steps and we found that twelve was not there in the tree. So in particular when you are at a node, you have to determine that the key that you are searching for lies between which two keys and once you determine that you will follow the appropriate child. At the two extremities you will check whether it is less than the first key or it is larger than the last key. In which case you would follow either the left most child or right most child. So it is as simple as that. So what would an in order traversal in the tree would look like? That was the question we were at. So first what is the in order traversal in a tree? We recall in order traversal says left, then you print the data of the node and then you go right. But now there is no left and right, because a node can have many children. So what does an in order traversal here mean? So first go the left most then print the key, then go to the next child then print the key, then go to the third child then print the key, then go to the next child and so on. That would correspond to an in order traversal. So for instance here if were to do an in order traversal, what would I do? I would come down here, first go left. So first I will do an in order traversal on this part of the tree. Which means that I first come in here, I first go left I will do an in order traversal here, which means I come in here I first go left but there is nothing here. So then I print the key, that is three point Then I go to the middle child, nothing there so then I print the next key four point Then I go to the right child, nothing there. So that finishes the in order traversal on this node. Having finished the in order traversal on this node, I go back to the parent. And then I will print this key, because first I went left then I print the key which means I print five point Then having printed this key I will now do an in order traversal of this sub tree. So when I am doing in order traversal of this I will get six and 8, having finished that I go back and print this key now which gives me ten point And then I will do an in order traversal of this right sub tree. And that would give me eleven first, 13, fourteen and then all of these. So 17, 18, 19, 20, twenty one now I finish the in order traversal of this entire thing. So I print the key twenty two and then I go right. So as we can see, you will get the keys in sorted order. That is also easy to prove. Why? Because in an in order traversal I will first print out all these keys and only then will I print out this key. So which means that in the order of printing all the keys which are less than this key will appear before and all the keys which have more than this key will appear after and this is true for every key. So which means what you get is a sorted order. Yes, eight could have more than other children also. For instance, I could have something here let is say 5. 5. The five point five would be a valid node here? Instead of this I could have just one node with five point five here. That we could have organized in a different manner. But five point five is a valid node, there could be more nodes here. So now let us understand what 2 4 trees are. So 2 4 tree is something like this. What are the properties? Each node has at most four children. So first it is a multi way search tree. Multi way search tree which means every node has at least two children. Now we are saying each node has either 2, three or four children. That is why it is called a 2 4 tree or 2 3 4 tree. Each node has at most 2, three or four children. The second important property is that all the leaf nodes are at the same level. So the leaf node here are this, just forget this square boxes for now. So these are the leaf nodes and they are at the same level. They are all at level, suppose we are numbering level 0, 1, two again, so they are at level two point These are the only two properties of a 2 4 tree. Of course it is multi way search tree, so a 2 4 tree is a multi way search tree with these two additional properties. Search tree will have a property that, everything which is less than this key is going to be in the left and everything that is more is going to be in the right. This is an example of a 2 4 tree, as you can see this node has three children and this has two point There is no node with four children but you could also have a node with four children in it. What is the height of a 2 4 tree? Why should the height of the tree be at least log4n and at most log2n? What is the worst case? When would the height of the tree be maximum? It is when everyone has two children. In that case everyone has two children and all the leafs are at the last level. Then it is exactly a complete binary tree. And in complete binary tree we argued that the height is log2n, there was plus one, minus one some where forget where it was, but it is some thing like that. That is a setting when the tree height is maximum. The tree height is minimum when every node has four children in it. Because then the nodes are closer to the root, you will have four and then sixteen at the next level and then sixteen times four that is sixty four at the next level and so on. Once again if we do the same analysis you will find that the height of this tree is log4n. So height of the 2 4 tree on n nodes always lies between these two quantities. It is either log2n, it lies between log2n and log4n. log4n is essentially half of log2n. Basically the height of the 2 4 tree lies between half of log n and log n. How much time does it take to search in a 2 4 tree then? Why log n? How do we search in a 2 4 tree? It is a multi way search tree. So if I am searching for a particular key lets say suppose what do I want to search? I want to search for eleven lets say. I came here with 11, where would I go? Compare eleven with 12, I come here. I am comparing eleven with 10, so I go right and then I find eleven here. So I found eleven point So how much time does it take for me to search in a 2 4 tree? Height of the tree, is it something more that I need to do? It is correct, it is order height of the tree. I have to compare with in each node. Because when I am searching for 11, I have to essentially compare against, how many keys there could be in a node? A node we said has how many children? four point If it has four children how many keys would it have? three point The maximum number of keys therefore is three point If it has two children how many keys do I require? one point So a node has either 1, two or three keys. So when I search for the key and I come with key, then I have to compare it with this key, this key and this key. So I might require three comparisons in all to determine which particular branch to take out. So I might require three comparisons. So the time is three comparisons with in a node, times log n because that is log n is a number of node I would be visiting. Order log n. So order log n is correct but you have to be careful about this. Within each node you require more than one comparison. In a binary search tree you required only one comparison but now you could require up to three comparisons. Why three log n? He is asking me why did I say three log n. When I am searching, I start from heren start at the root and then whatever key I have I compare it with the keys in a node. Here this node has only one key but it could have three keys in it. Then I have to compare against each of those three keys to determine which particular branch to take out of that node. If it has three keys then there are four different branches, which should I take? To determine that I need to make three comparisons. Let us look at insertion in a 2 4 tree. I have this largest example that I am going to be using to show you the process. Is this a 2 4 tree? This has four children, this has 4, this has two children, this has two children and this last one also has two children. I have shown the node with three locations in it. So each node will have space for three keys and four pointers. So it has only one key but I have shown each node having space for three point So the first element I am going to insert is twenty one point How do we insert? We insert just as in the case of the binary search tree. First we will search and wherever our search terminates, if we found that element then it would say that it already exist. You will not insert then but wherever the search terminates we would insert the element there. I am trying to insert twenty one point So 21, I come and compare. Here twenty one lies between thirteen and twenty two which means I am going to take this branch out. So take this branch out, I compare it against eighteen point It is larger than eighteen so I am going to take this branch out. So take this and it goes and sits in that particular node. Why does it go and sit in this node? Why did not I compare with twenty and say that let me go down further. This is a leaf node. I could also have said it, I compare it with twenty then I try to go right but right node is empty. The right pointer is a null pointer because it is not going down any further. So I know that this is the place where I have to insert and this is empty and there is space here so I just put it in. We would not put it next to eighteen point We would continue till we can not go any further. This is what happens in the binary search tree. you keep comparing till you hit a null pointer and then you put it there. So till we hit a null pointer. We compared twenty one with 20, let is say we were trying to go right but this is a null pointer and so we put the node here. Now you are wondering how I am going to use this space. We will see how we are going to use this space. If this was already filled you will have to wait till the next slide. So if there is empty space no problem you can do the insertion. Let is say now we try to insert twenty three point So twenty three lies between twenty two and thirty two point We are going to take this link out. We took this link out, twenty three is less than twenty five so we come down here. In a node we will try to keep the keys in a sorted order because only then. So twenty three should come at this place. What should I do? Move twenty four to the right and twenty three will come at its place. Insertion actually happens at the very last node that is at the leaf nodes. The other way I could think of it is twenty four was here, I compare twenty three with it, I tried to go left that is null pointer. So that means I have to insert at that node itself. We are trying to insert forty point There should be no problem with forty point The forty is more than thirty two so I go right, I come here forty is more than thirty five so again go right and there is space here. So I compare forty with thirty nine it is a null pointer which means I have to put it right here. There is space so I put it there. If I am trying to insert a key and there is no space available in the node in which the key should go. Then what do I do and that is an example. When I am inserting twenty nine that is the kind of thing would happen. So twenty nine between twenty two and thirty two so I follow this. twenty nine more than twenty five so it wants to come and sit here between twenty eight and thirty except there is no space here. So this is what we are going to do. We are going to split the node. Which node are we going to split? The one containing 26, 28, twenty nine and thirty point We are going to split it in to two point Let is say these are four keys, the two smaller one will go to the left and two larger one will go to the right and we will remove this node. We need to link up this node, this should be the children of this guy here. Because these are all originally children of this node. So this should also be a child of this node but now its going to have three children. But how many keys are there? One, so we need one more key. If it has three children, it should have two keys. So which key I should put here? I am going to promote. So it is best to just promote up twenty eight point That is what I will promote twenty eight here. I could also have promoted up twenty nine point You understand why twenty eight and why not twenty six point If I had promoted up twenty six what would be the problem? Then the search property would not be valid. So I have to promote either the largest key from this node, up here or smallest from here. This will become the new structure. We have promoted one key to the parent and inserted that key. We could insert the key in to the parent because there was a space in the parent. But it might happen that when I am trying to insert the key in to the parent, the parent does not have any space. seven less than thirteen so we have go to left. The seven between three and eight so we should follow the second pointer. It should come here and we want to put it here except that there is no space, so we will split this node. Two nodes created. 4, five go to the left node 6, seven to the right node. We get rid off this. These are the five children of this node. So if the parent node does not have sufficient space then it is split. So we split the parent node in to two. three and five will go to the smaller one, eight and ten will go to the larger one that is to the other node. I have 1, 2, 3, 4, five children and they have to be made children of these guys. And one of the smaller that has to be promoted up because when a split happens then we take the largest key of the smaller node and promote it up. The first two children would be made the children of this node. The right three would be made the children of this node. Why two of this and three of this? Because five is going to be promoted up. So that means there is only one key left here which means that this can have only two children. The first two children will go here, five is going to be promoted up so this will have two keys which means three children. So these three would be its children and we promote five up. So we split this node that we split first then we went and split the parent and now we will see the split happening here also. Because this does not have any space. So we will split it in to two point The five and thirteen would go in to one node. twenty two and thirty two will go to the other node. This will disappear and now 1, 2, 3, 4, five these are five children. So thirteen will get promoted up now. So the first two will become children of this and the next three would become children of this and thirteen get promoted. But where does it get promoted? There is nothing above. So we will create a new root, eventually we may have to create a new root. That is what going to happen now. We create a new root, thirteen goes up there and these two become the children of this. So if we create the new root the height of the tree increases by one. You understand the procedure so you first come down the tree till you hit a leaf. You will try to put the key there, if there is space nothing to be done. It is very simple. If there is no space then you split that node and then we decided that the two lower keys will go to one node and two higher keys will go to the other node. The largest key in the lower part would be promoted up. So when we split there are four keys in a node. There were four keys to which means the second key of those four is the one which will get promoted up. Promoted up means we are trying to insert the key in to the parent node. If we are successful if there is a space no problem, otherwise repeat the split process of the parent node. So split it and this split might cascade all the way up to the root. If it cascades up to the root and the root also gets split then we have to create the new root. That is it. How much time does insertion take? So search was very clear. For search we said it will take order log n time. How many splits can be there in the process of insertion? Its at each level we might be doing the split. How much time does one split take? How much time does it take for me to split a node? I will create some two nodes constant time independent of the number of node. So each node split takes constant time. So the total time is order log n. So now let is look at deletion. So suppose I wanted to delete twenty one point First as in the case of the binary search tree, first you have to search for twenty one point Find out where the key is. In the case of a binary search tree, recall deletion require three different cases. If the key was at the leaf then we just knock out the leaf, nothing to be done. If it was at the internal node then you had to distinguish between one child and two child. The one child case is not really happening here. So it is only two child case that we have to be worried about. If it is such an internal node with two children then what did we do? We found the successor or predecessor of that key lets say we found the predecessor and we move the predecessor to that and delete the predecessor. That is what we would mean. We are going to do something similar here. Let us see. Suppose I wanted to delete twenty one point So twenty one there is no problem because twenty one is in a node. We will search for twenty one point We come down here, go right, go left, go right and I find twenty one here. Why is there no problem in deleting 21? It is in a leaf node, I can just remove it and I can remove it without violating the property of the 2 4 tree. In a 2 4 tree we require each node has at least one key and at most three keys. So after deleting, this will still continue to have one key, so no problem. That is what is going to happen. I have not shown the process but this twenty one will get deleted, we just knock it out from here, nothing to be done. If the key to be deleted is an internal node, is at an internal node. For instance I was trying to delete twenty five point I search for 25, I find twenty five right here. What do I do? I am going to swap it with its predecessor. What is the predecessor of 25? How do I find the predecessor of twenty five in the case of a 2 4 tree? I will go left and then keep going right then I find the largest key in this node. I find the largest key its 24, so predecessor of twenty five has to be twenty four point I am going to swap this two. Then I am going to remove the twenty five from here. This is a same thing, I can remove the twenty five from here. Why, because its a leaf already. There are two keys in the leaf, so if I remove one there is no problem. Note that the predecessor will always be in the leaf in this case. Not in the case of a binary search tree. Let us check this point out. In the case of the binary search tree, the predecessor of a node need not be a leaf node. Suppose this was my binary search tree, this was a node ten point I am finding the predecessor so I go left and then I go right. This could have been my binary search tree. What would be the predecessor of 10? It would be this guy. This is not a leaf node but here the predecessor will always be a leaf node. Why? How do I find the predecessor? I go left and then keep going right, keep taking the right most child. So when will I stop? When there is no right child. What does it mean when there is no right child? When my right child is null then that means all the children are null. Because I cannot have a situation in which there is a node which has a key, it has no right child but it has left child. This is not permitted at all. If there is a key then we will have two children, if there were two keys then we will have three children and so on. So my predecessor would always been a leaf, so I would just remove that leaf node and I would be done. So that is what I do. Recall I was deleting 25, so I swapped twenty four and twenty five and now I have to just get rid off twenty five point So I will get rid off twenty five by that. So twenty five disappeared from here. It is a very simple case. As you can imagine, problem were arising when I am in a leaf, I am trying to delete a key from a leaf which has only that one key in it. Then that leaf becomes empty so what do I do now? So let us look at that. If after deleting a key, a node becomes empty then we borrow a key from its sibling. Let us see what that means. Suppose I am trying to delete twenty point So I search for 20, I come down in this manner. I reach here, now if I delete twenty point So twenty is removed, problem is this is an empty node not permitted. What will I do? Borrow from sibling. What does borrow from sibling mean? This guy has only one sibling. So can I borrow fifteen from here to here? No, it is disaster because search property is not going to be valid. So we are going to do something like a rotation like we did in an AVL tree. What does it mean? fifteen goes up and eighteen comes down. Then the next thing you are wondering is, if I can not borrow from my sibling. When can I not borrow from my sibling? When the sibling has only one key in it. For instance now if I were trying to delete eighteen then that would be a problem. Let see. If sibling has only one key then we merge with the sibling that is we combine with the sibling. Suppose I was trying to delete twenty three point So twenty three is here if I delete it this is an empty node. So I try to borrow from a sibling. There is a small catch here one and two, but I cannot borrow from this one. You see why it is. Because if I have to promote something then twenty eight is going to come down but this going to jumble this. So when I say borrow from a sibling I really mean and adjacent sibling. I can borrow from here, so when I am here I can borrow from here, if I am here I can borrow from here. If I am here I can borrow from here or from here. But here I can only borrow from this guy. Did everyone understand why this is required? I try to borrow from here but if I borrow from here that is twenty six goes up and twenty four come down this is going to become empty. So that is not going to solve our problem. What we are going to do is merge. These two are going to merge, combine but if these two combine then the number of children here of this guy will become two which means. So the key in the parent node which separates these two siblings is this key, which is separating these two siblings is going to move down in to the merge node. Let us see, I create a new node which is the merge of these two nodes. This twenty four moves down and this twenty six also. These are the only keys in the new node. Because there was one here, there was none here and there was none here. Two keys in all so they come and sit here. These two will now disappear and this becomes the child of this node. Now what can happen? Essentially what we have done is we said we are going to one of the keys from the parent node is going to come down. But what if there was only one key in the parent node. The same as before and so on. So moving the key down from the parent node corresponds to deleting the key from the parent node. This procedure will be the same as that we have done so far in this leaf node. But it can lead to the cascading. Cascading as in we will see that happening in this example. This is the only child left of its parent sibling is also only one key. So we are going to merge with the sibling. We are going to create a new node which is going to get the sibling key and the key from the parent which is twenty two point This is the situation now and we will delete this and this. Because of these deletions, height can reduce by one. After all we said height log4 n is less than what it was, then that means height has to shrink and that would happen. There are just very few concepts that we really handled and insertion or deletion. no point is doing that. So first you try to borrow if not successful then you merge. So let us conclude today is discussion. Height of a 2 4 tree we have seen is log n. This would actually be a theta of log n because it is at least log4n and at most log2n. So as far as deletion was concerned we have not looked at running time for deletion yet. But you can see that is also log n. Why? It was first we come down the tree to search for the key that is log n and then we keep moving back up. At every step we might go all the way back up to the root. So another log n step. Each step where either borrowing one from the sibling or we are merging with the sibling. But all of them are constant time operations. Borrowing would correspond to constant time. So what you have seen is that search, insertion and deletion all take order log n time in a 2 4 tree. So why did we come up with this very complicated data structure? Why are we doing all of this? There is another reason, we are going to see another data structure called red black trees. And that is also very fast data structure for implementing dictionaries. What we are going to see is that what we learnt about 2 4 trees today is going to be very helpful in understanding how the red black trees functions. So we are going to look at this in next class. So with we will end today is discussion on 2 4 trees. 
</body>
</html>