<html>
<body>
How about I propose this? We go through knapsack because it is on the Pset, not knapsack but a variation of it. If we have time, we do a couple variations. If not, maybe not. And if we have time, we do at a distance. Let is see what happens after knapsack. ? How many people got the difference between polynomial and pseudo polynomial? OK, so we should definitely do knapsack. Constant factors, they do not matter. Oh wait.. Yeah, they do. So the thing is it is not constant factors. That s there is not a constant. . So the knapsack problem. So the way I look at it. You are a thief. You somehow made your way into a vault. That vault has n items. Way better than camping. Each item has a weight of si pounds, and after you get out of the vault, assuming you make it alive and everything, you can sell it for vi dollars on the market, so this is how much money you get out of it, vi. Well, now the problem is the only thing you have with you as you enter that vault is one knapsack that can carry at most s pounds. If you try to put more stuff in it, so if you try to load it up with more than s pounds, it is going to break as you try to escape from the vault and stuff is going to fall on the floor, and then many laser beams will shred you to pieces, so that is undesirable. So we can only load the knapsack with s pounds. Now, given this restriction, we want to make as much money as possible out of the whole thing, so we want to load up the knapsack optimally. Does this make sense? Everyone remembers? Good. So two ways to solve it, graphs and dynamic programming. We are going to do both. Who wants to go for graphs first? Who wants OK, never mind. Majority has been achieved. How do we represent this? First off, let is represent the solution. Our solution is which items we chose, right? So we can phrase this as n decisions. Each decision is a truefalse decision, and it indicates if you take that item with you or not. So di says, do I take item i? So now this looks more like a game. You are on a TV, there is a game show, and you get asked n questions. Do you want to take this item with you, yes or no? If you somehow manage to get items that are more than s pounds heavy, you get shot, you do not make it to the end of the game. Otherwise, when you leave the game, you make some money and the money that you make depends on what items you took with you. So now this looks like the game problems that we used to solve with graphs in that you have decisions, those decisions are moves, and they get you through a graph of states. Now, let is see what is in the state. What do we need to keep track of? First, we need to keep track of what item we are thinking about, right? And then there is something else that we need to keep track of. How much capacity we have. Yep, very good. So the reason I need that is when I am deciding whether I am taking an item or not, I want to know if I am going to get shot or not. If I take too much stuff, I am not going to make it, so I need to know if this item fits in my backpack or not. That is equivalent to knowing how much weight I have left. So s pounds. Let is say this is capacity, how much weight left in my backpack is capacity. This is equivalent to how much weight I have accumulated, the total weight of my items. Weight of the items I have taken so far. So the sum of the weights of the taken items. left. Is not it the total minus? Well, I am saying they are equivalent, so if you know one, you can compute the other. They are not equal. Knowing one lets you know the other one, but this is more useful in terms of putting the graph together, I claim. We will see if that is true or not as we try to put the graph together. So what is a node? What is an edge? An edge is putting in one more item, and a node is a state. So what the weight going to be on an edge? If the edge means I am taking an item, then the weight is going to be what? The weight of the item you are adding. The earning associated with that. Yeah. I like this better because in the end, my goal is to maximize earnings, right? And I am going to feed my graph to a shortest path algorithm. Maximize earnings, minimize path weight. They are the same issue, flip sign. So I am going to say this is the value of the item almost. Does this work or not? Negative value of the item. I have to flip the sign to turn it from a maximization problem to a minimization problem. So shortest path will give me the shortest path. That is going to correspond to making the least amount of money if I do not add this minus sign. So what is a node? Is it a unique set of items? Sorry? A unique set of items. OK. So the state in a node is going to have i, which is the item that I am looking at, because this way, I am going to have one node for each item. And what else did I say I need to keep track of? The weight of the taken items. Yep. Weight of taken. So this is sort of like the gas problem where you have to keep track of how much gas you have as well as where you are on the map. Sorry if it brings bad memories. Let is talk about an example so that we can draw a graph for it and see what things look like. So say we have three items, and say our backpack has five pounds. And my three items are a golden statue, value 10, weight, four pounds. These are one thousand, eight hundred dollars when money actually used to be worth something. Crystal ball, you can sell this for 4, and it weighs two pounds, and someone in the previous section wanted a fountain pen, so we are going to use a fountain pen that is worth 7. Culture is worth a lot of money, right? And weighs three pounds. Really ancient fountain pen. I do not know how people wrote with it. So how do we draw the graph for this? We had make a tree where each level the tree is take item i, or do not take item i. Make a big binary tree. Does that make sense? So if each level of the tree says whether I am taking an item or not, and then I have two descendants, then that is going to be two to the number of items. So that is going to be exponential in the number of items, whereas we are going to end up in a solution where the running time is proportional to the number of items. . I mean, it makes sense in some cases, if you have fractional costs or something. By the way, all these weights are integers. Sorry I did not mention that. My bad. But I like the idea of having some sort of levels based on items, so let is say I am going to have a starting node, and then I am going to have some sort of layer for item one, some sort of layer for item two, and some sort of layer for item three, some sort of vertical layer. How many nodes do I have in a layer? One node for each possible weight because I promised that in a node, I keep track of the item that I am considering and the weight of the items I have taken so far. How many possible weights do I have here? Three weights. So my backpack holds five pounds, so what are the possible sums I can get? How many? 4, 2, 3, five point So far, I heard two 3, 4, 5, six point Who wants to bid more? Not more than six point So the answer is 6, right? The possible weights are from 0, which is an empty knapsack, until weight 5, which is a full knapsack. So weight 0, 1, 2, 3, 4, 5, 6, and I am going to start drawing the nodes. You could have weight ten point We are never going to fill up a knapsack with more than five point Otherwise, we are going to die. Why do we have 6, then? Because I ca not thank. Thank you. So this node, the first node. Weight in the backpack, zero point We are looking at item one. It is connected to the starting node. What outgoing edges do I have? What do I do with item one? I can take it or not take it. You connect the edges 4, 2, three point Am I answering a different question? If it is item one, should not it have a weight? So those have two numbers in them, i and j. Sorry. They are in the wrong order here. 1, zero point So I am looking at item one. So far, I have zero pounds in my backpack. Looking at item two with zero pounds, looking at item three with zero pounds. Looking at item one with one pound in my backpack, item two with one pound, item three with one pound, so on and so forth. So if I am looking at item one, and I have zero pounds in my backpack so far, what happens if I do not take item one? Where do I end up? 2, zero point Yeah. So I am looking at item two after I am done deciding, what do I do with item one, and if I do not take item one, then I am not going to have anything in my backpack. So this edge corresponds to we do not just take one. What if I want to take item one? Where do I land? 2, four point All right. 2, three point 2, four point So if I did take item one, then I had zero pounds in my backpack before. Now I have four pounds, and I am still considering item two. What about edge weights? What is the weight of the edge that says I do not take item one? What is the weight of the edge that says I do take item one? . Minus ten point All right. zero and minus ten point That minus lets us get the shortest path. Now, suppose I am in 2, zero point What are the outgoing edges? It is the same as making a giant binary tree, right? It is not going to be a tree because I can have multiple paths from a root to some node. But this looks like it is taking the same complexity as building a tree if you were to carefully build the tree so that you do not have unfeasible solutions on the tree. Then you are actually doing dynamic programming. You are not building the tree if you are doing that. You are still converging to this. You are probably thinking this and you said binary decision tree, or at least that is what I understood. You are probably thinking of the right thing. We can see if we are thinking the same thing when we end up looking at the running time. Yes? The goal here is to have the most valuable items possible in the bag in terms of money? Yeah. So the negative ten weight that you have there was because that item was 10. Yep. And in the end, we are going to give the graph to the shortest path algorithm. So yes, speaking of the goal, what is the answer here, by the way? eleven point eleven point How do I get 11? By getting the last two items. So I take the ball and the pen and I get 11, right? Everyone on the same page? So I am at item two. I have zero pounds in my backpack. What are my outgoing edges? To 3, zero and to 3, two point Wait, sorry. That is the third item. No, second item. You are good. Should not it be 3, three because the third item has three pounds? I said I am looking at the second item and then I am deciding where I am going. So this graph has a problem in that when I get to the third item, what do I do? So I need one more layer here, which means that I am done. I was saying that it is the outgoing edge from 2, 0, it is the weight of the taken item, so if you decide to take the third item, should not the outgoing edge go to 3, 3, not 3, 2? But when I am at layer two, I am only looking at item two. So I am looking at the items in sequence. First I have to decide, am I taking item one? Then I decide, am I taking item two, and then I am deciding, am I taking item three? While I am here, I do not see item three. I only see item two. Are not those weights on the left side, though? Yeah. These are backpack weights. So down here, these are pounds and these are items. What are the weights on the edges? zero and negative one point OK. How about this other node, 2, 4? What are the edges coming out of it. 2, zero point 3, four point So if I decide I am not going to take item two, but I already have four pounds in my backpack, I am still going to end up with four pounds in my backpack, and I do not get anything out of it. And? That is it. And that is it, because if I try to take the second item, that would put me overweight, so the edge would go out of the graph. Therefore, it does not exist. You can remove it, and then you go back to 3, 0, right? Is that not allowed? No, because when I am here, I do not know how I got here. I do not know if I had item one or not. The benefits of doing it this way is here, I am just looking at item two. I do not know how I got there. I do not care what I am going to do later. I am just looking at one item and making one decision based on that. Does this make sense? Where do I get my answer from? Can you put a final node on the right side? OK, so one way of doing it is that I am going to have a final note on the right side and connecting everything to it. Do you need the done nodes right there, or could you have just skipped done and connected three to that? So I can do that, but then it is going to be hard to reason about edges. This makes it easier to reason about edges because when I am looking at this layer, I am still going to have edges deciding whether I take item three or not. So it would be confusing to have all the edges pointing to the same place. I can, it is just that the graph would look more confusing. By the way, if I am at 3, 2, what are the outgoing edges from 3, 2? It is just all horizontal. You ca not take anymore. So I can be done with two pounds, and that means I get zero or I can take item three, and then where do I land? Negative seven point Does this make sense now somewhat? So what about this dynamic programming style? We will get there in a bit. Before, let is see what is the running time for this. So one way of finishing this up is we connect everything to one destination node. Another way of doing it is that we connect the source nodes to everything here with edges of cost zero and say, well, this is how much weight we are going to waste. So if my solution path goes here and then goes somewhere through the graph, it means that I am going to waste one pound of capacity, so my backpack is going to have four pounds when I am done. Would it be or infinity? What should the weight be? Good question. This is not possible, right? To get from s to 1, one point So I am saying that if I get from s to 1, 1, this means that I am wasting a pound. My backpack will have four pounds of stuff and then one pound of capacity will go to waste. Is not there another way to waste it on the right side if you end at the top? Or not at the bottom, basically. Yeah. So you are not double counting in terms of losing stuff? You are representing losing weight on the left side and the right side. Well, if I represent losing weight on the left side, then the advantage is that I have a single destination node. What is it? That dot. So this is the source. The destination is this guy. I can waste capacity here, so that means I can say that on this side, I do not need to waste stuff. On this side, I need to arrive at done five point That is the advantage of doing it this way, aside from the fact that it is going to map to dynamic programming. There are many ways of doing it. I can choose to connect the source to 1, 0, and then look at all the paths here and choose the best one. I can connect the source to everything here with paths of some weight, which you guys still need to tell me what it is, and then I can look at the answer here. Cost zero point Thank you. So this is another way. And yet the third way would be to only connect the source to the first node, and then connect all these done nodes to another node with cost 0, and this is equivalent to this. The reason we are doing it this way is because this maps to dynamic programming. Easier. Yeah. It maps closely to how the DP runs. I mean is it possible to do the DP such that you do it the other way as well? Yeah. You can flip the DP around, too. How are we doing with this? So then I hope the running time analysis will go really fast. How many vertices? v or three. OK, so v is? ns. n layers, right? n plus one layers, actually. n times weight mass. n times capacity, right? So it is actually n plus one times capacity plus 1, but I do not want to deal with that, so I am going to use order of so that I do not have to deal with that. How many edges going out of a vertex? Two. Yep. So at most, two edges per vertex. So how many edges total? ns. What shortest path algorithm am I going to use? Bellman Ford. Topological sort BFS. I am going to choose the second one because it runs faster. So Bellman Ford is running time is V times E. If I use the DAG algorithm, that means topological sort and then a DFS. That is V plus E. So please, whenever you have a dynamic programming graph, this is the answer. It is never anything else. It is never Dijkstra. It is never Bellman Ford. It is always this. And this means? ns. So this is the running time of the graph solution. If you use BFS, do you need to put in the dummy nodes for the edge weights? If you use BFS. Yes. So then the running time would be bigger than V plus E. Right. So then the running time depends on multiply by s again? This is not doing BFS. This is doing the shortest path algorithm for direct acyclic graphs. It is the DAG shortest path. Right. Were you here before Thanksgiving? No Right before? You missed the algorithm. It is in the Dijkstra lecture notes. But basically, you do not have to put in all the dummy nodes? No. So you do a topological sort, and then you only consider a node once, and you look at all the edges coming through it and make a decision based on that. So this is the running time, this is the algorithm, this is the solution. What if we do dynamic programming instead? Instead of nodes, we have sub problems. A sub problem maps to a node. The same things that we decided about this data that we store in a node, the same things are going to apply to the state that we have in a sub problem. So what are the sub problems? First up, how many sub problems am I going to have? n. ns. I just said that one sub problem will map to a vertex in the graph. ns vertices, ns sub problems, right? Come on, guys. Bear with me. Get more cookies. Are the cookies still there? Please pass them around and eat them. Yes? One sub problem would be getting the most amount of money for that little weight. At one pound, how much. I like that, so let is start writing. What is the maximum value that I can get using a certain weight? If I label the nodes indices i, j, I am also going to label the sub problems using i, j. So I am going to say that sub problem i, j is, what is the maximum amount of money I can get by using a weight of at most j, and you said something about items, so we have to figure out which items. Which items? Anyone else can help her. You already did the hard work, so you have most of the stuff filled in. Feel free to jump in. Greater than or equal to i. OK. Sounds good. We are going to number the items starting from zero this time because we are going to have a dynamic programming table, and that means we like zero base indexing. So the items are going to be 0, 1, and two point zero is the statue, one is the ball, and two is the pen. This means we are going to look at suffixes of items. First, the empty set, no item, then only the pen, then the ball and the pen, and then the statue, the ball, and the pen. And we are also going to consider how much weight we have in our backpack. So let me write this again. 0, 1, two here, and weights 0, 1, 2, 3, 4, 5, and this is going to be our DP table. Now, how are we going to compute this? DP of i, j is? Maximum. All right, a maximum of something. Good. Perfect way to start. How many decisions do we have? Two. Two. It is the same as in the graph problem, right? Once we solve that, this should be pretty easy because it is really very similar. So the two decisions are, do I take item i, do I not take item i? If I do not take item i, what situation do I land in? So suppose I do not take item i. i plus one point OK. i plus one point So I have to make up my answer using items i plus one all the way through n minus 1, and how much weight do they have to have? j. Yep. Now suppose I do take item i. What happens? i plus no, no, no. You are thinking of the right thing. We are making some money, right? Value i. Value i. So this is how much money we are making. Good. Plus dp i plus one j minus weight i. Make sense? OK Now I only have to do one more thing to make sure this code does not crash. I am sorry. What is the third term for? This is I am making some money, right? This means I am going to have to look at the items starting from i plus one and i minus one point And now I took item i, so that means I have si pounds in my backpack. So the remaining items must weigh j minus si pounds because I am going to add the si pounds for this item, and in total, I am going to have at most j pounds. Make some money, lose some capacity. Did we? Yep. This is what happens when you move from the graph to dynamic programming, or you can draw the graph the other way around. So could you have also done plus si, and then done something else as well? Sorry. Plus si If you did plus si and then you did some other check case that was different. Well, I do need to make a check. Yes. So that is greater than or equal to zero point This thing, right? Because otherwise, the code is going to crash. So j minus si is greater or equal to zero point I think this means j is greater than or equal to si, right? Yes. OK. At least for me, the natural order when I have the graph is to consider the moves that by making in the game. I am answering the questions one by one. Do I take this item? Do I not take this item? When I am in the DP, when I make a decision, I want to have the full information on that decision. Whether I take the item or not depends on what would happen with the items following it. Representing it this way allows me to make the decision right here. If we had done prefixes rather than suffixes, we could have done it the same. It would have been exactly the same as there. So we taught dynamic programming over many years, and it turns out that people understand suffixes better than prefixes, and the graph format makes more sense that way, so that is why we are doing it this way. It is for your own sake. Trust me. Or at least we think so. Where does suffix come in? I know what it means. These guys. These are the sub problems. Nothing, item two, items one, two, zero, one, two, so it is a suffix of the set of items. How come you are going backwards rather than forwards? It does not actually matter if you go backwards or forwards? Yep. In the end, we are going to look at everything. So we need two things. We need to know where is the answer going to be, and we need to know what are the initial conditions. Actually, I lied. We also need a topological sort. So where do we want to start? First one. Where is the answer? Yes? The lower right hand corner. I mean, if you have all the nodes. Oh, we do not have a Done column, do we? No. Well, so the answer will have considered all the items, right? Top left. So which i? Almost. So the top left corner means I looked at all the items and I have an empty knapsack. Oh, so the max of all of the first column. So the max of all columns would be the answer if the weight here would be equal, but I said the weight has to be smaller or equal, so the answer is easier. I do not have to do a max. Bottom left corner. I can only look here. So this means that I will use a weight of at most s, because this is s, and I will have considered items zero and larger, so all the items. This is where the answer is. And in general terms, that means DP of what and what? So what is the bottom left corner? 0, s. Yep. Can you explain again why it needs to be DP 0, s. I think it is easier to look at 0, s and see how it maps to the sub problem, and then convince yourself that this is the answer, so let is do that. DP of 0, s means i is 0, j is s. So this is going to tell me what is the maximum amount of dollars I can get by using a weight of at most s agrees with the initial problem and using items i or greater than i, or zero or more, so items zero through n minus one point These are all the items. This is the maximum capacity, so this maps to the initial problem. And that is why I did this. That is why I do not have an equal sign here. And if you did have an equal sign, then you would be changing your sub problems? The recursion stays the same, but I have to look at all these to get the maximum. Someone suggested that. If you put an equals there, you are going to have to do something to the DP such that the equals actually is captivated, because you ca not just arbitrarily What do you think of this? Something there is going to change, is not it? No. I think this works. This stays the same no matter what the sign is. The only thing that changes is where is the answer and what are the initial conditions. Oh. So there is something else that changes. Yep. Initial conditions. Good. I like that you are thinking about that because the next problem changes pretty much that. The sign changes and then these change. What is a good topological sort? This should be pretty easy. If I want to generate a topological sort, what variables do I iterate over, and in what order? i. OK. And you are pointing at n, right? n down to zero point Yep. And then the only one left is j, so i in, and then j goes from where to where? j goes to s. It can go either direction. Can it? What do the dependencies look like? When I am computing i, j, I want i plus one and j minus so I am looking at lower j is, higher i is and lower j is. But it is always higher i is. Does not that mean in this for loop that you are already going to have calculated the next right column, so it does not matter where the column I may be wrong. You are right. Fine. OK, both orders work. I just looked at this because I wanted to have a nice, simple but fine, both work. Wait. You mean reversing j works? Yes, because we are iterating over i before iterating over j. Of course, this makes more sense. Just because they are both good answers does not mean you should choose the one that requires more thinking. I always like the answer that requires the least amount of thinking to prove that it is correct. Does that mean you are starting with a full I start here. But if you are going from s down to 0, then you are starting down at the corner, which means you have a full knapsack, so that does not make sense. So the argument was when I compute this, I am looking one right, i plus 1j, and then I am looking somewhere here. And I have already computed this column, so it does not matter if I go up or down. And that argument is correct because first I am going to compute this column, then this column, then this column, then this column. By the way, what is this column? This column is the initial condition. Now that we figured out the topological sort, let is try to compute values here and see what the initial condition should be. So if I want to compute DP of 2, 0, that is the maximum of either DP 3, zero or something else. This is going to evaluate to false, so it is going to be this. What should the answer be here? zero point zero point So we want DP of 3, zero to be zero for this to work. So what is a reasonable initial condition? Column three is of zero height. DP of nj is zero for all j, pretty much what you said in math mode. So I am going to have an extra column. This is like the Done problem over there, and here I am going to say that whenever I am looking at the empty subset these are all suffixes. All three items, two items, one item, empty suffix. Whenever I look at the empty suffix, I can fill up a backpack with any weight by using no items, and I am going to make zero money. So what are the values here? You guys nodded, so you understood, so then you should be able to dictate the values in the table. So is that one also zero because you ca not go up to anything, and then the next one is four because you can go Sorry. Next one is so it is for the fountain pen, right? Last item. Crystal ball. So we are going statute, ball, pen. And this is weight on the left side, right? So we are filling them like this in the topological sort order that we chose here. We said this is the order, so this is what we are going to use to calculate the table. Oh. So it is still 0, then. OK. seven point So here, this condition is going to evaluate to True finally, so this is going to be the maximum of either DP i plus 1j, so DP of 3, 3, which is 0, or seven plus DP of 3, zero point So seven plus 0, which is seven point That is why it is seven point 7, seven point 7, seven point How about this? zero point zero point four point The maximum of zero and four plus 0, right? four point No. seven point So it is the maximum of seven or four plus 0, so this is seven point seven point eleven point seven or four plus seven point Does this make sense for everyone? Last column. Let is do it. zero point Feels like zero point zero again. Why not? four point How much does this thing weigh? four point seven point ten point Sorry for my handwriting. And it needs to be eleven because you said that had be the answer. All right. So it is eleven because it is either this guy or ten plus DP of 1, one point The first item weighs 4, so I need to look one right and four up when adding. Does this make sense? Please say yes. What is the again? I get how if you are looking horizontally, the top thing is the max. It is saying DP of i plus one j. So this is looking horizontally, and this means I did not take item i. You did not take item i, but if you are going to take item i, you add the value of i, and then you look back for DP of i plus 1, which is the previous column, and the row number is whatever capacity you have left if you did take it? Yep. And so in the case of cell 1, 3, if you took item one, then capacity you had have left is three point Right. So you said total capacity three, right? So if I take item one, how many pounds does it have? It has four. Statue is 0, ball is 1, pen is two point Oh. You are not using So I am using those items, but I am starting using zero based indexing. Yeah, but we are going from here to here. So I am saying if you pick the middle cell that is 1, 3, that one So this has item one, so the ball, weight three. If I take the ball, how much weight do I have left? The ball weighs two pounds, so you had have three pounds left, and that is why you are in the three column. I have a backpack of three pounds, and then I put a ball of two pounds in it, and I have three pounds left? No, no, no. You have three pounds left if you put a ball and two pounds in, right? I have a backpack of three pounds. I put a ball of two pounds. How many pounds do I have left of capacity? So backpack, three pounds total. I put a ball in that has two pounds. How many pounds? We have none left. Oh, it can hold three total pounds? Yeah. Then you have one pound left. But we have a five pound backpack. Well, you said we were looking at 3, one point You said we were looking here. Yeah, we are looking there. So this means three pound backpack, because the sub problem says your weight is at most j. Got it, OK. Oh, I see. So j minus si is saying It means you used up, so you put up something there, so you ate some capacity. Well, you ate only two pounds, though, so why is it in row three? You told me to start here. I know. I am trying to remember how we got there. You said, let is start here. That is why this arrow points here to one. You have two arrows, 2, 3, and 2, one point Because it is j minus si. Oh, I see. Minus three point So j is the amount of weight you have left, right? So j is the amount of weight I can have for this sub problem. Yeah, the amount of capacity I have still in my backpack. Let is talk about pseudo polynomial time very quickly and what does it mean, OK? And you guys will promise to look at the recitation notes and look at the other problems, right? So incentive for that. Problem two is easier than knapsack, so if you get that, that should be a good confirmation that you got knapsack. Problem three is a bit harder than problem two, but it shows up on interviews, so you want to understand problem three. I got problem two twice in four years, so there is a decent chance that you will get it. So you want to get to problem three, so you should go through problem two. How many times have you got problem three? Twice in four years, so that is the problem that you want to get to. Problem two is a stepping stone. So running time for dynamic programming. How many sub problems? Same, ns. Yep. Sub problems. How many sub problems do I look at when I compute the answer of a sub problem? Two, right? So order one. So this is how much time it takes to compute the answer to a sub problem, because I have the max of two elements, so it is constant time. So the total running time is? Order ns. All right. Order of ns. This polynomial, is this the same kind of algorithm as Dijkstra? Pseudo polynomial. Pseudo polynomial. Do not know why. So intuitively, the problem is s shows up in your running here, and s is the property of your input numbers. It is not how many elements you have in the input. It is what is inside one of those elements. So let is see why that matters. Let is look at the practical example. What about measuring in cubic inches or cubic centimeters? Is that a problem? It would take a lot longer if we do it in cubic centimeters. Yeah, but then you could argue that if it is an integer amount of cubic inches, you should divide everything by that. Where this really matters is suppose you have a one hundred item input, so one hundred items. What is the worst case input on a 32 bit machine? An input looks like this, by the way. How many elements you have, so 3, and then for each item, what is the weight and what is the value? So then we are going to have three weights, which I believe are 4, 2, three point You guys have to take my word for it. And then I have three values, which are 10, 4, seven point Let is not worry about the values. I claim that they are irrelevant. You can convince yourselves afterwards that that is the case. Let is only look at this. The weights have to be between zero and what for the problem to make sense? five point If I have a weight bigger than this, I know I am not going to take that item. How many bits do I need to represent these weights? Log s. It is log s plus one technically, but if I write order of log s, I am good. Times the number of items. Yes. So if I want to represent all of them, I have order of n times log s, plus the number of bits required to represent this. This is log n. So log n is smaller than n. I am not going to add it here. So this is my input size. This is how many bits I need for the input. So the worst case input on a 32 bit machine is going to have roughly 3,200 bits. What is the worst case s that I can represent on a 32 bit machine? These are all 32 bit numbers. You mean each of the weights are 32 bit numbers? Yeah. So what is the worst case s I can represent? two to thirty one minus one point Which is roughly four times ten to the ninth. So the worst case running time is? Roughly ns, right? So n times s, which means roughly one hundred times ten to the ninth, which means four times ten to the eleven operations. Now, suppose we are looking at the worst case input on a 64 bit machine. Still one hundred items. What is the input size? To the twenty one total at the end. That is how many operations. Let is go through it step by step. How many bits of input? 6,400. Where does that come from? one hundred items times thirty two bits. one hundred items. Each item weight has sixty four bits. What is the worst case s? two to the sixty four point two to the sixty four minus one point Does not matter too much. It is one times ten to the 19th, one point six times ten to the 19th. So the worst case running time is? ten to the twenty one point ten to the twenty one point So what happened? I increased my word size. The running time increased quadratically. This is not a polynomial increase. What is the problem here? Why is this the case? If I write log s as b, so log s becomes b, what is the input size? nb. Yep. n times log s equals n times b, so this is the input size. Now, what is the running time? The number of operations? Yep. n times two to the b. Yep. n times s, and s is two to the b. So this is the problem. This is a polynomial in n and b, but here, if I write the input this way, I have b as an exponent. So if I double the number of bits by doubling the field size, my running time increases quadratically, so this is not polynomial. However, if I write it as order of n times s, this looks like a polynomial. So it looks like a polynomial, but it is not truly a polynomial, so that is why it is pseudo, as in fake. So it is actually exponential. It is not exponential. So an exponential algorithm for this means try all the possible subsets, and that is order of two to the n times n to compute the sum. This is exponential, right? You have n here. It is clear. I know, but if you have two to the b, that seems pretty clear as well. Well, you have to look inside this s and see what it means. That is the difference. So by increasing the number of items, if you double the number of items but you do not do anything to the word size, then your running time is going to increase polynomially, but if you change the field size, it is going to increase exponentially. So pseudo polynomial means watch out, there is a trap. It is not really polynomial. If you increase the input size by increasing the number width, bad stuff is going to happen. So think of Dijkstra. What is the running time of Dijkstra? You count the number of vertices, the number of edges, and you have a polynomial in that, right? You do not have to look at the number size. You do not have to look at any weird stuff like that. Here, you do. That is the difference. Does it make more sense? So whenever you have an input number that shows up in your running time, instead of how many numbers you have, that means there is a trap. That is pseudo polynomial. So it is just like having some constant that depends on something? It is not a constant. I mean coefficient. Once you set it, it is a constant, right? I mean, that is true for everything, right? You can say that you have ten to the eighty atoms in the universe, so all the numbers that you work with are at most ten to the eighty point Therefore, your running time is order one no matter what you do, and then running times are no longer useful. You have to draw a line somewhere. I think it is just like s, if it depends on your field size and you can scale it, it is kind of like So asymptotic running time. What is the point of that? How do our algorithms scale? As our data becomes bigger and bigger, what happens to the running time? This pseudo polynomial thing tells you that if you are shifting to a larger number size, to a larger word size, then your running time is going to explode. It is not going to scale linearly. Still do not buy it? I trust you, I just So it is only dependent on the field in this case. Do you guys want to look over Dijkstra and see what the input to Dijkstra looks like and why that is different? Do you think that is worth your time, given that this is what is standing between you and the weekend? What time is it? If you guys want to, I am willing to do it. It is 407. I will stay. Well, if you guys want to go, you can go. I will draw this for the people who still want to know what it looks like. Dijkstra. What is the input to Dijkstra? It is a graph, right? Yeah, nodes and edges. What does the graph look like? It is some number of nodes, so it is a single number that is the number of nodes that has log v bits in it. And then for each edge, we have three numbers first vertex, second vertex, and the weight. What are the sizes of these numbers? Log v, log v, and the last one? Log w? OK. And what is w? Maximum weight. Yeah. So this is a property of the field size, right? Let is look at v, actually. So we have E edges here, right? So the input size is going to be log v bits plus E times log v plus log w. How did you get that? Because I have the edges, so I have E of these. I only have one vertex count, but then I have E edges, and each edge has three numbers, and these are the widths of the numbers. Is the adjacent edges to v? Is that right? You say you have E edges. I am assuming it is a list, so the most compact representation of edges, I think or it might be a reasonably compact representation is that you have the list of edges. So you have a graph that has five nodes, and then you have an edge that goes from one to 2, and then weight 3, an edge that goes from one to 5, weight four point If you use a number, it is not a Well, do I need anything else for vertices? Not really, right? So v1 and v2 are neighbors of capital V? So v1, v2, w, these are the first edge. Each edge has these fields. This is the entire graph in one thing. This is the entire graph as a list of numbers, and this is how many bits it takes to represent the graph in a reasonably compact representation. Now let is say little v is log v, little w is log w. So then this is order of how many bits do I have here? E times v plus w plus v. I just replaced the logs with these variables. This is how many bits. Now, how many operations does Dijkstra take? What is the running time? Well, it depends on E log v. Would not it be E plus v? That is the fastest one, right? But I think practically, it is only going to be So this is E plus v log v, the fastest theoretical limit. This is still smaller than E log v. This is going to make my life easier. So this is smaller than this. If this thing is polynomial, this is polynomial for sure. E log v is E times little v. So how many bits in the input? E times v plus w. How many operations? E times v. Any exponential anywhere here? Would not you change the size of v? That looks fine. Well, so there is a trick that v is two to the v, right? So you can say that this is order of so this is definitely bigger than two to the little v times v, but then you have the same thing in the input. So the input also has at least two to the little v times v bits. But do not worry about that. That is too much. The point is if you are worrying about this, do not worry. The math still works out. So whatever you have here as an input, the running time is going to be a polynomial in the size of the input. What happens if you double the word size? What happens if you have bigger weights? Everything like v is multiplied by 2, and w is multiplied by two and everything in this problem, right? So if you are doubling the word size, then this is going to double, this is going to double. Everything is fine. What if you double the size of the weights? That only adds an extra bit. Sorry. So if you double the size of the weight numbers? So if you move from 32 bit weights to 64 bit weights? That is still a constant factor, right? What happens to the running time? Nothing. Nothing. w does not show up in Dijkstra. If it would, then we had be trouble. It would not be polynomial anymore. But practically, you will be accessing that number, right? Yeah, but that shows up in the cost of one operation. That is why I am saying this is how many operations you do, how many arithmetic operations. Then the model of computation that we use is RAM, and that says that you can do any math operation in order one. . So here, my number in the input, s, which is the size of a weight, showed up in the running time. Oh, the size of the input showed up in the running time. So the size of the input is OK, but one number in the input showed up, whereas here, that is not the case. The weights do not show up in the running time. So why do not we just always run Dijkstra, then? Actually for this problem, for the knapsack problem, you ca not find an algorithm that is polynomial. If you do, there is a 1 million prize for it because you just proved that p equals mp. This is the best we can do for knapsack. Is counting sort pseudo linear, because you need to have a maximum, a range? Does that make sense? Counting sort. Depends on your range. Yeah, but the range shows up under a log. You are allowed to have logs. You are allowed to have log w. You are not allowed to have w. It is dependent on the size of the input. If you double the number size, then you are going to have twice as many rounds, but you do not have an exponential number of rounds. Sorry. You are thinking of counting sort. I thought radix sort. Radix sort does not matter because you assume we can do everything in never mind. You are right for counting sort. Sorry. You are right for counting sort. Sorry. I was confusing counting sort with radix sort. So for counting sort, yeah, it is not linear. It is linear in your range size, which is not linear in the input size, which is why we do not do counting sort. We do radix sort. We do counting sort in radix sort? Yeah. But radix sort limits the size of the range, right? That is the point of radix sort. Oh. I see what you are thinking. So doing counting sort with each number? Right, with really big numbers, taking a really long time. Yeah, that would take a long time. Yep. That is very true. If you try to do pure counting sort on 64 bit numbers, you are going to run out of RAM. Does this make some sense? OK. Promise to look over the other problems, and in return, given that I did not have time to cover them here, I promise to answer any emails you guys might ask me over the weekend. Oh. Awesome. 
</body>
</html>