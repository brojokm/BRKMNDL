<html>
<body>
We are going to cover hashing next time. Now we are Going to focus on pset three because I heard pset three is hard so we are going to look at the code and try to understand it. This course is hard. I have tried to make it easy. I really tried. How many people recognize the code? Does this look familiar? One, two, three. Everyone else got stuck on question one? I am not going to give you the answers to the psets. We are going to LAUGHING Sorry. We are going to look at the code and understand what it does because once you understand what it does you can understand how to modify it. All right, before I do that, any questions? And I might not answer them right away, but I will keep them in mind while I go through the code. Are there any specific pin points. The types. Yep. Covered in five minutes. Oh well. The first thing that I want to talk about is sweep line algorithms. We are asking you to implement the sweep line algorithm and we are giving you one that is horribly inefficient. Suppose you have some line segments that look like this. Sorry, drawing is not. They look like this. And suppose you want to find the intersections between them. Now let is figure out what the algorithm that we gave you does. Did people look at the trace for that? Not the good trace, the trace that is output by the algorithm that we gave you. Does anyone understand what that does. I kind of get it. OK. I think what it does is it just hits through all the horizontal lines and it goes through all the vertical ones. First it goes through all the horizontal lines and what does it do with them? . They get bolded in the visualizer which means they are added to the range index. So one, add all the horizontal lines. And two oh you said it goes through all the vertical lines after that. Any idea what it does? It looks for intersections. When he looks at a vertical line segment you will see some blue square and you will see some segments that are green. This is a query to the range index and the green segments are the answers and the blue square is the range that is queried. First add all the segments to the range index and then do a query. In principle sweep line algorithms have some geometric inputs. For example, a bunch of lines. And conceptually they have this vertical line that they sweep across the plane all the way from minus zero to plus infinity. Now if you try to sweep a line continuously from minus zero to plus zero in code it might take forever. We do not really do it that way. The way we do it in code is you know when something interesting is going to happen and you only simulate what happens to the sweep line at that point. In this case the sweep line starts at minus zero and then all the horizontal segments are added to our range index. And then as the sweep line goes across the plane, when it hits a vertical segment a query happens. The only times when the sweep line stops is first, at the beginning to add all the horizontal line segments, and then every time it hits a vertical line segment. We know this ahead of time so we can compute a list of all these coordinates of interesting things. And then we can sort them and then go through them and simulate the behavior of the sweep line that way. If you look at the code listing at events from there, this is the gist of it. This is what it does. It compiles a list of events. The first key in each event is the x, is that x? Yeah. x like this, y like this. The first case, the x coordinate of an event and by sorting that list of events it will then process them in order. Events from there is responsible for looking at all the wires and compiling events. How does an event for a horizontal layer look like? Can anyone tell me? Sorry, for a horizontal wire. It will run across. First off it looks like a list, right? It is a regular python list. And I will try to call it vector so that we do not confuse it with a big list of all the events. You said the first thing is the leftmost point. Right? If this segment, for example, starts at minus 100, this one starts at minus 95, this one starts at minus 90, and this one starts at minus 50, by the way not to scale, then the leftmost point is minus one hundred point Right? This is the first element in the vector. And that is computed on line four where it goes through all the segments, looks at all the X coordinates and chooses the minimum. What is the next thing in the vector? We do not have to understand why. We will go through why in a bit. I am just interested in what? Zero. Zero. Excellent. After that there is a wire ID. Each wire gets a unique ID, that is a number between zero and the number of wires. Say this is one, two, three. This is going to be one. And then I have the string add. And then I have the actual wire object. What does the vector look like for a query event? Sorry, what does it look like for a vertical wire? I am giving away some of the answer. Bad, bad, bad. All right, vertical wire, look at the code and. It keeps the left. Of the wire. OK. And? It keeps the x coordinate. A vertical wire will have the same X coordinates for all the points on the wire, right? I do not really worry about which coordinate it is. This wire is at minus fifty point The first element here is going to be minus fifty point What is next? A one point A one point OK. And suppose this is wire ID four point I am going to have four point Query. Query. And the wire. And the wire. All right, what happens with these in the init method, which is not shown in the code listing, is after the list is put together sort is called on it. These are all compared and then reordered to be sorted according to some ordering relationship. Does anyone know what the ordering relationship is for Python lists? Yeah. It starts from the first, from zero, and the next it goes to sort the same with as X one point OK. Say if I have 1, 2, three and 1, 3, two point Sorry, and 2, 1, two point He is going to look at the first element and if they are different than the one with the smaller element is smaller. 1, 2, three as a vector, sorry, as a list, is smaller than 2, 1, two as a list. If this guy becomes one then they are equal. Then it has to go to the next element, compare them and see if they are different we have an answer, if not we have to keep going all the way until the end of the list. This is called lexicographic comparison and this is the same ordering that you have for the words in a dictionary. Right, if you think of each letter as an element in a list and the word is the list then this is how you look up words in a dictionary. The reason events look like this is so that sort would output them in the right order for the next state. So, yes. Does that mean all the horizontal wires, does that mean that they start at same place even though that they do not? Yup. all the horizontal wires will be sorted. All these add events will be sorted before the query events. Yup, very good observation. This is what I am trying to achieve. That is why I have this special value here. I go through some extra effort to compute it. I had to write an extra line of code so this is the motivation for it. The first key in the vector is the X element on the sweep line. I could have also had the very large negative value that something that would behave like minus zero here and that would work just as well. By computing the left edge I do not have to deal with that. I do not have to worry of whether my negative zero is small enough, because if it is not I will fail the test and that is bad. This is the x coordinate at which the sweep line stops and something happens. So if all the events are different the x coordinates then I have my ordering, I am done. Now what if I have two events at the same time? For example, what if I have two vertical wires? The x coordinates are going to be the same so I need to use something else to break the ties, right? The first thing that I use to break the ties is all add events have a zero here and all the query events have a one. And the point of that is if I have two events at the same x coordinate, if I have a query and an add, I want the add to happen before the query. If this is the same this is going to be different for ad versus query. Does that make sense? This is how we order events relatively to each other on the same line. Now suppose I have these two wires, they are both vertical so they are both going to be queries. They are both at the same index. I need something else, and that other thing that I have is the wire ID which is guaranteed to be unique. I know for sure the comparison will stop here. And the comparison had better stop here because if the comparison gets all the way to here, wires are not comparable so the code is going to crash. It stops here because the IDs are unique, everyone is happy. All right, do the events make more sense now? To complete the picture if you look at compute crossings, lines nine and ten. Line nine goes through the vector sorry, goes through the list of events that have been sorted and processes them in order so sort had better do the right job. And then it extracts the x coordinate, that is here, it extracts the event type, that is here, and then it extracts the wire from here. These guys really are just there to help with the sorting, they are never read afterwards. Where are the events actually sort? I thought they just put into order. The events are sorted in an init method that is not here. It is in the piece of code but it is not here. And that may be a hint that you do not want to change it. As in you do not need to. All right, events look like this. Any questions about events? Everything make sense? Presumably when you write your own sweep line algorithm you are going to come up with your own events which are going to be different. You are going to change these methods to add your own events to the list. And then it is going to be sorted for you and then you are going to change compute crossings to process your events in the way that they should be processed. Let is look at the range index. What do we store in a range index? The horizontal wires. Horizontal wires. Very good. What is the point of storing horizontal wires in an index? That is when you want to query, the area has a line through it. For the algorithm that we gave you how does a query look like? Suppose I have this wire here and I am doing a query for it. Just ask to list horizontal wires that are between that Y. Between this guy is top and this guy is bottom. Right? Yeah. A query would look like this. Basically all the horizontal wires that have their y coordinates between this guy and this guy. Now if I have a wire that is way up here or way down here I know for sure that it is not going to intersect this wire. Right? I do not care about it. The range index helps me eliminate some wires. Now, will the range index eliminate all the wires that do not intersect with this wire? No, OK. Why not? Well in this code it does not. OK, in this code it does not. We are only talking about this code, I am not talking about the solution code that you guys have to implement. It does not because it never removes the horizontal wires. OK. What is an example of a query that would give me some wires that do not intersect my wire? Like if they are in between the y axis, they are, yeah but they are not actually. OK. So you mean. Yeah. Negative zero and zero on the x axis would give you a bunch of wires and not many of them will intersect with the vertical wires. If the end were a vertical wire,. OK. I understood this because it matches what I drew. I did not understand the minus zero plus infinity. Well if you think about the x axis on the bottom, if you go from all the way on the left to all the way on the right you are going to get a whole bunch of wires that are short that Are you talking about one wire that is like that, or many? If you are grabbing from your range index. The range index has horizontal wires in it. Right. Are you assuming that they are all short? Yes. But it is not necessarily true. Some of them will be short. You are saying a lot of short horizontal lines you mean like this, right? Yeah. OK. That is what you mean. You have one intersection and A ton of non intersections. Exactly. OK, cool. Thank you. Doing a range query on this can give me a lot of false positives. That is why after I get them I have to make sure that they intersect and I ca not just blindly output them. These are bad false positives, these are bad false positive. Now let is look at how the range index works. Can anyone remind me of what the range index does? It is a data structure, right? And it has some operations. What are the operations for it? It returns everything between two values. You have a list operation where you give it two values and it will return everything inside the index, in the interval between those two values. What else can I do? It can also tell you how many. It returns those keys and how many there are. I have the count and you said that I have some things in the index. Right? How do I get them in there? These are queries, I need updates. Add and remove. For the code that they gave you, what is the running time for each of these operations? It would be constant had to be removed. OK. Add calls the pend. Right? So that is constant. I will agree there. To remove it you had to shift everything. Yep. Let is start with an example. Say I have these keys in my range index. 5, 8, 11, thirteen point Suppose they are magically inserted in this order. If I want to remove two, since this is an array I have to shift everything to the left. Yes. So that is. Order and time. OK. How about list and counts? What is the running time for counts? How does count work? It is not just through all of the keys. Count goes through everything and It has to be order. Cool. Count goes through all the keys, evaluates the predicate that checks whether they are in the range and then it adds up one to the sum for the right place. How about list? Also. OK, that is a list comprehension. The code is a bit tricky, but it pretty much does the same thing. It goes through the list and it puts all the keys that are in the interval in the list. Now let is look at another version on the next page of our range index that is slightly better. What is the rapid variance for this? How is it different from the first one? Sorted already. Sorted already. Very good. The keys look exactly like this. Right? What is the running time for let is start with add or remove, what is the running time for add and remove? N, order of N. Why is it order of N? No, oder log N. Why is it order log N. Because if it is sorted you can look in the middle and do a binary search. I can do a binary search in order to find out where I insert something. Right? But what if I want to insert zero in this? Is it log N plus order N? Does that make sense? Because you have to shift all of the. Yeah. So worst case if I have to insert zero here, I have to shift everything to the right to make room for it. Right? So your first instinct was good. Order N. And questions? No more? Cool. How about remove? Order N. Order N. Why is it order N? You have to shift left everything to the right. Is this what you were going to say too? Same reason as before, if I want to remove two I still have to move everything to the left. I can find the key that I want to remove very fast but then shifting things is still order N. OK how about count? How does count work? It is the same thing, is not it? Binary search so it is log n. Binary search, so it is log n. If I look at the count there it is It is not though, that is telling you how many keys between. So it is a simple subtraction to find the number of keys between. Count calls binary search twice and then it does a arithmetic operation, yes. It would be log n because with the count where the range is that is log n because you have to actually sift through it, but binary search you have two other operations and then you just do a surprise. Yep, thank you. Very good. This is log n because of good old binary search. How about lists? I think you were thinking ahead of lists. How about lists? You have to list every single thing that you read. You have got the values you might potentially have to. Is it log n plus the length of the list. Yeah. I was going to do a nice long analysis and there is the answer. Log n plus, suppose you return i values from the list, i. Why does this matter? If I have a range query from minus zero to plus zero I have to create a new list, copy all these keys in and return them. That is order n. I ca not just say it is log n. On the other hand, if the answers to my list queries are small, if they are one element, then it is going to take log n time to do a binary search and then order one to produce the list if I have a constant size list. If I just say order n I am selling myself short. It is a lot better if I want to have short queries. What would be the best possible running time for lists? If I had a magic algorithm that works as fast as possible would I be able to run in order one time? No. Super fast magic algorithm order one. No, why not? Because you still have to find l and h in your array. Suppose I have some other data structure, a super magical data structure. You can do searches in order one time, is what you are saying. You still have to have the contents of it for what you are listing. It would have to be order i. Even if I have a super magical data structure where I can do everything that I want inside in order one time then when I produce the output I still have to write the output. This thing is going to be omega i and I ca not possibly do any better than that. No matter what running time you have for list it has to include this i. Unless you are running time is order i, in which case i is smaller or equal to n. Does this look right to you? There is a small bug in this code. What if I do count of 4, eleven point Binary search returns, if there is a key there it will give me the position of that key. And if there is no key it will tell me where I should insert the key if the key does not exist in theory. So if this is my array then the positions are 0, 1, 2, 3, 4, five point Count of 4, eleven would do a binary search of eleven and see four and then it will do a binary search for four and return two point Right? Because if I want to insert four I would have to put it here and then shift everything to the right. And four minus two is two therefore it is broken. Off by one block. Off by one block, right? Well the interesting thing about it is that I had this code, we actually shipped this code between Saturday morning and Sunday evening and it passed all the tests. As we go to the next section keep in mind that this is broken but it would still pass the test for our problem and we will see why in a bit. . Count of 4, eleven point So confined to them then it says that when you are down 5, right? Four. Four. Binary search, if it finds the key it returns the position of they key. four divided by x, and 4, four would it have had two? Yeah, because it tells me where to insert it. OK, then it is.  Well it says four minus 2, right? The last line is high index minus low index? Oh, well that is wrong.. So are you saying that it tells you where to insert it instead of actually inserting it. Yeah. Binary search does not insert the element. It just tells me this is where you put it. And then if you look at add, add inserts it right there. That is why binary search is done that way so that that would work. Can I ask a style question? Sure. The underscore before binary search, is that like saying private? Yep. OK. Wait, what does private mean? Private means that it is not part of the public interface of the class. If we are in a team and we are working on something, if I mark a method as private that means if you use my class, you are not supposed to call it because I might change it is name, I might delete it completely, I can do anything I want to it. But if the method is public, so add, remove, list, and count, those are the API or the public interface of the class. I guarantee that as long as the blit range index class exists it is going to have an add to remove a list and the conduct will behave in exactly in that way. Once you have a class with public methods you are not supposed to change them because other people might depend on them and that would make other people unhappy. We said that this range index holds wires. Right? So if you have these wires here they are not really numbers. I know how to compare numbers, I do not know how to compare wires. That is not something that is readily comparable, right? We have to bridge the gap between numbers or things that are comparable and wires. The way we do that is the key wire pair class. If you look at key wire pair class it has I will write it as KWP here. So it has a key and the wire. Right? That is why it is a key wire pair. And if you look at the comparison methods, lines eleven through 26, but if you look at eleven through thirteen pretty much everything else is the same. Then comparisons are done in a certain way. So the first criterion is the key. If you have two key wire pairs that have different keys, then the one with the bigger key wins. Now if they have the same key then this field called wire IDs is used to break ties. So first key and then wire ID. What is the wire ID set to? And where? Where would you set a field in a nice class? The constructor. In the constructor, very good. Where is it set? Line number? ten point Line ten point So the wire ID uses the same object IDs that we had earlier. So each wire has a unique ID that is between zero and the number of wires. This works when I insert my wires into the index. What is the key for wires, by the way? Where are wires inserted into the index in the algorithm that we have and what is the key? The algorithm that we gave you. Yes. The y coordinates. The? Which one, I could not hear you. The y coordinate. The y coordinate. Can you tell me which line? The intuition is very good. You want the wires to be keyed by the y coordinate so that when you a range query between this guy and this guy you get these wires. That is the intuition. Now what is the code? Line thirteen point Line? I did not hear you well. Line? thirteen point thirteen point Wires are added to the index when an event of type add is processed. Right? Line twelve says if event type is add so that is probably what we want. And line thirteen adds it to the index and builds the key wire repair with the key, the y coordinate of the wire. Now let is look back at the keys and see that we have two special key wire repair classes. Key wire pair l and key wire pair h. These do not want the wire. Why would I make a wire key pair that does not want the wire? Why is that useful? You have the minimum and maximum wire at ease. Very good observation. The wire ID for the low key pair looks like minus zero and the one for the high key pair look like plus zero as long as I do not have more than a billion wires. What do these things not have? They do not have a wire. So if you look at key wire pair l and h, if you look at the initializers on lines two and eight, they only take a key they do not take a wire. This is useful in which situation? Where do I want to create an index key that is not associated with the real wire? When you want to make the list when you want to do a query. When I do a query. Very good. If I am querying, if I have this vertical wire, which starts from minus eighty to plus eighty then I would like to make a low key that corresponds to minus eighty and a high key that corresponds to plus 80, but I do not have any wire with a horizontal coordinate of eighty point Right? A hackish solution would be to make fake wires with those coordinates but if I make fake wires God knows where my system is going to break elsewhere. Instead the clean solution is to have these key wire pairs so that when I insert wires I have a wire and when I do not the wire is set to none. And the wire IDs are these special values, minus zero and plus infinity. What is cool about setting the wire IDs to minus zero and plus infinity? It is so that if you have a y of eighty this y is at negative zero so it is going to take that y also because its y value is . All right. Cool. If I have a real key wire pair and it has a wire whose coordinate is eighty this is going to be bigger than a key wire pair l with coordinate eighty and it is going to be smaller than a key wire pair h with coordinate eighty point If you do a query using this and this it is going to grab all the wires with coordinate eighty point Does this makes sense? So what is cool about this in terms of coding? Do I have equal keys in my range index? Do I have to handle multiple equal keys? No because, actually in this case yes. Do I? Because if you have all the horizontal wires then it is possible that you have two horizontal wires at the same If I have two horizontal wires, say this guy here and this other guy here, this guy here, what is the key value pair for it? Key wire pair? Let is say the coordinate is minus ninety five and the wire ID is two point The key wire pair is they key is minus ninety five and the wire ID is 2, right? Yeah. And then for this other wire, suppose the wire ID is 10, the coordinate is going to be minus ninety five then the wire ID is going to be ten point So how are they going to compare? Then that one is less than that one. Yup. So even though I have two wires with the same y coordinates of the key as far as the algorithm is concerned is the same, in the implementation the keys are artificially different because I introduce an artificial ordering on the wires using that wire ID. In Which case would I have the same key inserted in my index twice? Yes? . OK. If these two wires overlap, say this guy ends here and this guy ends here, and if I put their keys into the index they are still different. Only if they are the same wire ID would they have the same OK, and when do two wires have the same wire ID? If one of them was negative infinity. Let is assume that the infinities were in the right way. Yes? No? Wire IDs are unique. Every wire has it is own wire ID. Wires will never have the same wire ID. So the only case in which you have two equal keys in the index is if you insert the same wire twice. Would you ever want to do that? Probably not. You are going to the same wire twice from the range query and that is not useful. When implementing a data structure for the range index we do not have to deal with equal keys and that is nice because that is less thinking. Now when we do a query, will the keys in the query be in the range index? Not necessarily. How would I do a query if I want to do a query from minus eighty to plus 80? You grab all the horizontal wires whose y coordinates are You are thinking in the range index. I am thinking as the client of the range index. So you have this range index class, how would you issue a query to the range index? The list on this page. OK. I would call the list method. And oh crap, I thought I was going to avoid doing that today. l and h are keys, right? How do I construct my keys? Use key wire pair. Key wire pair left of eighty sorry low, and key wire pair high of eighty point So then I am going to get to these I do not have wires for this eighty coordinate. Sorry, minus eighty to eighty because that is what the query looks like. I do not have wires for these coordinates so I am going to use these special values and this one is smaller than all the wires with coordinate minus eighty and this one is bigger than all the wires with coordinate eighty point Will these keys ever be in the index? Nope, we are only using them for updates. If you put this in the index then when you are getting it back and you try to get the wire associated with it you are going to get none, your code is going to crash. If I have a query will the keys in the query ever being the index? No. No. That means fewer border cases to consider when implementing query. All the keys in the range index are different and they keys in the query will never be in the range index. When you do the count l and h are not in your range index you have to count that. Yeah. In this case that is why the code did not fail any test. Because I am not using numbers I am actually using this. So for the number analogy this is equivalent to when I am doing a count of 4,11 that would get rewritten as count of 3, ninety nine and eleven point zero one and this works. This is what these two values are doing. Except if you try to do zero point nine nine and zero point zero one that is brittle because you might actually have those keys. All right, does this make sense? Any questions on this part? Nope? Yes? Yes. Is this thing in a count off situation where you have a gap in the wires but you still have a associated with it as it is going through it. Sorry, say that again. So with that example right there. Yeah. Are you worried about the fact that I will have two equal keys or are you worried about the fact that these wires are crossing? No that they are not overlapping. You have a wire and you have a wire coming down and you have another wire. OK. This is not going to account for that. You have to write the better sweep line algorithm. OK. What I am talking about now will make your range index faster. Or it makes your range index simpler to implement. OK. This is magic behind the scenes that makes your code smaller. You still have to implement the sweep line algorithm that makes sure that when you a range query it will either return less false positives or ideally no false positives. And then the code will be faster. But then when you do that, you will see that it is still slow because the range index that we have here is not optimal. Why is not the range index here optimal, by the way? What can I improve about it? Add and remove. Add and remove. OK. We are using the comparison model because it is convenient to use the comparison model. You have complex objects to implement those six methods that you see in key wire pair and bam. You can do comparisons, you can use any data structure or algorithm that assume a comparison model. What is the penalty of the comparison model? What is the problem with it? Yes. It will be slower, or it will never be faster than the. Yup. If I want to do a sort that is n log n. And if I want to do a search that is theta what? . Now what are the best bounds that they have for these if we can go outside the comparison model? Just to see if you guys are paying attention in lecture. So best running time for sort if we do not have to use the comparison model. n. n. OK. Best running time for search if we do not to use the comparison model. It is order one with. Order one, with hashing. Can you do any better than that? You can code it as zero. LAUGHING Sort has to output an array of elements so it can be faster than order n. Search has to output yes or no so it has to output something so it has to be order one. So this is as fast as it gets, we are definitely not going to go faster than that. We have this extra log n factor that we pay if we use the comparison model if we do not collect more information about our keys. But in return we have the convenience that all we have to do is establish an ordering relationship. Does it make sense? Cool. Let is try to talk about the list pseudocode, which you might have seen on the pset before. And that is on the last page here. I ca not give you a proof of why it works, but we can work together to figure out how it works and get an intuitive understanding. Let is get the keys here and let is assume we are using a regular BSD for implementing a range index. I am going to put my keys in a BSD. 8, 3, 2, five point OK. List those two things. LCA and no list. Right. What is LCA? Suppose I want to list all the keys between one and six. First I am going to call LCA and get some answer and then I am going to call node list. What is the answer for LCA? OK. Node at three. Key value three. What is this? What is LCA? It is OK to give out an answer to a dumb question on the pset. So LCA is lowest common ancestor. Very good. It is the lowest common ancestor of what? Subtree of values that should be returned nodeless. So usually you have two nodes in a tree and you want to return the LCA. If I want to find out the LCA of two and 5, that is three point If I want to find out the LCA of two and 13, that is eight point Now if the keys are not in the tree what does the LCA give me? It is where they would be. It is where they would be if they were inserted. Right. So one would be inserted here and six would be inserted here. And then their LCA is indeed three point What does that tell me? Why is that useful? You can cut off a bunch of the rest of the tree so you do not have to look at that. A bunch of, or the rest of the tree? The rest of the tree. The rest of the tree. So if one is here and six is here, then I know that all the keys sorry, so three is to the left of eight so all the keys to the right of eight are going to be bigger than 6, for example. Right. Because six is here and it is under eight point I can throw this away. Now if this would be to the left of something else, because one is here I know that all the keys to the left side of that thing would be smaller than one point This subtree has to have all the keys between one and six point Yes. You do not have to move 8, right? Where would you move 8? Yup. So we only look at the subtree rooted at LCA. LCA is passed as an argument to node list, and node list seems to do sort of an this is a pre ordered traversal. You look at the key, you look at the left node, at the left subtree, you look at the right subtree. Except there is some magic there and in some cases it does not go and look. Let is see what would a good case where it does not go and look like. Let is get the same tree. Suppose I want to do a list between four and eleven sorry between four and ten point We will the LCA of four and 10? Eight. OK, so node list would have to start here. Suppose I am here and I go to three point I know three is smaller than four point Do I want to go left? Everything to the left of three is smaller than four point This entire subtree can be pruned. Now suppose I am on the right side and I am at the eleven point eleven is bigger than 10, do I want to go right? So if eleven is bigger than ten I never want to go right because everything to the right of that is bigger. OK so this is how pruning works. Now if I am at 3, can I stop? I ca not stop and exit completely because on the right side of three I might have keys that are bigger than three and that are in my interval. And in this example that seems to be the case. Let is look very quickly at the intuitive way of analyzing the running time for this. Suppose I have my LCA up here and suppose I go on a path from LCA to L and then let is not worry about the right, about h. h is somewhere here, the case is going to be symmetric. When I go down the path, after I go here would I ever want to go left? If this node is before a right turn then I know that l is going to be bigger than that node. Right? So I am never going to take a left turn. This subtree be pruned, this subtree will be pruned, this subtree will be pruned. Now if I go right here, what happens? It is node All the nodes here are going to be between l and LCA. LCA is smaller or equal to h so all these nodes here are guaranteed to be nodes that come out in my list. All right, why am I doing this? I was saying before that I absolutely have to have an order i because I have to produce the output list. If we look at the lines three and four, line four outputs a key right? Line four is definitely order i and line three is an if condition so we know for sure that line four is only going to execute four keys that are between l and h. This algorithm is going to visit some nodes in the tree. For example, if I have a list of four and ten it is going to visit 8, it is going to visit 3, 5, and eleven point And for some of the nodes that are visited it is going to output them. Right this guy gets output and this guy gets output. The nodes that are outputs are order i. Those are already covered in the i term. And in order to get the running time what I need to know is, how many nodes do I visit that are not part of the output. Because if I end up visiting the entire tree then that is order n plus i. So order n. But if I only end up visiting a few nodes outside of the output then that might be a lot better. And here I am trying to argue that I will only visit a few notes the outside the path. In fact, for every node I am going to visit at most of the node and the node at its left. And then everything to the right of the path is between l and h, so everything to the right is going to be output. Everything here is in order i and everything here is visited in that output. And potentially everything on the path as well. So what is the height of a path in a binary search tree? Regular binary search tree? OK, and worst case. So worst case the height is order n. But we usually call it height because on average, at least, it is log n. It is somewhere between n and log n. What is the running time for lists in a binary search tree? If you buy this argument here. What is the running time? . You could say n plus i and you are perfectly correct. But we can make it a bit better. What is the height of this path? h. H. What is the running time? h plus i. OK. Cool. Does this make sense at all? Is this too complicated? That is the running time for what? This is the running time for lists. All right so, questions? Is this too far out? Did I lose you guys completely? Makes perfect sense. I like that. It is oder n plus i because it could have up to any nodes on it, right? Yup. And then it is order i because you have to add that of nodes anyway. It is order h. I am saying that it is a binary search tree of height h and if h is better than n then I am going to do much better than n and that is why I am putting that h there. OK, that makes sense. I think it is just a ltitle confusing at that part, but the makes sense because of course that is a smaller node you are not going to look at the left portion you are going to look at the right because it is bigger than your smaller, right? So if you go to the right, that means that Here I know that l is on the left, right? So l is smaller than this key. Everything to the right of this key is between l and LCA. LCA is smaller or equal to h. Everything here is between l and h, so all the nodes here are going to be output. All the nodes here count as i. OK. Now when I turn left here, this is smaller than l. This is smaller than l because l is on the right. This thing is going to be pruned. So I will visit the parent, this node, and that is it. I am not going to look down. And this is how the nodes look like. Everything that is to the left of the path is not visited, everything that is to the right it open. Any more questions? I hope you get it right on pset then. Thanks guys. 
</body>
</html>