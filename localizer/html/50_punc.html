<html>
<body>
In the last lecture we looked at stacks as a data type. We saw how to implement stacks using an array. Today we are going to look at queues and linked list and then later part the class today we are going to do sequences. So in particular the first part of the class today i am going to do queues linked list and double ended queues. What is the queue and how it is differ from the stack? So if you recall the stack follow the last in first out principle, the element that was inserted last in to stack was the one that was removed first. Queue on the other hand follows the first in first out principle. Whoever joins the queue early earlier is the first to be removed from the queues to be processed. so you are all familiar with queues. The elements in a queue, for instance here notion of a first element and the notion of the rear element. When an element inserted in to this queue comes here at the rear. When an element is removed from the queue. the element or if i remove the element from queue it is the element which is sitting at the front rear, so this is the elements which get removed . there is no notion of which you are all guilty of so we always insert an element at the end. When we remove an element it is always the element at the front. So, the queue is also an abstract data type and we can define a few methods on the queue. These are the standard operations you can think of one would be to create a queue the method new would create a queue. Enqueue is the method to add an element to the queue and dequeue is to remove an element from the queue. When you dequeue a queue or when you remove an element from queue you get another queue. the front is the method which gives me the first element of the queue. How it does differ from dequeue? It does not remove the front element it only tells me which is the element at the front end of the queue. Beside we also some other support method to implement the queue and one could be size and one is an empty size would tell us how many elements of the queue and empty would tell us whether the queue is empty or not. So it would return the true if the queue is empty and false otherwise. And just as we define axioms to the case of stacks you can define similar axioms now for queues. If i have create a new queue and i insert an element or enqueue an element v and then say what is the element at the front of the queue then it should be v, you understand why this is true. suppose i create a new queue enqueue an element and i dequeue an element. there is an extra queue here i dequeue an element then what should i get? I should get the empty queue. which is the same whatever obtained if i just call new. Similarly here if i had a queue and i enqueued an element w which means i added an element to the queue, then i add an another element v two the queue. So which is coming before which is coming later w is ahead of the queue ahead of v in the queue. no if i call front then what should i get so what so first you have w all the elements of first you have all the elements of queue followed by w followed by v. so which is the element of the front at the front of the queue, whichever is the element in the front of Q,w Why I have written front ofQ,w not front of queue? If queue is empty because if the queue is empty then this would not if i just written front of queue here that would not been defined. if a queue is empty then there is no notion of front of the queue that is why i have written queue comma w front of enqueue Q,w. So same thing before I had a queue Q, if I insert w in to the queue then I insert a v then I removed an element. Which is the element it gets removed which were the element at the front of queue. And if was the queue was empty then it would have been w. So then this operation is the same as saying that I had queue a Q, I removed w, I added w to the queue then i removed an element from the queue. Then I add a v again queue that have obtained as the result of these procedure should be the same. DequeueEnqueueEnqueueQ,w,v equal EnqueueDequeueEnqueueQ,w,v let us check it out. let us assess that queue was initially empty then what is this Dequeue Enqueue Enqueue Q, w, v gives me? First I added w then added v, then I removed an element, if i remove an element what i get w is removed. What should I get the remaining queue as v? Let us look at this Enqueue Dequeue Enqueue Q, w, v. now queue is empty, I added w to the queue then, I removed an element so once again I left an empty queue and then I enqueue v,so queue v in it. So if queue is empty then it is both cases queue have v only in it at the end. If queue is not empty, then when i enqueued w then I enqueued v again. So I have a queue which I have first all the elements of Q followed by w followed by v and then when I dequeued, what should I left? left with the Q without the front element the original Q without the front element followed by w followed by v. Let us thing if we get the same thing here Enqueue Dequeue Enqueue Q, w, v. I started with Q I added w to it. Now I have Q and w then I dequeued which means i remove the front element of queue. so I have the queue no contains all the elements queues except the front then i have w in that queue. Now I added v at the end so I get the same. how do we implement a queue? We are going to use an array to implement the queue, we are going to use in circular fashion. What is that mean right? Suppose some1 tells a this queue is never going to be larger than n elements. I am going to allocate an array of size N i am moving to have two variables f and r f for front and r for rear. F is the index of the front element of the queue. We were the front element is in the queue f will be referring to that position and r is an index which is the element following the rear element. So as you can see refers to this location, this blue part is the part occupied by the queue. How do dequeue reached this place I would have started with the front rear. The first element I insert must have come here. then the next element I inserted must have come here. Third element inserted must have come here and so on. But then I am also deleting an elements when i am deleting an element goes away. So in effect the elements the queue kind of drift right and so we are now at a stage where the front element is here and the rear element is here. this implies essentially that we have kind of deleted f minus one element. Let us say queue begin not accurate completely accurate the statement you will see what I mean by. I had said something like in a circular fashion what is this mean and why I am saying such a thing. so let us say we can inserting an elements this queue I insert another element inserted another element i inserted another element and now i cannot insert anymore elements right because have already reached at this end of the array. But I have a space available here in the front. so what I will start doing will rap around will start and setting the elements. And this will what happen right you can some point look like this This is now the front. You recall in the previous slide it was to the left of the rear but now front is to the of rear because we have queue is now starting from here and i am going like. now when i insert an element is still it will come at this location. The first element will come at this location. Everyone with me. Initially a queue begin, so now when we started front was referring to this location. Where was referring to when we begin front have refer to rear have refer to f should have been minus one. because the front is refer to first element of the queue there is nothing in the queue f should be minus one and rear refers to zero because rear refers to an empty location . So what does if at some point i reach at equeueuation, when f equal r what does this mean empty or full? When it becomes empty what will happen? Suppose now at this point starting from this point i kept removing the elements starting from f th location, i did not add any other element i removed all the elements before r th location. Now where would f be? F would be increment to r, so f becomes r. When f is r queue is empty. But suppose i incremented i kept adding elements. So when i add r will move one step r will move another step so on . when i add a element here then r would be pointing would be referring to here. So again f equal r we will not at the nth element right that is what we are going to do. so there is ambiguity here so we have to resolve this in some manner. f equal r mean both empty and full. Since we will have a problem if you donot know the queue is empty or full. We will try and ensure that we never had n elements to the queue when the queue has only n minus one element we will declare to before. so that is what we are going to done Let us look at the code for enqueue. So this is just pseudo code if the size of the queue if the nber of elements in the queue is n minus one. Then we are going to stop,we are going to say the queue is full. we written the queue full exception otherwise such not a case then add the rear location put the element that you are trying to insert yes and increment r Why this modN require? We need to do the rap around its circular, so rap around. Indices goes from zero through n minus one only when I increment r, r is already n minus one and I increment r at this r plus 1modN, then I do not wanted to be become n,I want to become zero point So n mod zero. Size is the method so this should have been sized bracket yes thank you. What this method size two it returns this value, why should have not written just r f? So r minus f it is negative in this setting, but in this setting r minus f tells me exactly the number of elements in the queue. So r f is the correct thing except it might be negative. how many elements are here? Now in this queue N minus r plus f. so i have sorry it should be N minus f plus r whatever one of these things. so this would be the number of elements that would you get. So this queueuantity always be positive because r minus f can at worst be minus. So N plus r minus f would always be positive queueuantity. So you can return this N f plus r as the size, this will tell you the right number of elements. Check this out if your confused, is empty this is a method and we said queue is empty f equal r. There was an ambiguity recall so we said but we will never have more than n minus one element with queue. So f equal r, that means the queue is empty not it is full, f equal r return empty will return true for this method. For front if the queue empty then raise an exception otherwise just return to front element. We are not removing the front element done here. In this case we will increment the front index and remove the front element by setting Qf null. This is clear to everyone, any questions. You can also implement the queue using a linked list. So we saw array to implement our queue . The disadvantage of using an array is fixed size. If you knew what the maxim size of the queue you can take, but if you have no idea what maxim size could be, you could either use the method did in the last class were in in the size its increases what we have allotted then we double the size of the queue You could either do that or you could use an implementation which uses a linked List. I assume all of you familiar with linked list from your previous course. So what essentially linked list? It has nodes and it has pointers, which are basically referring to the next nodes list. This is also referred to as a head of the list. This is referred to as the tail of list and each of the node has a some element some data in it. If I am go to use a linked list implement the queue, then question is which this should be the front of queue. whether this head node should be the front of queue or this tail node should be the front of the queue. The head of the list to be front of the queue . The tail of this list cannot be the front of the queue. Can someone tell me why the tail of the list cannot be front of the queue? Why cannot I have my queue in the1st element is this, the 2nd element is this and the 3rd element is this? Element remove exactly, so the problem is the removing Note that I cannot remove this tail node element, the linked list does not permit me to do this. Can I remove this tail node element from linked list? Not directly, why not because to remove this element I have to change this pointer. But no way of accessing it pointer. I cannot remove this tail node element. I can remove this element head no problem but i cannot remove this tail And in a queue removal is being done in the front,We remove the element the front of the queue. So since I cannot remove the element which is sitting here i cannot call this as the front of the queue. I would like to have this as the front of my queue. Let us see how we are going to implement from methods. So suppose I have to dequeue, which means this is now the front of the queue is to your left. This is the front of the queue this is going to be the rear of the queue. So if I have to remove the element at the front of the queue dequeue, what should i do? The head should now point here this front element will get removed. So I just increment just making the head point to this element now. So in this manner I can delete the head very easily I can delete this element very easily. I can also insert a new element head very easily I just create a new node connected here make the head point to the new node. So inserting the head is also very easy. Everyone follows this dequeue operation right. This is the front of the queue I can just kind of move the head to one step right and in that manner remove the front element to the queue That will also need to be done If I have to add an element enqueue an element recall enqueue has to be done rear of the queue. This is my queue this is the rear queue I need to add a new element here I need to add an element. This pointer should now get modified to pointer this element and tail should be update to this point because this will become tail and this pointer should be null. I can always add an element at the tail and the question we discuss just now it is difficult to remove an element. You cannot do in constant time. Because if I want to remove this node, how we remove this node? Because to remove this node I need to access the previous node. So the only way you can do it this kind of list to start from the beginning and go all the way to the right till you get to this and then you will be able to access the previous node. His question is what is the problem in removing in this node? From here what is the problem in removing? The problem in removing this node is that after I remove this node what is the new tail of the list? Is this node I have to make this point to here? How do I get to this node here? I need to go through the entire list to get to this node very expensive. I am not saying it is not possible to do it is a very expensive operation. It is not worthwhile to remove at the tail and so we will remove at the head and at the tail, which means the front of our queue will be at the head and the rear of the queue would be the tail. So that is the far as the queue data type is concern. Now I am going to introduce another data type is called double ended queue. What is the double ended queue? It is queue in which we support insert and delete operations both ends. So now we have insert first insert, last remove, first remove, last insert at the front of the queue and insert at the end of the queue, remove at the front of the queue, remove an element at the end of the queue. We have the element operations first and last also So such a thing is called double ended queue. Both ends we can do both the operations. And as you can see a singly linked list is not a good idea to implement such double ended queue. Why because said repeatedly we cannot remove the element at the tail or it is expensive . what is the good solution to this problem? So we are going to use what are doubly linked list to implement double ended queues. First what is the doubly linked list? A doubly linked list it has nodes with two pointers one next pointer one previous pointer We are also going to have two sentinel nodes here I will come for the minute. But each node has two pointers one pointing to the next, one pointing to the previous. Know using such a list you can implement all the operations of double ended queue in constant time, why? Now the problem is earlier if your recall was, how I delete this node which is at the node how do I delete this now? So these are two sentinel nodes I have pointer to these nodes, how do I get to this element? I just follow the pointer once and get to this element. How do I delete this now? Move to the previous port and set is next pointer to trailer and sent the previous point of trailer to this node perhaps applied on this. So we need header and trailer nodes in a doubly linked list. These nodes are called sentinel nodes and dmy nodes. They do not contain any data inside in it. They are just dare to mark the start and the end this is useful. How do you delete? We come to that in a second. So that is the answering his question. How do you delete at the end right? So I have to delete san franchiso right out of this list. All I have to do is makes this pointer to here and then this node his out this becomes my new list. So that was the only thing I am not do in a singly linked list. So I have shown you, how to do it here and so all the other operations understand also can be done in constant time. Any questions? So using a doubly linked list we can implement all the operation in constant time, all the operations of double ended queue. We can insert at the front, insert at the end, delete at the front, or delete at the end, all in constant time. What does constant time mean? Time which is independent of number of elements in the list right your running time will not be depend upon. Now double ended queue is a fairly generic data type it can used to implement other data types also. Suppose you had an implementation of double ended queue, you can use that two make a stack or make a queue. So I have an implementation of a double ended queue, I can use the methods of this implementation to implement a stack. Let us say we keep the top of the Stack we make the top of the stack correspond to the last element of our double ended queue. So the method top would correspond to return given me the last element double ended. The method push would not correspond to inserting at the end of my double ended queue. And the method pop correspond to deleting at the end of my double ended queue is nothing sacrificing about last year I could also make this correspond to the front element of my double ended queue . In which case this could be have been front this would have been third front and this would have been removed first You could use it either way you like it. And size just corresponds to the size of my double ended queue is empty corresponds to is empty double ended queue these are only depend upon the nber of elements in the queue. Similarly I can use double ended queue to implement the queue. So now front would correspond to the first element of double ended enqueue. what I do in enqueue? I insert at the rear. So it corresponds to insert last. When I say dequeue I say remove from the front So remove the first element of double ended queue. So if i implement if i dequeue implementation I can use the methods two implement a stack or a queue or one of these data types. Any questions? So this is the notion of an adapter. We had used double ended queue to implement a stack or queue this is an example of adapter pattern. So adapter patterns implement a class using methods of another class. So in general adapter classes good specialized general classes and we can have applications, this one application would be implement as we just saw an implement by changing some methods. We can implement for stack double ended queue. Another application would be for instance in the last class, we saw an implementation of a stack. Using an array stack we define an interface called stack implemented using an array that implementation called it an array stack. And what are the contents of array stack they are any arbitrary objects and I can adapt this implementation to an implementation called integer array stack which only use as integer objects in it. So all i have to do is change the suitably cast the type of the objects that i am pushing in to this stack or removing of this stack. Another data structures called circularly linked list and its very simple in this the last element is pointing to the first element of the queue of the list. So there is only one pointer which is pointing to. So there is no two pointers first stack head and tail so there only one which points to the start of this circular list and you can use this data structure to implement both queues and stack also. How will you use this implement a queue? In a queue once again this is the front the queue the rear of the queue makes this front of the queue and the rear of the queue is this. When I have to insert an element to this queue, I have to add an element What should I do, How will I add an element at the rear? I will add an element, lets say here in head pointer I will add an element here what should I do? Makes this pointer point to this guy and make the head point to, it is not straight forward because if you do mean that how make this point to the new node you have just created that has to be done. After all what we want? We want to create a new node here. So this will become the new node that the element you are inserting will now go in to this node make it going to this node and create a new node and copy this element to the new node. Make the head point to the new node copying is not costly because here only copying the reference. Think about this it is very straight forward. So in this manner you can insert an element in this queue if you are using this implement the queue. To remove an element, removing an element corresponds to removing the first one How do you remove the first one? If I have to just remove this element here then how do I make this point to this problem What do you do again? Lets remove this one node and copy the contents of this node to here. We have to remove the rome. How do I remove the rome? I copy seatle to rome. So this now seatle as in is and I remove this node Copy here means just changing this reference So that is all I want to do discuss about queues and double ended queues. So now we are going to this second part, we will quickly look at some sequences. So vectors you are going to talk about vectors you are going to talk about positions you are going to talk about list and general sequence. So they we will be using the data structures that we have seen so far arrays and linked lists to be implement this data types. What is the vector data type? Vector data type is sequence of n elements its support these methods. So these are indicated methods, these are not all the methods. So essentially in a vector, it is a sequence where there is a notion of rank every element of this sequence. So think of sequence of elements. 7,11,13,19. We know that seven was the first element and eleven was the second element, thirteen was the third element and maybe I said five as the fourth element. So with each element there is a notion of rank and then I can have a methods like Give me the element at rank r. So rank here corresponds to, let say rank or integers So 1st element was element at the rank 1, 2nd element was at the rank two and so on. So suppose I asked, give me the element at rank r or replaces the element rank r by the element e, insert an element at the rank r, insert the element rank eat rank r or delete the element at rank r I could have such methods. Great so what happen think of rank as for instance, lets say the rank of student in a particular class there is departmental rank one the departmental rank two and departmental rank three so on. Suppose departmental rank four does department change goes to some other department. Now who has the department rank four now whoever had rank fifth here. So the same notion. So every1 would move up by one rank. Lets see how to implement this data type. What you think as a natural data type structure could be one data structure implement this data type? You can implement using arrays lets see an implementation using arrays. So what I am going to have, I am going to have this array in which I will have the element with rank one element, with rank two element, with rank three so on. And now if I have to insert an element rank r so in think. Is this going as element as rank zero and lest say mean from zero. Rank zero rank one if I have to insert an element rank r, what is the think I have to do? I have to put an element here which means that I have to shift all these elements once step to the. So that is what i am doing here then put an element here. What we are doing in a for loop we are moving first n minus one we are moving step to the right by this statement S i plus 1 minus and we are doing this first n minus one then n two is moved one step to the right all in all. R is moved to the one step and then finally element is pushed r and the size of the thing is increased by one. N suppose stores the size of vector Sr minus e n n plus 1 Similarly when I am removing an element rank r, I am essentially shifting all the elements one step to the left. All elements starting from r to n two. So Si gets S i plus 1. The element at location r,here I will get the element which was sitting at location r. How expensive are these operations worst case? Order n in the worst case. Because we might have to shift up to n elements to right or to the left this implementation is expensive from this point of view. Do these two operations insert certain rank remove certain rank I have to in the worst case order n time. The other operations are faster. Element at rank r, how much time its take? Because I just go to the rth location in that array and retrive the elements sitting there. Replace at rank r r, e again order one because just go to the rth location and replace with element e. The chart shows you the time complexity of various methods all methods except inserted at rank and remove at rank take constant time these two methods could take order n time in the worst case. Can you think of some other way of implementing this thing? A Doubly linked list, you can use doubly linked list vector? So I am showing here operation of inserting at a certain rank. Now what is the rank? This is the header, this is the element at rank 1, This is the element at rank 2, This is the element at rank three. So now suppose I want to insert an element insert at rank two. what I am going to do? I have to make a new node and put it between one and three point How much time does it take? So everyone understand the process of insertion. Create this node, how do I insert? I make a point to this node, makes a previous pointer point to this node and next pointer would point to this node. This is how I insert, this what I get after insertion. There are two issues first if I have to insert, then I take constant time but to find out where I have insert take order in time. Because if I say inserted at rank seventeen I have to step through that linked list goes seventeen position then I would know to insert this location. Once I have to know insert at this location, it is easy in three or four pointer changes which I have to do to insert the element So this would be java code for inserting at a rank. Now here I am assuming the existence of this procedure node at rank. This is the method that I am going to be finding shortly. what does this method do? Given a rank it tells me which is the node at that rank. So for instance here to insert this node at rank two first I will call this procedure with rank two it will give me this node it will give me this node, because this is the node at rank 2. Now what i have to do? I have to get to the previous node of this node. I get this node at rank 2, I get to the previous node of this node so this is the node at rank, previous to rank two which is at rank one and the new node that i have to insert has to be between this. So this is I create the new node and I set its previous field to refer to the previous node and I set its next field to refer to the next node. DLNode next equal nodeAtRank rank DLNode prev equal next. getPrev DLNode node equal new DLNode element, prev, next DLNode prev equal next. getPrev This was the node at rank one DLNode next equal nodeAtRank rank,this was the node earlier at rank 2. So In this manner I create the new node at the appropriate place and then also need to check the previous and next field of this node, that is what I am doing here. next. setPrev node Prev. setNext node Size plus plus Do not get intimated by this code, it is just showing here in the picture that is all. All I am doing is assuming the existence of this procedure DLNode next equal nodeAtRank rank in which given rank will tell me which is the node at that rank in the original list. Please do not try to copy this either, these slides will be available on the web. Now here I show you the process of deletion. So if I have to remove the element at a certain rank. How i do that? Suppose i have to remove the element at rank three. So once again I will first find out the node which is at this rank. So I get to this node and then all I have to do is go to the next node, go to the previous node and update their next and previous pointers. So this will now point to this and this will refer to this manner get I will rid of this node and this I will have end. And similarly I can write down the java code for doing this, once again I am assuming the procedure node at rank given a rank tells me which the nodes is sitting at that rank. Now how do I implement this procedure node at rank? well there is nothing else I can do except that array except march to the list and find out and keep incrementing my counter till I reach that rank. So I have done essentially that except is small improvement. If the rank is else than the number of the size of the list by two then I start from the header and if it is more than size by two I start from the tail just to small improvement nothing more You do such a thing. Because if your list has hundred elements and you are looking for the element rank ninety eight then there is no point to staring form the header it is better to start from the tail. So that is far vector, the vector data type concerned. Except that when I say rank remove the element at a particular rank or insert the element at a particular rank. As you have seen both implementation we have problem. Whether we use array or a list to do that implementation we seem to require order n time in the first case just to we able to in the list, just to be able to find out where that element is, where the element correspond to that rank. And in an array where we know the element corresponding to that rank is we have to move the elements when we insert to delete. So linked lists are better in supporting node based operation. I have to linked list, I tell you this node delete this node. If it is doubly linked list you can delete that node in constant time or if I say insert the node here or I say this is a node. insert a new node after this node I could insert a new node after constant time or if I say delete the insert a node before this node again I can insert a node to do in constant time. So we have the data structure which is very efficient which can do constant time operations provided. We give it access to the node somehow I access the particular node at which we want to do insert and delete. So that is why I mention here. removeAtNode Node v and insertAfterNode Node v, Object e you can remove at a node or you can insert after a node, you can insert before or node all in constant time. However when I give you access to a particular node then in some sense I am also telling you how I have implemented my list whether it is a doubly linked list or a singly linked list and what are all you know, what are the pointers and stuff like that. Suppose I want to hide all the things information so that you can still use node based operation without knowing the actual implementation how the thing was done. So that one can have many different implementations. So we are going to do this using a notion of positions. Positions is the abstract data type which intuitively capture the place where certain elements is stored in your data structure captures and there is only one method which is associated with position and that is the element is the method element. So given object of this data type position I can only call this method element on that object. And that will return to me, that will tell to me what is the element sitting at that particular position. If this is not make much sense think of position as a reference to particular node, think of it as particular node. You are familiar with pointers, so think of it as a pointer which tells you. But all you can do using that pointer is access the element that is situated in the node and nothing else. You cannot use that pointer to update or previous fields you do not even know this node is implemented. Whether the implementer has doubly linked list or singly linked list or a circular list we do not need to know any of that. It is an abstract data type which hides all of these details and you can only use the method that element on the abstract data type position. And with the notion of position they will be related all the positions in the case of a linked list. There is the 1st element in your linked list 2nd element and the position is referring to the 1st element, 2nd or the 1st node 2nd node or the 3rd node. Similarly 1st position the 2nd position the 3rd position and so on. So given a position there is the notion of the position before which refers to the node,before that position and a position after that position. And we can now define a list abstract data type which uses this position. So what would this abstract data type have? It would have generic methods like size and is empty, it could have query method. So given a particular position I can have a method which asks the 1st position of my list. If it this will say yes and otherwise say no and whether it is the last position of the list I can have excessive methods which say first, last. before and after. The first will give me the first position, last would give me the last position, before p will give me the position before this position p and after will give me the after this position p. I can have update methods like swap elements become a key what does this do given a position p and queue it swaps the contents of these positions whatever are the elements sitting at these two positions it swaps. I can replace the element p at the replace the element at position p with e. And similarly I can insert the element e at the very first position I can insert the element e at the last position and so on. And using a doubly linked list you can actually implement all of these methods in constant time. So the list abstract data type is just you know is your same as your linked list data structure except that we are getting a abstract data type implementation. We are trying to capture all of those methods that you can do on a linked list as an abstract data type. Now this data type can be implemented using a double linked list methods you can do on a linked list as an abstract data type. Now this data type can be implement using a doubly linked list. It can be implement using a singly linked list except that it perhaps more efficient implement using a doubly linked list. Using a singly linked list some of these methods might take linear in the worst case. Finally we have the notion of a sequence abstract data type. So we talked of the vector abstract data type where there is a notion of rank associated with each element list data type. Where there is notion of positions and the sequence abstract data type has both it combines the vector and list abstract data type, it is inherits both of these interfaces. So it is multiple inheritance and besides the method that listed for vector list abstract data type has two additional methods which kind of suite connect from one to another. Given a particular rank r it will tell me so the method at rank return me the position correspond this rank. And given a position p the rank of method will tell me the rank corresponding to this position. So you could have an implementation of this kind for a sequence. What is this? This is an array each element of the array refers to so this is the position and this is same as this. This will give the particular location I can identify what rank corresponds to looking at this element. So now how this method implement rank of p. P corresponds to a position A position here is one of these thing. So given a particular position how do i know the rank corresponding to that position i just look in to this element that this rank corresponding to this position. Given a particular rank how do i determine corresponding to that. Suppose you gave me rank one. I follow this reference this is the procedure position corresponding to this rank . At this position there is an element store what is the element in this case newyork. At this position besides the element there is something else which kind of provides of cross reference. So at each of these positions i have an element store and a rank of that element in my sequence. Now suppose I had to insert an element certain rank what could I do? Insert an element at rank two. Can someone tell me what I have to do? So if i have to insert an element at rank two. I am going to create new position the element would sit in that position and this would refer that position and of course all of us these will have to one step other. Not only have move to right what else have to change the ranks will change rank move step to the right to go and update this. So again inserting at the particular rank will take order n time of the worst case. Similarly deleting an element. If I had given particular position if I wanted to delete the element that position, what would I do? How do we delete an element at certain position in the case of doubly linked list. You need to think about this the leave as an exercise. So this is comparison of sequence operations you can implement a sequence using an array. The picture I shown you previously and you can also implement sequence using a doubly linked list. This would be set of in the worst case of running time. So as you can see in the case of an array implementation. If you want to insert an element certain rank or you want to remove an element certain rank it will take order n time. Now if you want to insert after or insert before a certain position. This will also take order n time and if you need to remove an element at a certain position. This will also take n time, not so in the case of doubly linked list. Then you can just zap out the element from there. You can just update the pointers before and after and do these in context time. But then what becomes more expensive here? Because in a doubly linked list you cannot figure out the rank of an element. I have to go entire list to get to the rank figure out the rank. Any rank based operation will not take n order time. Whether you want to find the rank of n element or you want to find out at the element at particular rank find out the position corresponding to certain rank all of these would now take n order time. So with that we stop our class today. So what we learnt today where queues, we learnt about double ended queues We learnt about how to is linked list and doubly linked list to implement the these data types. Then we also looked at the vector abstract data type the list abstract data type which is essentially a concretization of the linked list data structure. And we also looked at sequence data types sequence data types basically inheriting all the methods of your list data type and your vector data type 
</body>
</html>