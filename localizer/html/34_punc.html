<html>
<body>
All right. So I brought a few problems. They are obviously not the quiz problems, though some of them are supposed to be similar. What I have here might not be what you have on the quiz because we might drop quiz problems or because some of them are just meant to make you think and not to give away the solutions to the quiz. Now, before we get started on this, do you guys have any burning questions or any concepts that you want covered? Based on that, I will select which problems we do. Yes? This actually relates not too much to the Pset. If you are looking at the time complexity to maybe transfer something from one table to another, it takes a lot more time, I would assume, to move the actual item to the new table than it does just to look at your point and be like, oh, there is nothing there. So if you were just going to look through an empty table of size m, the time to look through that empty table, I am assuming, is much less than the time to actually move an item. So you are saying we have m things here. Yes. Some might be nil, and some might have stuff in them, and you are going to resize that to presumably two times m, and the way you do that is you are going to move the elements, presumably by rehashing them, right? Yes. So these elements, at least when we use Python, we do not really store big elements anywhere. If you have a big object, we always work with references to that object. So you remember the address where that object lies in memory, and since the memory is finite and small, addresses are all from zero to a small number, so they are constant. So what you have here is not a big object. It is the address of the big object, so moving is always constant time. What I am saying is let is say that the table is completely full versus completely empty table. It would take more time to move everything out of the full table than it does just to look the empty table, right? Let is see. So writing something here is order one time, right? So moving is order one time. Moving one element is order one time. What is accessing an element in a table in a list? You have a Python list. What is the cost of doing an index access? It is also order 1, right? OK. So order 1, index. Order 1, move. Suppose you have an empty table. How many indices do you do? How many times the index? You look at each one, so it is order one times the length of the table. m. So if the table is empty, you have order m indices and zero moves. Total running time, order m. If you have a full table, how many times do you index in the table? Still order m. OK. How many times do you move stuff? Order m. Total running time? It is order 2m, which is order m. So it does not matter whether the table is full or empty. OK. Just wanted to confirm that. And this is how you do that. Cool. Thanks. Any other questions? Then we will go over problems in the order in which I like them, which is easiest to hardest so that I do not have to explain the hard ones. Warm up problem one. So you have this recursion and you have to solve it, and you get a hint that n to the power of one over log n is 2, which is theta one point So based on the hint, you can see that it is going to involve some math. It is going to get a bit ugly. So how do we solve recursions? Two methods. What are they? Expand. OK. Substitution formally, but basically, we expand this guy over and over again. And? Trees. Recursion trees. Which one do guys want to do first? If you only have one t here, anything works because you can keep expanding it and that works, so we can do either method. Which one do you guys want to go over? Trees. OK. So we start with the first node. The size of the problem is n. What is the cost inside here? one point OK. So this creates one sub problem. What is the size? n to the 12. OK. Square root of n equals n to the 12. You solved it already. What is the cost? one point Do people remember this? Is anyone confused about what is going on here? OK. So two terms, something involving t and something not involving t. The thing involving t is what we want to get rid of. When we do our recursion tree, whatever is in here goes inside here, and this tells me how this number relates to this number. So when I go from one level to the next level, this is the transformation. n and becomes square root of n, so the transformation here is the same as the transformation here. What is next? n to the 14. OK. Cost? one point OK. Do we need to do one more or do people see the pattern? Silence means one more. If you guys do not speak, we are going to go slow. What is here? n to the 18. What is here? one point Let is hope everyone saw the pattern, and suppose we have done this for l levels, so we are at the bottom. What should the cost be at the bottom? . Sorry. We do not start with the cost. What should the size of the problem be at the bottom? n to the one over two to the i. Let is say that this is level h, where h is the height of the tree. Do not you want to do something like n to the one over n? Yeah. OK, so we want something that looks like that? If the recursion tree is height i, it is n to the one over two to the i, but two to the i should equal n, or approximately n. Why? I like that, but why? Because you need to go down until you are only looking at one element, and that would be one nth of the problem. OK. So we want this guy to look like what? In fact, it does not exactly have to look like 1, but what is the advantage if we manage to get this guy to look like 1? We have a recursion. We do not have a base case here, right? A reasonable base case is T of one is theta one point Whatever function that is, if you evaluate it at 1, you are going to get a constant, so you can say that. Now, at the same time I can say that for any constant, c, T of c is theta one point So if I take this constant here, which happens to be 2, but that is not to worry about that. If I take this guy here, I can put it in here. And I know that this guy here equals this guy here. So if I can make this guy here look like this guy here, then I am done. Make sense? If it makes sense, everyone should nod so that I know and I can go forward, or smile or something. So this should look like one point This is order one if not one point Let is make it order 1, because it is two in this case. What is the cost here? one point one point Everything inside the bubbles is order of already, so I do not need to write an order of. What do we do next? Solve the equation. two to the. You are skipping one step. That is exactly what you do when you have the substitution method. You are going to get to something and you need to solve the equation. But for the tree, there are two steps. So we need to add up all the costs here and that is the total cost here. In order to do that, first, we sum up over each level. And in this case, it is really simple because there is only one node per level, but if you have multiple nodes per level, you have to sum up for each level, and then you have to do a big sum. What is the sum for this level? one point Come on, guys. You are scaring me. one point one point It is all one point Excellent. So the only thing that I am missing is to know how many levels I have, because the sum is going to be order h, whatever h is. How do we do that? n to the one over two to the power of h has to equal this guy, right? Why would it equal that guy? We know it is less than that guy, but we do not know it is equal to that guy. We have to make it equal because we can only stop when we get to the base case. So we have to expand the recursion tree until we get to a base case, and then we stop, and this is our base case because this is what the problem says should be our base case. Right, but n to the one over two to the h is not equal to n to the one over log n. Well, we can set h to be whatever we want. h is the height of the tree, so we do not know what it is. We have to find out what it is. So let is say two to the h is equal to log n if you want to make it look like that. Let me write down the equation to make sure you are right. You are probably right because you are thinking faster than me, but let me not embarrass myself and do this the right way. So you said two to the h is log n, right? Looks about right. So what is h? Log base two point All right. Log log n. So T of n is order h. We got this from here. T of n is order h is order of log log n. Math people drowning, right? Any questions about this? Yes? The first line on the right This? Yeah. Is that your base case? What is that? We got a hint with the problem that said, n to the power of one over log n is 2, which is order one point So for the base case, we always want them to look like this. If we do not get a base case, we write our own base case, which is if you plug in a constant, you are going to get a constant. And since we are told that this guy is a constant, that is a pretty good hint that we want to get to it. Let is see how we are doing on time. Good. Ready to move on to the next problem? Let is do a fun one. Some people might remember it from elementary school, but this time, we are going to look at it with our six point zero zero six eyes. So suppose you have m coins, gold coins. One of them is face. The fake one is super light because it is not real gold. It is something that looks like gold. And we have a scale, and the scale is super accurate. It can weigh any coins on either side and tell us which side is heavier. Perfect accuracy, no need to worry about errors. I want to find out which coin is the bad coin. What is the minimum number of experiments I have to do? So there is a strategy, and we can worry about that later, but using 6. 006, what is the minimum number of experiments I have to do? Log N times. Not quite. So this is what you think is, and you can do log n with binary search, right? The problem with binary search is if I put half of my coins on the left, half of my coins on the right, one side is going to be heavier, right? So the answers are going to be this or this, but I never get this. I only get one bit of information instead of getting one trit. A trit is a base three digit. How many bits of information in a trit? One and a half. Roughly. Log three point Log three point And we know that it is base two because that is what we use in CS. So we are discarding a fractional bit of information if we are not allowing for this to happen. Anyone want to try something else? We have to prove this, by the way. We have to prove the minimum that we come up with. You could just do it coin by coin, but that would take forever. That is N. That is worse. How about log base four N or something like that? Can you explain to me why we ca not just do binary search? We can. It is definitely going to give us the correct answer, but it is not the minimum number of weighings because we are discarding a possible answer. So if you do binary search, you will never get that the two sides are equal. Log base three point Log base three would be better because we have three choices all the time. Let is prove that. So the right answer happens to be log base three of N. Let is see how we would get it aside from guessing. So you divide it into thirds and compare one third and one third, and if they are equal, then the light one is in the other third. And if they are not, light one. Then you just keep dividing by three point OK. So that is the strategy. What if I do not know the strategy? How do I do this without knowing the strategy? What if the number of coins is not divisible by 3? Math people. Yeah, but then how do you OK, never mind. Just take the two extra coins and toss them out. If it is not divisible by 3, you add fake coins that are good. I mean, you use good coins. But we are not worried about the strategy. I want us to think of a lower bound. This is a lower bound for an algorithm, right? You cannot do better than log three N experiments. Does the word lower bound ring any bells? Is there any lecture where we talked about lower bounds? So if you sort and you are using a comparison model, what is the best you can do? N log N. N log N. Good. So sorting using CMP, the comparison model, is N log N. How did we prove that? One word. Well, two words. Decision trees. Does anyone remember what decision trees are? One person. It is just a comparison thing, right? You are like, is it greater, is it less than, or is there some sort of question you are asking about each key. Cool. Let is go over that a little bit. No matter what your algorithm is, it is going to weigh some coins and it is going to get an answer from the scale. And then based on that, it is going to weigh some other coins and get some answer from the scale. And it will do some experiments and then it will give you an answer. So if you draw a decision tree, it would look like this. First, we start with zero information. We weigh some coins. Based on that, we have three possible answers smaller, equal, greater. Now, if we are here, we are going to do another experiment. Three possible answers. If we are here, another experiment, three possible answers. If we are here, another experiment, three possible answers. Say we do a third experiment. One, two, three, one, two, three, one, two, three, one, two, three, one, two, three, one, two, three, one, two, three, one, two, three, one, two, three. And then suppose we stop. If we stop, we have to give an answer. So this is an answer, this is an answer, this is an answer, answer, answer, answer, answer, answer. So how many answers do I have at the bottom if I have three levels? Here I have three experiments, so three levels in the decision tree. How many answers? . three to the third because I start three at the first level, nine at the second, twenty seven at the third. Each time, I multiply by three point So if I do three weighings, I can give at most twenty seven answers. If I have more than twenty seven coins, I ca not possibly decide which one is bad because say if I have thirty coins, then I need to be able to give out thirty answers. My algorithm has to have a place where it says the bad coin is coin one, coin two, coin three, all the way to coin thirty point Here I only have twenty seven possible answers, so this is not going to cut it for thirty coins. I need to do one more comparison so that I have a deeper tree. So suppose I have h comparisons instead. How many leaves? How many possible answers? h to the third. Almost. three to the h. three to the h. So three multiplied by three multiplied by three multiplied by three h times, so three to the h. It is no longer equal to twenty seven point three to the h is the number of possible answers. This has to be bigger or equal to N. Otherwise, the algorithm is incorrect. So what can we say about h? . We did all this without even thinking of what an algorithm would look like. This works for any algorithm. No matter how smart you are, no matter how much math you know, your algorithm is going to be bound by this. So the fact that the answer looks like this gives you some intuition for how to solve the problem. If you want to solve the problem now and figure out the strategy, you know that you have a three here. So if you divide into two every time, you are not going to get to the right limit. So first you do this, you get a lower bound, and then you use your intuition to figure out what the lower bound means. In this case, it would mean the strategy that we heard earlier. You have to divide into three every time and then figure out what you do based on the comparison. So your answer works perfectly once we have this. And also, once we have this, you know that your answer is correct because it is optimal. You ca not do better than that. Any questions on decision trees? So lower bounds are a boring topic in general. They tell you what you ca not do. They do not tell you anything useful about what you can do. In some cases, being able to reason about a lower bound gives you a hint of the solution. New problem. Suppose we have a 2D map. There is a hill, and you take a satellite picture of it at night, and you get a picture with bright pixels and not bright pixels. There are numbers showing how bright your pixels are. 1, 2, 1, 2, 3, 0, zero point I am going to draw out an example so we can use our intuition. 0, 0, one point So suppose this is our map. It is W times H W of what these are, I think they are columns, and H of the other ones. And you want to find a certain picture inside it. You want to see how many times does a certain pattern show up. Say the pattern is small w times small h, and it looks like this. But this will be the input to your problem, so the pattern might be different. You ca not hard code this in. And this is useful. This problem is called a bunker hill problem. This is a hill, and this is a bunker. You take a picture of the hill. You want to know where the bunkers are so you can bomb them at night so then you can attack the place. That is awful. Thank you. I will take that as a compliment So a nice way of solving this? You could just go through each row, and then look for a match for the first row, and then Yep. Is this a match? That is what you are saying. Yeah. We can see that is a match. Is this a match? Is this a match? By the way, this is a match. This is not a match, this is not a match, this is not a match, this is not a match. Now we go down here. This is not a match, this is not a match, this is not a match, so on and so forth. That was not what I was suggesting, but that is a good idea. Maybe you are suggesting something smarter, and I do not want to let you do something smarter so that we look at the brute force approach first. I mean, I was just saying take the first row of your bunker, and then compare it to other rows, and once you hit that, then check and see if the rest of Yeah, that is a bit smarter, so that is harder to reason about. Let is take this one and figure out the running time of it. Does that mean even if you know it is not a match, you keep checking all nine of them? Yeah. Say at the worst case, you only find out it is not a match all the way at the end. Are you trying to look for all matches or just one? All matches. You are limited to n squared time almost no matter what, right? If you have a small bunker in a large field, you have to hit the small bunker every time. Are you going to solve the problem for me? Are we trying to find the? No. We are trying to find out the running time for the dumb algorithm first. Humor me and let is solve this first, and then let is get to the efficient algorithm, OK? Big W minus small w plus one times big H minus small h plus one point Where had you get plus one from? So it is WH? Yeah. Well, there is something missing here. This is how many positions I have that I have to look at. How much time does it take to compare the small images? . This is smaller than wh, which is the input size, so it is scary if you have an algorithm that runs faster than the input size because it means you are not looking at all the input. So this is definitely bigger than the input size once we add the w times h here. Do not forget this guy. This is the naive algorithm, and if we discard the small order factors, we get that this is order of WHwh. How can you do better? You have the answer, right? Let is let everyone else think for a minute, and then you can give me the answer if you want, or someone else can give me the answer. I guess you should because you thought of it first. Any ideas? So you are thinking about the input size, right? Someone was thinking about the input size. So the input size is W times H, right? So if I have an algorithm that is W times H, that is optimal because it has to look at all the input. Well, we are going to have an algorithm that is W times H, so with that out of the way, does that inspire anyone as to what the solution is? Do that thing that I was saying, just take the first row, but then you still have a W term. Yeah. So let is make it better. It is the correct intuition. Now try to use a trick we learned in lecture to make that faster. Just use the top left corner instead of the whole row. OK. So we could use the top left corner, and if the top left corner does not match, then we do not have to check for matches. So this works for reasonably random data. As long as we do not have a lot of false positives, we are going to run fast. Now, the top corner of this one, if the map has a lot of 1 is and then some 2 is sprinkled all over it, most of the time, we will have to go through the whole image so we are going to have a lot of false positives. How do we make our false positive rate go down? Looks kind of like a rolling hash problem. Looks like a rolling hash problem, exactly. Let is see if we can use rolling hashes. But then you still have that lowercase w term, though. How do we get rid of it? . Sorry? Would not it be w? I mean the running time if we were just going through one row would be big W minus little w, times So where is your rolling hash? I guess you can use the entire thing as a hash, too. That would kind of work. So we want a hash for the whole thing. Instead of using this as the hash, we want a smarter hash. It is the entire thing, and then as you move to the right, you can add those and subtract, and compare that with the hash. OK. So we had have a rolling hash that has everything in here, and then as I move to the right, I add these guys and I remove these guys. This is big W times big H, roughly, times small h because every time I move to the right, I have to do order h work. So I am down from this thing to order of WHh, So it is better. It is one step forward. Now, let is make this even faster. What if I could do this in order one instead of order h? How would I do this in order 1? You had have to compress all the rows, and then take the hash of each column. How would we compress them? Take the hash of the column. You want to compress the rows? Yes. You divide it Let is not compress the rows. You could take just your bunker, and then figure out the hashes of the three columns, and just run through like that. You had still have to access each of those items. I do not really see how it is faster. I guess it is less, though. It is less. Maybe it is only one point So do you want to hash each little column? So we are going to hash all these guys, and then we are going to have hashes for them, and we are going to do the regular Rabin Karp for the hashes. Now, what happens when I go down? You have to recompute everything. Let is do better than recompute everything. Do you want to downward on each column? Yep. Rolling hash. I want to make this faster, so I have big W hashes. They are all little h inside. Here, I have to compute them brute force. I ca not do anything better. But when I go from here to here, there is only one element going out and one element going in. Same for all these guys. Let is not make the picture uglier than it needs to be. So I have big W rolling hashes. They are vertical rolling hashes. And then the rolling hashes hash columns, so my the sliding window that I have is little w rolling hashes. Each rolling hash is little h in size, so it is a hash of hashes. It is nested hashes. And then when I go down, I only have to roll down each of the rolling hashes by 1, so that is constant time. So to go from here to here, to the slide the window one down, I have to roll this hash down, roll this one, this one, this one, this one, this one, and all of them roll down in constant time. So when I am adding a column to the hash, say I am here and I want to go here, I roll down this hash and I have the answer. It is order one point I am adding it in order one point Does this make sense? It is tricky. But it is not too bad, right? You just need to do the vertical roll first, right? Yep. To have the simplest possible code, you start with big W rolling hashes, do 1D Rabin Karp, you roll everything down, 1D Rabin Karp, and keep doing that. OK What is the running time for this? WH. WH. Does this one have a space complexity about W, then, because? Yeah. So my memory requirement went up to 4W. Is everyone happy with this? It is one of the few cases where an approach for solving a 1D problem generalizes to 2D. In most problems, you have to rethink the whole situation. Let is do a hard problem. Enough with the easy ones. Two lists, roughly size N, and they are both sorted. Let me fill them out with random numbers. 5, 13, 22, 43, 56, 62, 81, 86, 87, 2, 3, 7, 9, 15, 19, 24, 28, thirty two point So I have these lists. Let is be generous and say that all the numbers are different. They are sorted. I want to find the nth number, so the number with rank n, out of both lists as fast as possible. Would not it just be index? So the thing is if, for example, n is 1, then it is this. This is the second number. This is the third. So if you take the lists and you combine them, then I want the result out of that. Let is do merge sort and the combined index, right? Full merge sort, N log N? No. It is already sorted, though. OK. So what do we do? We just do merge. That is just order N. So merge. Merge. OK. So merge and then index is the first approach, which is order N. Then you said run the merge algorithm, but stop when you get to the little nth element, so that is a little bit better and we do not have to produce an array so the space complexity is down to order 1, right? Now let is do Logarighmic times n. Yeah, exactly. This is linear. We have to get to logarithms. How do we get to logarithms? Do a modified binary search. What if you first looked at actually, I do not know what I am going to say. Anyone else? So modified binary search. Do you know the full answer, or do you want to start looking at the solution? I have an idea. Let is see how it would work. So if we take the n over second element on each row, the one that is lower, that is at least the n over second element, and the one that is higher So let is say this is our N1 and N2, and they are both order N initially. So this is N2 over two if this is smaller. The lower one is at least the N over second element since everything before it is less than N. Does that make sense? Yeah. So this is N over two are greater, right? This guy. We also know that the element above it is at most the nth element because it is greater than So it is at most N1 plus N2 because that is how many you have in total, and the one on the top, you know that these ones are bigger than h, right? But you do not know anything about these ones, so it is minus N1 over two point So it is at most N1 over two plus N2, the top element. So then we can take the element three quarters of the way through N2 and one quarter of the way through N1 to do more. ? Yes. Let is see what happens in each case. So if little n is here, then you divide. So if n is smaller than this, then you chop them up here and you have divided the problem into half. You are good. If it is bigger than this other number here, you have chopped the problem up and you are here. You are good. Now, the hard case seems to be when it is in between. So what do we do then? Are not those two numbers the same? If it is between, take the upper half of the bottom one and the lower half of the upper one, right? If it is between fifteen and 43, then you take everything in the upper half of N2 and you take the lower half of N1. Yeah, you should always be taking the upper half of one and the lower half of the other in this case. Really? N2, fifteen is at least the nth over two element. I think we are using three n is at the same time. Are you using the little n or the big N? Sorry. is element and the lists are called N and this is confusing. Can we rename the nth element to something like m or some other useful number? The kth element, OK. So the fifteen at least the kth over two element, so it ca not be anything on the left half of the k over 2? Why k over 2? This list is size N. Sorry. I did not pick the elements at N over two point I picked the elements at k over two point Why would I do that? If N1 is greater than k, then I chop off the end of the list, right? If N2 is bigger than k, then I chop off the end of the list completely. If this list is sorted and I want the third element, I know that these are not the answer. No matter what is down here, these are not the answer. So I know for sure that k is going to be bigger than N1, N2. So instead of going there, let is go at k over two point And here, let is go for k over two point Now this one looks a bit nastier. N1 plus N2 stays what it was before. On the list where you got the element that was lower, you know that everything to the left of it is less than k over two point The element number is lower than k over 2, so we are not using anything to the left of the fifteen point You can kill that section for us. OK, so we can kill it, but then what is the rank? When I recurse, how am I going to know the rank that I am looking for? k minus what you killed. You can save the branches. So you want to kill this guy, right? So you want to kill these numbers. But here I have k over two numbers, and here I have k over two numbers. How do I know that it is not somewhere here? How do you know that what is not somewhere there? You compare fifteen and 43, right? And then you see that forty three is bigger, and you see fifteen is smaller, so then you would go to, I guess, k over four index in N1, and 3k over four in N2. When you recurse, you said that you have killed k over two elements. But you can also kill everything to the right of forty three point Yes. You can kill everything to the right of forty three since it ca not be any of those elements, and you can kill everything to the left of fifteen point And then you repeat the algorithm again with the lists you did not kill, except you also put in a term of we have already covered k over two elements. So we want the element with the rank k over four over these lists. So I know for sure that what I have is either k over two or less than k over 2, right? So this is less than k over 2, and then I am looking for a rank of k over four point That seems to work. How does the running time look? It should be O of log k. I think it is log. So log k, log N1 plus N2. Are these different? Yes. If k is 1, the algorithm should only recurse once, even if N is twenty million. OK. But if k is twenty million and the list lengths are two million long, it will take approximately those lengths to run. OK. So what gets reduced, aside from the list size, k gets reduced. k seems to define the input size for the next iteration because I will have at least k over two elements in one of these buckets. So it sounds like it should be log k. k is bigger than N1, N2, but it should hopefully be smaller than the sum because otherwise, why am I doing the problem? So this is definitely order of N1 plus N2. So this is a bound. This is a slightly tighter bound. We have a different solution to the problem. All the possible solutions are hard to argue. They all come down to something like this. The one that we have requires you to use you have two indices, and you know that the sum of the indices is k, and you do binary search on the top and adjust the index on the bottom to keep the constraint that the sum of the two indices in N. And you can look at that in the notes that we are going to post. Are you guys tired? Do you want to look at one more thing, or are we done? . Let is look at something reasonably easy. You guys can read this on your own. I am not going to bore you with that. So suppose we have some functions, and we want to order them according to their asymptotic growth rate. Do people remember how to do this from Pset one? So the idea is that you take each function, you simplify it, and then you sort them. So let is have a couple of simple ones and then some hard ones, and we are going to stop in five minutes. What is this? n to the fourth. OK. Let is see. n choose three point What is this? . OK, very good. Why? Something about choose is n times n minus one times n minus two point It is n factorial over n minus two factorial. This comes out to be roughly n cubed. Cool. How about n plus log to the fourth of n? N. Yep. So even if I have a polynomial in a logarithm, it is still dominated by pure n. Now, suppose we want to order these guys together with which one does not look boring at all? n to the log n and two to the n. Let is sort them. Which one is the smallest? Which one is the biggest? two to the n is bigger. Let is start with the smallest ones, because I think that will be easy. So which one is the absolute smallest out of all these guys? n. OK. Then? n to the third. Cubed and fourth. So we have to compare these guys. How do we compare them? n to the power of log n and two to the n something. . Take the logs. So when we have something confusing with exponentials, take the logs and see what we get. Logs are monotonic, so if you take the logs, you will have the same relationship afterwards. So log of this is log of n to the power of log n, so it is log n times log n, so it is log two n. Log of two to the n is n. Which one is bigger? n. All right. And we are not going to solve this, but how would you go about solving this guy? What do you do to it? Sterling. Sterling, yep. You do Sterling, you go through the numbers, and you figure out the answer. And then if you have to do logarithms, you use logarithms to figure out where it belongs among these guys. What is Sterling? Sterling is formula. It is that gross thing that was on the board before we came in here. So Sterling says that n factorial is ugly. two pi n here times n over e to the power of n. So what is this binomial? What is the formula for it? OK, formula for n choose k. Anyone? It is n times one over two factorial times n minus k factorial. In this case, it is n factorial over n over two factorial raised to the power of 2, right? And then we chug through the math and get to some answer. All right? 
</body>
</html>