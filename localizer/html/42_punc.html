<html>
<body>
OK, so up until now, we have been talking about the shortest path in graphs. And we have been talking about these game problems where you came up with a way to represent the state of a game as noting graphs. And then we drew edges between those vertices that represented states, to represent moves that you can do in a game. It turns out you can solve a lot of problems this way. And you can do it without thinking of a graph at all. So we usually think of a graph, build the graph, then run dynamic programming. You can do better without building the graph. And the good part about that is that your code is smaller, and it runs faster. The bad part about that is it is harder to understand. The dynamic programming code looks like black magic. And, when we are going to give you dynamic programming problems on the final, you ca not say, oh, we are going to build something and run? dystring?. And get partial credit. You actually have to understand the magic, and write the formulas, and hopefully get something that works. So, we are going to spend all the time that we have left in the semester, I think, building up your intuition for how to build dynamic programming. So, from lecture, dynamic programming is just a catchy name for for optimization problems. So, problems where you are trying to compute the minimum or the maximum of something. So let is start with a problem. And then, see how all the concepts in lecture relate to that. So this problem is called Crazy Eights. And we start out with a deck of cards, randomly shuffled. And then some of the cards are pulled out. Did everyone see playing cards? Poker cards? Does everyone know what they are or do I have to define them? Does anyone need me to define poker cards? Let is put it that way. OK. Cool. So, suppose we have a bunch of these. I do not know what Crazy Eights is. We will get to that. OK. It is an eight point I know what an eight is, but I do not know how the game works. OK. We will get to it. So, let is see. four of spades. OK, so this is a bunch of cards that were pulled out of the deck. And we want the longest crazy subsequence. And the crazy subsequence is a subsequence where two cards are like each other. The way we define like is that either they have the same number. Or they have the same suit. Or one of them is an eight point So an eight is like anything else. OK. So four and eight point Are they like each other? Yes. eight and five point Are they like each other? Yep. OK. this 5, five of hearts and nine of diamonds. Are they like each other? No. five of hearts and seven of hearts. Are they like each other? Yes. five of spades and seven of hearts, like each other? No. OK. So we have some cards that are like each other. We want the longest possible subsequence. What about five and 5? Those are like each other. They are like each other, yep. They are more cards that are like each other than the ones I drew here. For example, this guy is like everything else. Oh, we already drew that one. OK. So how do we model this problem using graphs? So, stuff that we knew before the last lecture. Those could all be nodes. OK. All the cards are nodes. That is good. And, I want the longest path between what and what? One node to another? OK. The longest path in the graph. Yeah. The longest path in the graph. One trick to reduce it to a known problem is to add the fake source. So this is a fake source. And it is going to connect to everything. And this way, I want the longest path, starting from the source. And the other source? Nope. The longest path, starting from the source, ending anywhere in the graph. Such that it does not go touch another card again? Yeah. So, if I want a longer subsequence, that is a good question. How would the edges look? Directed. Yep. Directed. And which direction? Arbitrary. So, if I choose this one and this one, can I go back afterwards? You just ca not go back to the four point So, in the longest common subsequence, all the cards have to be in increasing order. So I can say I am going to choose this one, this one, and this one. And they have to match in this order. So I can only go forward. So I ca not reorder the cards. My answer has to be, say, four of diamonds, eight of diamonds. And then, what else would match that? nine of diamonds. You can put the eight anywhere, though, right? No. I ca not move them. So the cards have to be in the initial order. I do not have to choose all the cards, but the cards that I choose have to respect the initial ordering. So everything points right. Everything points right. Forward. Yep. And, I need one more edge from here to here. Oh, so you are saying in the game you get an initial order. And you ca not reorder it. Yeah. But otherwise I can, if I have all the cards, I am just going to order them. Well, that is the point right? I was picturing more like you get a set of cards and you try to figure out No. So, that is a different game. That might be harder to solve, so let is stick with this. Yes? Why is eight in there, with 7? eight is similar to anything. Just for the heck of it. These are the rules. OK, so we have a graph and we want to compute the longest path. We do not have an algorithm to compute the longest path. We only have algorithms to compute shortest paths. So how do I deal with that? We had that in problem set six. Make all weights negative because there is no cycle. OK. We know it is negative. And, I guess these ones do not matter. But all these are going to be, instead of being 1, they are all going to be minus one point Very good. And there are no cycles in this graph, so we know that the answer will be well defined. OK. Everyone with me so far? Happy nods? Yes. So, what algorithm do I know that solves this problem? Bellman Ford. Bellman Ford. Good. What is the running time of Bellman Ford? . Cool. Suppose I have N cards. How many vertices do I have?  Plus the source. It is ordering. So you are right. How many edges do I have? Worst case. N squared. Yep. you mean, like, the directed? No, I mean Bellman Ford. Then, we are going to go to that algorithm and get the better running time. Cause is not Bellman Ford e times e? Oh. What? Yeah. Yeah, that is what I Did someone say, v plus e? Or did I write v plus e? Yep. You did. Thank you. So it is v times e. So the total running time is. aUDIENCE N squared. aUDIENCE N cubed. Or, n cubed. Yeah, it is multiplying, too. You guys are mean today. OK, so n cubed applying Bellman Ford. There is a better way of solving this problem, right? The Directed Acyclic Graph Bellman Ford. So let is look at the Directed Acyclic Graph, not the one to be generated by this because that might be a bit messy. And let is try to compute shortest path. s, a, b, c. OK, so let is see how we had compute the shortest path in this graph. It is Acyclic, right? All the the edges are pointing downwards. So let is try to compute them directly. I am not going to write pseudocode first. I am going to write the formulas, and that will get the intuition for it. Then, maybe right psuedocode. So what is the distance from the source to itself? . Good. The first ones are easy, so I am going to do them myself. sa is one point sb is two point sc is three point And, of course, you guys get to do the hard ones. So the distance from s to d is what? How would I compute it? There is two paths to get to. OK. So, I would want the shortest path from those, right? OK. So it is four point And the formula for it is the minimum of two paths, right? S to b, and then b to b. So, one path is and s? and b?. . Wait. sa. So, first there is a path from s to a. And the edge a to d. And then, there is a path from s to b. And the eight from b to d, right? And I already know the values for sa and sb, so this is well defined. We can compute it right away. No recursion. No metrics. I mean, there is recursion, but there is no infinite recursion. Does this make sense? So, in order to get to d, there are two edges pointing into d. One of them coming from a. One of them coming from b. So I can either get to a and take this edge. Or get to b and take this edge. This is what the formulas are saying. How about se?s What is the formula?  OK. What are they? s3. Yeah, sa, sb, sc. . Aed is. And the number? 3? I think. e to e. OK. f. Someone that has not spoken today. So that I can see that everyone gets it. Please. dsb OK. plus wef. OK. And dsc plus wcf. Awesome. And that is four point I will take your word for it. OK, so now the last one. Distance from std. five point Wait. No. So, let is write a formula. Oh, g, not a. That is five point five point OK, so let is write a formula to make sure that you guys are computing it in the fastest possible way for me. So sd plus sd to g. OK. Does anyone else? Is this the only path? No. There is more. OK. Plus e as to f. Plus e as f. And n. c to f. I mean, c to g. Or, No. no. s to c. OK. See, there is a trick. OK. Cool. And then, what are the weights? w e to g. e to g. Very good. fg. fg. cg. cg. Why are you adding in c? Because there is the extra c. Oh, I did not see that. So, the point of this guy is, is that if you do bfs, you will get tricked. Because bfs would put g on the same level as these. And might compute the value for g before it has the values for these. OK, so what order do I need to compute these numbers in, for this to work? That way you computed them? So, that is a, that is a, something of the graph. Yeah. Oh, topological. Yeah. Stole your answer. Topological sort. So, any of the topological sorts works. The one we used this time is sabcdefg. Why am I using a topological sort? Because there is dependency. Yep. So, this depends on this and this, right? As c depends on sa, as b as c. So basically, every edge here indicates a dependency. In order to compute the shortest distance from the source to here, I need to know the shortest distance from the source to these two. And then I can look at the edges. So, the nice thing about a topological sort is, after I write the vertices this way, all the edges point forward. Right? s to a. s to b. s to c. a to d. a to e. b to d. b to e. b to f. I can keep going. But the point is, there is no such thing as a backward edge. So if I compute the numbers in this order, when I get to se, I know that I computed the distance from s to abcd. And if I have any edge coming into e, I know that I have already computed the shortest distance to the node that it is coming from. yes? Did I lose you guys? Was this too So basically, like, at a, you relaxed all the edges going out of it. You can look at it that way. But what we are doing here is I am looking at a node and I am relaxing all the edges coming into a node. OK. So this matches this order. OK. What you said does not match this order. But it is exactly the same thing. Oh. It will give you the same result. You had get the first value at g when you reach c. But, like, end up with the same answer. Yep. We are still going backwards then, instead of As long as you are processing the nodes in the topological sort order, all the algorithms will work because you are just computing these terms in a different order. But as long as the dependencies are satisfied, you are still going to get the right thing. OK, so what is the running time of this? How many people know the running time without having to write pseudocode for this? I know the answer beforehand, so I cheated, obviously. OK. Is it a? edges. Almost. Very close. INTERPOSING VOICES So, it is the topological. So, running time plus the running time for evaluating this. The running time for evaluating this is v plus e because you have every h shows up exactly once in here. So you have e terms. And you have v vertices, even if you do not have any edge, you have to initialize the verdicts. So that is why it is v plus e. It is also topological sort. So, this is the order in which we process this. So everything is v plus e. If we use this algorithm to solve this problem, what will the running time be? n. n squared. It is an no. So, it is v prime plus u prime, which is n squared plus squared, which is n squared. So, by observing that this graph is acyclic, we have a better running time than Bellman Ford. Even though we used exactly the same intuition that we used up until now. Model the problem as a graph. Figure out what the edges are. Run a shortest path algorithm. We have a better shortest path algorithm, which works for Directed Acyclic Graphs, so we get a better running time. OK, questions for what we did so far? It is on this graph here, then you would do the same thing. Take each node and then relax the incoming edges. Yeah. So what is the topological sort of this?  It is exactly the cards in the order that they are on the board, right? So, in dynamic programming, the topological sort order is obvious. So the hard part is representing the state and figuring out what the dependencies are. So what the edges are. And after that, the topological sort usually comes, it is fairly straightforward. OK, so what we can do now, we have a few directions in which we can go. We can write the pseudocode for this. I mean, it is basically, it is just, we are going to write abstract things instead of this. So we are going to write one piece of pseudocode that evaluates these. So it is just generalizing this thing. Something else we can do is we can look at how would these things get computed using memoization? We can look at how we would compute shortest path in graphs with cycles. So this assumes we have a DAG. What if we have cycles? How do we deal with them? Or we can do another DP problem, and see how we had model that. So, votes? What do people want to see? I think we might have time for two things, out of these four. So, everyone votes for one. And we will start with that. Sorry? DP problem. OK, so one vote for DP problem. Yeah. OK. Cyclic. Wait, you got two or one votes? One vote. OK. I will DP. I will stick with. DP. I think we are done here. All right. So, new DP problem. So, suppose you have something like Manhattan is map, which is basically a lattice. Fancy math term for a grid. And suppose it we can only go forward and down. So, all the streets are one way because they liked how people drive in San Francisco, and decided they are going to do the same craziness. So, we want to go from s to t. And there are different cost on all these edges. This is an n by m matrix. And I want to get from s to t in the shortest possible way. So, let is model the problem. And then let is do recursion formulas and make it look like a DP instead of like a graph problem because it might be too easy of a graph problem in hindsight. OK, so what is the graph problem? It is not equivalent. Topological sort. And then bfs. OK. Topological sort. And then, and then that. Well, let is write this as, let is say that each node is so let is say that the nodes have numbers, right? So this is 1,1 and this is 5,4. And I want to write this using math, so 2,1. 3,1. 4,1. 5,1. And then, 1,2. 1,3. 1,4. OK, so this is the graph. The shortest path from here to here is obvious. By the way, this is a real problem for people who do not see the connection between dynamic programming and graphs. I This problem has tripped up people on exams before. So it is not a toy problem. OK. So, on an examine, would you have the option of just using a straight up graph algorithm Well, we are going to ask you to solve this using DP. So let is try to solve this using dynamic programming by writing recursion formulas. So, what is the shortest distance to 1,1. zero point OK, then. If I have a general distance, if I have some random node here, dij, how do I compute this? It is a minimum distance between the distance of law plus weights. Or the distance of j. i minus one. Yeah. So, i minus one j. Yeah. We get it. Plus the weight of the, yeah. Going from one to the other. OK, so the weight from i minus one j to ij. OK. And? j minus 1i. For i, j minus one point ij minus one point Plus weight of that ij. ij minus j1 to ij. ij OK. So these are the recursions. Now, how would I write the full set of code for this? So what is a valid topological sort for these guys? 1,1. 2,1. 3,1. Dials. 1,2. The right dials. That is going to be hard to code. That is going to be easy to code. So I am going to take your answer. OK. What? I am not going to take your answer because your answer is correct, but it is hard to code. But is not that the same thing? She says, go like this. Oh. Oh. So, here is how I am going to code them. 4i in 1,2n. 4j in one to m. So, I guess, first off, if i is one and j is 1, then d of ij is 0, right? This is the base case. Otherwise, d of ij equals big bad formula that we have up there. OK. Do we need anything else? DP. This is DP. We are done. Is it? Almost work. Yeah, this is Over I thought this was just programming. it is a dictionary, though. Yeah. It is programming. So this is the DP solution to the program because, instead of building the graph, you are writing the recursion. And you are writing using this implicit representation of the graph. Oh. This is it. This is DP. Most people are really afraid of it. This is the hardest thing in the course. If you get the connection between graphs and this, and if you know how to model graphs, that it. You are one month in the term, you are done with six double six. You already know everything to ace the exam. OK. Are not graphs just programming, as well? Ah. But there, you are building a graph structure. Here, we do not need to build that structure. Because we see the connection directly. Like, this code is much smaller, right? It is much easier to look at. I mean, sorry. It is faster to read. But it looks like black magic if you do not see the underlying graph. Yes? Did you have a question? Yeah, so. What exactly is dynamic programming? Unless they give at least one or two examples of, like, using something that you had calculated already, or Yeah. Fibinocci. So. Yeah. So Ah, so now you just have to have a dictionary to store the minimum cost. That is what d is, though. The d of ij. Wait. So. So I like your question. And I am going to address all the other ones first. And then I am going to spend about five minutes addressing your question. What is dynamic programming, right? What is the point of this? Like, what is dynamic programming? We are going to come back to this. So any questions about this? Wait. As you are going through Is there a dictionary? Sure. This is an array. Or dictionary. So, say this is ij. If it is an array, or if it is a dictionary, it would be d of the tuple ij. So, I can write this in Python, right? This is almost Python. What am I missing? , or it fits inside. Yes. So, I have some boundary conditions, right? Because this guy would depend on this guy, which is inside. And left to depend on this guy. Which does not exist. Oh. I was not OK. Sure. So, we need a few more ifs here, for boundary conditions. I mean, in theory, though, you could just run through the new dfs and create a topological of the source. Right? And just run through that. Yeah. But that is so much code to write. Look at this. This is five lines. Well, yeah. For this particular problem, it is five lines. Well, for dynamic programming, the solutions are five to ten lines in general. And the only hard thing in dynamic programming is figuring out what is the state going to be. So, after you get used to them, after you solve ten or 20, when people come out of programming contests, and someone says, my solution is dynamic programming. Really? Wait, you can solve it that way. And he says, yeah. This is the state. And then everything else is obvious. Like, it is pretty easy to figure out everything else. The hard part is the state. So, it is enough to say my solution is dynamic programming. This is my state. You guys are probably going to have to say a bit more than that on the exam. But this is the hard part. DP. No, you ca not just say DP. You will definitely need at least a state. OK. So. You are also missing a state for deciding stuff in the dictionary, though, right? Before deciding if my key is already in the dictionary? Well, so, aside from the boundary conditions here, if I compute this here, it depends on theses two, right? Are they going to be in the dictionary? Not yet. Why? If I am running this way, so if I am computing all my values in this order. So the first line one. Then line two. Then line three. They are already going to be in the dictionary. So this is because I am doing topological sort. You do not need memoization if you are not using the topological sort of the graph. You only need memoization if you do not. So, why are we doing boundaries commissions if Because . So, I am doing a boundary condition because if I paste this in if I paste this thing in, then when I am here, this is going to refer to this guy. Which is fine. But it is also going to refer to 2,0. Which does not exist. So the code might be a bit obfuscated by the boundary conditions. But it is ten lines of code. It is pretty nice and straightforward. OK, now what is dynamic programming? I like that question. So, a key property, I do not think it was mentioned in lecture. Guys, correct me if I am wrong. It is called optimal substructure. Does that ring a bell? Probably going to hear about it next time, so. Optimal substructure. So, the point of optimal substructure is, suppose I have a shortest path from s to g. Right? so, suppose I have shortest path from s to g. And that path is called p. Now, suppose this path goes through d. So, path from s to g is actually s making a path through d. And then there is another path going from d to g. This path over here, p1. p1 is guaranteed to be the shortest path, or a shortest path, from s to d. So this is the big solution. It is optimal because we say it is the solution to the problem. This is a part of the solution. This part of the solution is optimal for this part of the problem. So the part of the problem is getting from s to d. The part of the big optimal solution is optimal so the small part of the big solution is optimal with respect to the small problem. So p1 has to be a shortest path from s to d. Do you guys want to see a proof by contradiction? Or do take my word for it? Does anyone want to? So, intuitively, the idea is that if you had the better path here, say that path would be s3, then I could replace this, sorry. p3. I could replace this with p3. And I would have a better path overall. And that would contradict the fact that this is the best path. So this part of the path has to be a shortest path to get from s to d. So I have broken up my problem to get from s to g, into saying, I want to get from s to d, from s to e. Or, from s to f and then cross one edge. And then the ways I get from s to d from s to e, or from s to f, have to be optimal. I have already encoded that here. And nobody asked me, yo, is this true? Can I take a longer path here? And have a better solution? The answer is no. In some problems, the answer is yes. Those are not problems that you can solve with dynamic programming. if, in your problems, that is the case, you probably forgot to account for some part of the state. What kind of problems would it be where that would not be true? Well, remember the quiz problem with the gas stations? If you do not account for the gas, if you do Dijkstra, then, well. Guess what? Shortest path in the graph, if that does not account for gas stops, if you start accounting for the cost of refilling, this path might be longer than a path that goes like this. So, it is longer in terms of road stalls. But has fewer, or has cheaper, gas stations on the way. So then, there is no optimal substructure. And that is because you did not account for the fuel states. OK. Probably not the best example. Sorry for bringing up painful memories. But the point is, usually when you have this with our problems, you did not account for the state. All the problems that are solved with dynamic programming have this thing called optimal substructure. And this is sort of how it works. OK. I have no idea how much time I have because my phone crashed. So can anyone help me? Five minutes. ten minutes. Sorry. Seven minutes. OK. What else do you guys want to see? Cycles.  OK. Is everyone happy with cycles? OK. Almost everyone, so that is good enough. OK. Let is do cycles. We have seven minutes. So, suppose I have this graph. Source going a going to be going to c. And then the costs are one minus one point one point one point Can I solve it using that method? Probably not. Let is try to write the recursions to see what we get for the formulas. So, dsa is one point minimum. Yeah, it is one point But it is the minimum of dss plus weight sa. ds well, almost. Actually, it is not one point Likely. You are confusing me again. There is one more edges that they have to account for. Oh. dsc plus weight. I am going to fail today. I am tired. ca. OK. So we accounted for both edges coming in now. dsb is minimum of dsa plus weight ab. dsc is minimum of dsb plus weight bc. Right? And dss is zero because we promised that is how we start. OK. Now what if I try evaluate these? Is there a sane order in which I can evaluate them? Nope. Let is see why. If I try to evaluate sa, this depends on sc. Which we do not have yet. sc is here. sc depends on sb. sb is here. And it depends on sa. Which was. So we have this infinite recursion, right? They all depend on each other. There is a loop here. There is a negative cycle. Ca not use this algorithm. That is a shame. What can we do instead? Show a negative node. A negative weight. half. Sorry? Can we just get rid of the negative weight half? No. That is the best edge. That is probably going to be part of the solution, right? Can we add one to all the edges? That is still going to have a cycle. I still wo not be able to run this. Oh, yeah. Bellman Ford. Bellman ford. That is not dynamic. OK. Well, one way to do it is Bellman Ford, right? Another way, which we went through last time, is to break the cycle. And the way we break the cycle is we add the path length into the equation. So, I am going to look at the distance from a source to some node, so the distance from a source to some node, as the distance from the source to some other node plus the edge weight. This is what I had before, right? Nothing new here. So dsv is the minimum over all the edges of dsu plus weight uv, Right? Minimum over all uv. That is our edges. Right? This is the old stuff. Now, we are going to say this instead. The distance from s to v, using a path of length k, is the minimum over all the edges of the distance from s to u, using a path of what length? If this path is length k. So k edges. How many edges do I have here? k equals one point So this is distance su using k minus one plus the weight of uv. So what is the difference between the two? So, this will always decrease. So I guarantee that they will not have an infinite recursion. This is the magic that makes it work. Now, an equivalent way of looking at this, is building a graph. That is what we have been doing so far. So let is build an equivalent graph to this.  It is going to get to zero eventually, right? So when k is 0, the distance from the source to itself is zero point But the distance from the source to any other nodes is infinity. Because from the source, we ca not get to anywhere else in zero edges. We ca not teleport. So let is build a graph to get the intuition for this. This looks mathy. This looks too mathy. So, at the first layer, you only have the source. You can only get from the source to itself by not crossing any edges. At level one, you potentially have all the nodes. If the source is connected to everything, you might have all the nodes. So, s1, a1, b1, c1. Where can you get from the source? To a. To a. What is the cost of the edge? one point OK. Now, let is build a second layer. s2, a2, b2, c2. So someone tell me the edges. So, assuming I can get to this node using one edge, how can I get to this other node using two edges? A to b. OK. a to b. a1 to b2. two point OK. Cost? one. A1 to c That is negative one point a1 to b2. Thank you. OK. . Sorry? Are we doing anything else? I think so. So, if I am at b using one edge, I can get to c using two edges. Cost? one point OK. If I am at c using one edge a. using two edges. Cost? one point OK. And if I am at s using one edge? a.  Can you? There is now edge. There is no edge. I thought it was just like an assumed edge. Nope. Nope. Not an edge. As to a, cost? one point one point OK. Let is build a third level. s3, a3, b3, c3. Someone dictate the edges please. S2 to a3. With one point I mean, it is going to be the exact same. Yep. a2 to b3 minus one point b2 to c3 one point And c2 to a3 one point So these are exactly the same edges, right? Because they are the original edges in the graph. Every edge in the graph can connect to levels here. So, all edges. All edges. All edges from s. How many layers do I need? e. OK. Pretty close. Let is try something smaller. a. Oh. That makes no sense. So, what is the longest path in a graph? Graph of v vertices. What is the longest path? The number. The longest shortest path. v minus one point v minus one point That is how Bellman Ford has v minus one runs, right? Oh. So, a shortest path ca not have a cycle. If it has a cycle, then it means it is an infinite cycle. So there is no solution. Shortest paths have no cycles therefore, even if they go through the entire graph, they are going to have v minus one edges. So I am going to have v minus one layers. Here, I drew three layers, so I am done. That is why I stopped at three. So let is see how many nodes and how many edges we are going to have if we do this transformation. v prime is so, how many times am I going to copy the graph? Two or thee times. Three times. OK. And in general terms? v minus one point v minus one times. OK. So I am going to copy the graph v minus one times. And then I am going to add that one source, right? Does not really matter because it is order of b squared. How many edges?  Order of v times e. We can do the math that is whatever. Let is say it is something like this. So the running time this graph is acyclic, right? All the nodes are going forward. The new graph that I have here. Yeah. So, I can use the DAG algorithm. So the running time, if I use the DAG algorithm, is v prime plus e prime. Which is? v. Thank you. Or is it ve? So, it is v squared plus ve, which is ve, for most purposes. And this is? Bellman Ford. Bellman Ford. So this is Bellman Ford. This is what Bellman Ford does. Except when you are coding it up, it relaxes the edges in a different way. But this is the intuition behind Bellman Ford. And this is an easy way to see why Bellman Ford works. So, practically, we really would not want to do dynamic programming. We just want to run Bellman Ford because that is less code, right? So, this is the dynamic programming view of Bellman Ford. Write Bellman Ford. There is a reason why we taught you to write it that way. It is going to be shorter. This just gives you more intuition. And it shows you how the DAG algorithm relates to Bellman Ford. And this is how we handle cycles, which are removed. So, that means I have fulfilled my promise of covering two of the issues that I had on the board. Yes. So any questions about this? So, we did not do the pseudocode for the shortest path using DAGs. The code that we gave you in the code handout matches the pseudocode that you had write. Yes? So, if all edges were negative one here, except for the top edge, looking at this graph over here, how would the search go through, such that it would find, lik,e negative two weight half? So these edges are minus 1? Yeah. Well, do you have a solution in this case? It is no. No. But you could have this, right? And expect the whole thing to work. No, that is still not, that is not making sense. Is it? It is negative one cycle. Oh, yeah. That is unfortunate. OK. Never mind. Do like this? OK. So, also, looking at the graph, there is only one natural path that you can take. Yep. So, if I go from s to c, like this, sabc, this is going to be s0, a1, b2, c3. So, all the paths go ahead. So, what if I wanted to find the shortest path to s to b? Like, in terms of actually writing an algorithm, would it be s0, a1, b2, or s1? a2, b3. OK. So, if you actually want to read the shortest path, then the shortest path could have length 1, length 2, or length 3, right? I do not know. So I would have to look at all these. Oh. OK. So you just run it from s0 to any b, basically. So, the algorithm that we have there computes the path from one source to everything else. So I run it. It runs. Computes all the shortest paths. And then I have to read these ones. And get the smallest one. That is a question. Thank you. Yeah, that is a detail that I left out. Thank you. So, no more cycles. OK. Any other questions? Yes? I am still, like, on the initial problem and stuff. A bit of a disconnect. When you were underlining stuff, like the sa, it seemed to me that, like, in that case, when you are going forward, you are never going to stop because you are doing recursion. So you never have a beginning point, almost. Effectively, if you, like So, do you mean here? Well, yeah. So, in that case, this is the beginning point. Right. If I go through the nodes in the topological sort order, then all I need is one beginning point. Because everything else will refer back to that. There has to be a topological sort order. And the first node in that order is my source. And, if we have cycles, then the beginning conditions are here. So that is why I am only drawing this vertex. Because these other vertices would not be useful. OK. So then, that being said, do not forget your quizzes and happy Thanksgiving. 
</body>
</html>