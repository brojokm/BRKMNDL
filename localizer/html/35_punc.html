<html>
<body>
It is a bit better, my heart is back in place. I am glad that not everyone is gone. Well you mean passed out and died from the test? Yeah. OK, no there were a few students left. That is good, that is good. I think once we release the results everyone will calm down, and we will realize that the mistake was on our part. The mistake? I mean the results are lower than what we thought. And it is because we have not covered something that I will cover today. So we think well we talked about it yesterday, and we think we have not done enough algorithm design with you guys. So today I have problems, and we are going to come up with solutions. Are you not going to tell us what number is? It is in the lecture notes. It is actually quite boring. I promise it is really boring. OK. And if you want to do that next time when we will actually talk about numerics. The thing is numerics are straightforward. Once you learn the algorithms you are not going to come up with a new one. I am pretty sure about that. Like you are not going to come up with a revolutionary way of adding two numbers. I do not know. You never know. Well you can tell me why. Think about it and then you can tell me why you are not going to. OK, got it. OK so let is start with a problem. We know what sorted arrays look like, right? 1, 3, 5, 6, 7, 9, twelve point This is a sorted array. If we are given a sorted array we know how to find the number in it, right? What is the running time for that. For any given number? Yeah.  Well what is the best way that we know? Logarithm. Log and binary search, right? Well instead of this we are given a shifted array. And shifted means that say you are shifting the array by K elements. We are taking these guys. So the array is shifted to the left. So these K elements end up on the right. These N minus K elements end up on the left. So 7, 9, 12, 1, 3, 5, six point So still N elements they are shifted by some number K. And I want to find one number, e, in the array. I do not know K by the way. We just know that it is a shifted array. This is twelve point So the first thing you do is figure out how much time you have for this, right? If you are on a test, you roughly know how much time you have for a problem. If you are on an interview you have to figure out how much time the interviewer is willing to give you for problem. And spend the first, I do not, a third of the time thinking maybe. Come up with the best solution that you can. And then stop there, and start talking. So the first thing you do, you want to make sure that when you run out of time you have something to say. The most awful thing you can say is, dude I am going home now. Or leave the answer blank. If you leave the answer blank we are not going to give you points, right? So not good. So what is the worst answer you could give us? OK worst is a bad term. What is the brute force solution to this? The solution where we do not care about the running time, but we want the correct answer. Look everywhere. Yep. So do a linear search. Pretend we do not know anything about this array. Lose the information that it is a shifted array. Linear search running time order N. OK so this is something, at least now when your time runs out you have something. You are not going to leave empty handed. Let is start thinking now. Next step. can we shift it again? So the fact that it is shifted means that so originally it was sorted, right? But now instead of it being completely sorted, you have all the elements are shifted to the left. And then so there is a rotation thing going on here. So these elements got out of the array and then they are put back in from the other side. Why do we do that? That is how the info looks like. We do not do it. It was done to us. Oh OK. So now what do we want? We want to find an element Oh, I see. despite the fact that the array looks like this. Do we know that the list that we have is shifted already? Yes. So we are promised that this is a shifted array. So it will look like this. But we do not know what K is. If we knew what K is, could we do something fast? What would we do? Yeah, you had just re shift. OK so if you re shifted what is the running time? For order K. OK so if we actually shifted and then do a binary search it is order K plus log N. So for big K is that is not better. Why is it not order N plus log. You can say that since we do not have any promise on K it is N. It is order K if you can shift things out of both N is. With Python this would be order N, just popping out one element is order N in Python. So this is assuming a smart array. Otherwise if it is Python, good point. It is straight up order N. So now another good point. You have this solution, and you have the brute force solution. They have the same running time. You run out of time. Which one are you going to code up? Which one are you going to show? The simpler one. The simpler one, excellent. So the reason is, if you are on a test it is probably give the pseudocode, then analyze it. If you are in an interview the guy will ask you OK, what is the running time? Code it up on the board in C, Java, whatever he knows. So you want to code the simplest solution, because that reduces the chance that you will have bugs. So that gives you the most points. So this solution shows more insight, but it does not have a better run time. Stick to the simple solution. However if you have this then you have some insight on the problem. So you can keep going and hope you can come up with a better answer. So if we knew K, one thing we could do is reduce the array to an unshifted array. What is another thing we can do? So I claim that if you know K you can come up with a reasonably easy log N method. If you are doing binary search, like if you just pretend like the array is all together, but if you know K. So let is say you are looking for six point Then you had say oh well I am going to split the array half, but you are actually going to start at K and then split it in half. So it is like you pretend that So what you want to say is you have a pretend array in your mind, right? Yes. It is by K. And you want to access the middle element to see if what you are looking for is bigger or smaller. Instead of looking at the middle element here, you look at the middle plus K, right? Yes. Oh, there you go. Plus K. This is one way of doing it, good running time. The problem is it is hard. You will have to rewrite binary search and hope it works. What I would do, given that I have had a bit of time to think about it, is this is sorted. This is sorted. So two binary searched are also going to be log N time. Two binary searches, two lines of pseudocode. The running time analysis is pretty simple. Correctness is also pretty simple. And also this gives me some insight on the rest of the problem I claim. OK so if we have K we can do log N. What if we do not have K? What do we do? Yes? Figure out what K is. All right let is try to find K. We know how to do it if we have K. So let is try to find K. What if I want to arrive to a solution that is log N, how much time can I spend on finding K? OK so let is find K in log N time. Binary search for minimum? Binary search so I like binary search, because binary search is an algorithm that runs on an array. And that runs in log N time. So if I am able to make it work I know everything is going to be right in terms of time. So what do you run a binary search for? The smallest number possible? I guess that is kind of going through all of them, though. It does not really help. So if you have the min. Sorry, you can speak in one second. Oh we have the min So no, if you ca not have the min. I think it is good insight. So if you knew where the min is, you know this is K, right? Yes. So this is the minimum, that is K. OK, what were you going to say? Oh for just binary search it would not minimum. I was thinking that if we start at one we will see to our right and left. And the point where are ending is where we have something larger to our right and something smaller to our left. OK so there is a discontinuity here, that is what you are saying, right? So this is sorted. But then at this point this breaks. Yes, we are kind of finding that point where something to the right that is greater than and something to the left is also greater than. OK so let is see if we can do that. So for binary search you have to go somewhere. So in our case we are trying to get K, right? And we know that it is somewhere between one and ten point And what binary search does is it makes a guess. It says hey, I think it is in the middle of the array. So it will probably guess n over two point And it makes a guess and you have to tell it was the guess too small, or was the guess too large? Because this is what allows you to recurse on either the left interval or on the right interval. The problem with a discontinuity is, if I guess here, and if I guess here, I still do not see the discontinuity. So it is good inside, but it is not enough. I need a little bit more. Yes, 2, three hands oh wow you guys do not got it? So I think we can arbitrarily take the halfway point instead of subtracting from the first element. And then if it is a negative number, then discontinuity will be in this half. If it is it will be in the other half. And then you recurse on that. OK. So let is draw this up. So in a sorted array the numbers look like this. In a shifted array we splice it here, and this guy goes to the right. So it is like this and then like this. So this picture shows me the insight that I had before, that this part is sorted and this part is sorted. The missing part, which I just heard now, is that since the whole array was originally sorted, this guy is smaller than this guy. So if I draw a horizontal line here, I can draw a horizontal line somewhere, and this and this will not cross it. So this whole thing is taller than this. So by the way, K was where the discontinuity was, right? You said discontinuity. This is K, it is somewhere here. So this is a better. So if I make my guess and I land somewhere here, I can know that my guess is too big, because it is below the line. If I make my guess and it is somewhere here, I know my guess is too small, because the number that I see here is above the line. Who sets the line? The first element here. So this is how you look at it graphically. If you do not want to look at it graphically, this was a sorted array. If this is the Kth element, then everything here is smaller than it. So all these guys are smaller than the first element. OK so honestly who understands the solution? 3, 4, OK. Oh, OK pretty good. Do we want to code this up, or do we want to look at another problem? OK who wants to look at another problem? Clear majority, all right. Usually I have to do both choices, because not enough people are paying attention to get this. So I am happy. . Yes. All right so before I start another problem, one thing I want to say. Not only do I have a solution for this problem, but I have a process that allowed me to go from nothing to a few partial solutions. And while I was doing that, I was getting insight and I was making sure that if I run out of time before I have the final solution, I do not walk out of the room empty handed. So I do not just want to show you the final solution, I want to show you the process. You can look at the notes and see the final solution. That is not everything I want you to get out of this. OK, problem two has a heap. And this is a minimum heap, so it looks like this. So this is a minimum heap, N elements. And I want to extract the kth smallest element in the heap. So if K equals 3, this is the third smallest element, right? K equals 4, it is this guy. 5, and 6, one and two are here. OK the good running time that we want, because this is a hard problem so we give you the running time, is K log K. However before we do that I want to hear some brute force solutions. All of them. And? OK you need to sort them first. So this heap is actually an array, right? 2, 5, 7, 6, 8, oh it is 6, 9, 8, sorry. So you are saying sort the array, then K . OK what is the running time for this? Log N. All right we have a solution. We are not going to leave empty handed. OK let is try to go a bit better. What is another way of going it that will give me a better running time? You could pop five of the K elements off of the All right so this is a mean heap, right? So it has find min. And find min runs in order log N. So if I call it K times I am going to get the K smallest elements. By the way heap sort says pop and times, and you will have all the elements in sorted order. So we are doing a heap sort, except we stop when we lose interest after K elements. So we are down from N log N to K log N. So I would be interested in hearing a solution that is worse, because it would look like N log K. But shows me more insight. So by the way this is good. You are already K log N. So K log N, the correct answer is K log K. Small difference, right? It is a logarithm factor. At least it is not an N factor. If you code this up chances are we are not going to be able to distinguish between this. So you will never see this on a PSet. So you are almost there. And this is just applying straight up knowledge that we had before. Let is look at this solution, if anyone sees it. Before we attempt K log K. In another case would we just pop off first K elements, why would that be in log N? Because it is actually an array, so I would think that we had just take the K time. So this is a heap. If you do not maintain the heaping variant after you do the first pop you are not going to be able to do the second one. OK, cool. So let me give you a hint. How would we find if this is an array how do I find the minimum? 2, 5, 7, did I forget something? No. Let is pretend this array does not start with 2, because it is boring if it starts with two point How do I find the minimum? I keep one variable that says the best I have seen so far, right? Let is see, N oh this is still boring. Let is start here. So we start with best seen equals seven point Then when we go to six we see, is six better than best seen? If so, replace best seen with six point If not keep going. Then I get to nine point Is nine better than best seen? Nope, keep going. Is eight better than best seen? Nope, keep going. So I compare every element with the best seen, and then whenever the element is better I do a replacement. And then at the end, best seen will have the smallest element. So this algorithm works for k equals 1, which is not very useful. So can we generalize this somehow to so we have a running time here. That might give you a hint about how we want to generalize it, and I want to generalize it for all values of K. If you go to the power of two then it is less than the nearest power of two less than K OK. that element, and iterate forward with your best seen. Does that make sense? If you want the kth, if you want the tenth smallest element, then it has to be after the 8th row because it is the next level in the tree. Does that make sense? That does not make sense. It makes sense, but I do not think it is right. So you are thinking that the tenth smallest element has to be somewhere below, right? Yeah. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, and then pretend that there are numbers here. 11, 12, 13, 14, 15, do you see what I am saying? So this is a heap. So I can keep filling it with bigger elements, and ten is here. However you can do something else to limit the size of the heap. It will give us a different running time, but you can do something. You can think about it. How can you chop up some of the heap? For example if I have a heap that is ten deep and I look at the fourth element, what can I do? You can think about that. And let is try to get to this. So I will accept an answer for either how do we limit the heap in that case, or how do we generalize this algorithm. Yes? You want us to remember the smallest K elements, you had make a max heap K . OK so I want to have I will break down your solution into parts. So you want to have a bag of the smallest K elements, right? So instead of the best seen, you want to have the K best seen. And once you have a bag you want to go through your elements. And then if you have something that is better than what you have in the bag, you want to put that in the bag. Suppose I have, suppose K equals 3, and I have 2, 5, and seven in the bag. And I see six point Who do I want to compare it with? The biggest thing in the bag, right? So if I want the K smallest elements, if this guy is smaller than anything, these are not the K smallest elements anymore. So I want to take the maximum in the bag, compare it with what I am seeing right now, and if what I am seeing is smaller I want to replace it. . Because I keep doing this maximum, I keep asking this maximum question, this has to be a max heap. That is why he said max heap. So you did all these steps at once and then gave me the final answer. But this is how you do it step by step. So it looks like finding the minimum element, except you have a bag. And that bag has to be a maximum heap. And the original heap is a minimum heap. So the fact that you have to use a maximum heap is a bit nontrivial. Good answer. All right so we have K log N, and we have N log K, so choose what you want to have in your log. We have a solution for you. How about this. How are we doing here? So suppose I am looking for the fourth element, and my heap has ten levels. How can I chop it how can I reduce the number of things I am looking at? You can reduce it down to four levels. I can reduce it down to four levels, exactly. So this heap has log N levels. And my K is smaller than log N. I can reduce the heap down to K levels and discard everything below. And the reason for that is we have a mean heap, right? So if we go down from, on any path from the roots to a leaf, the values have to increase, right? Otherwise it is not a mean keep. Otherwise there is an invariant violation somewhere there. So as I go down on any path my numbers are going up. So these are all the paths of length four point All of them have to go through here. All the paths of length four will stop here. So I know that everything here has to be bigger than the first four elements. So if I reduce this to K and I discard everything else, what is the running time? So if I use my find my extract min algorithm before, what was the running time? It was. So it is not the Oh sorry it is the So what is one operation in a heap? If I have the height of a heap, what is an operation? How much time does it take to do one operation as a function of the height of the heap? So if my heap has h levels, in this case h happens to be log N, it is order h. So if I reduce it I am not reducing it from N to K. I wish I could. I am reducing it from log N to K. So for really tiny K is, this becomes order K. And my total running time is K squared. So I am going to do K operations, K extract mins. OK now the reason I wanted to entertain this is I claim it is going to be useful to help us find the answer. So everything that we have here gives us some insight into what the correct answer is. Well what our correct answer is. There might be others. So let is think for a bit, and see if we can do better. Am I covering something? I hope not. So by the way, when you have problems on your own, say you are looking at CLRS or at old exams, you want to give yourselves half an hour, an hour to think. And just this process alone is going to help you do better on a test. Because while you are thinking you are going through everything you know. And you are rearranging stuff in your brain in a way that will be easier to access it later. So now you are going to think, what do I know about heaps? What do I know that takes log N time? What do I know that takes N log N time? And your brain will be better at answering these kinds of questions later. Now we are not going to give you thirty minutes, because that would make us run out of time. You want to reduce it down to K elements. I want to only have to look at K elements, that is good. Otherwise you ca not plug K into the search. Yep, OK so that is good. Which is interesting, because it is K log K, and that kind of suggests that you had have K elements in the tree. But then you are searching for each one in the tree. So maybe I am not going to be able to cut this heap into K elements, right? I will have to do a bit more. Can you cut this heap into K elements and use that heap to do our? Let is see how we had cut this heap. First off let is see how this keep would look like if it is cut. How do we find the first K elements here? How do we find the first element? . It is the root. Second element. . What do I look at? If I want to select the second element in a heap, how many elements do I have to look at? Two, five and 7, because everything below will be bigger, right? OK I look at them, I compare them, I know five is the smallest one. Now suppose I want to find the third element. Who do I look at? seven or the thing under five point So seven is still in the race for sure. And then I have to look at the children of five point Right now we are looking at three point Suppose this has some really large kids. As in numbers. And I find that this is the third element. Who do I look at for the fourth element? . OK so this is not in the race anymore, because it is the third. The fourth has to be either of these two guys. Or the kids here, right? And it happens to be seven point So I take it out. If I want to look at the if I want to find the next element, who is in the race? This guy gets out of the race. 7 is kids.  OK so we have something. We are not really cutting up the heap, but we are sort of computing where the blade would go if we wanted to cut it up in K elements and N minus K elements. Does this make some sense? Nods, no nods. I mean I guess you are never going to be going down farther than K. So let is just understand the concept. And then we are going to do one more pass, write pseudocode, and understand the running time. Because this is still confusing, right? We will need one more pass, otherwise we ca not write the pseudocode into it. So does the concept make sense? Is that K log K? Yes. So the idea here is that I have a horizon that says, what are the next elements that I am willing to consider? And first the horizon starts with just the root, because I know that is the minimum element. And when I take an element out of the horizon I put in its children. That is what I did all the time. So given a horizon how do I know what the next elements to extract out of the horizon? . The mean, OK. So I want a data structure for the horizon that can extract means quickly. OK what am I going to use for the horizon? A min heap, excellent. So let is try to go for pseudocode. Suppose we have H as our original heap. So H is a mean heap. We will make Z be our horizon. I ca not use H again. It would be nice if I could, but I will use Z because Z is also a letter in horizon. So Z is the mean heap. And then first I will insert into Z. I will insert the heap is root, right? So Z dot insert H of one point Remember that heaps are actually arrays. I hinted to his earlier. So these nodes have are elements in an array. So this is the first element, second, third, fourth, fifth, sixth. So we are using array backed heaps, and H of one is going to be the root. Then I am going to compute the first K elements like this, for K in range sorry, for i in range K, so K is going to go from one to K. What I want to do? Take, compute the ith element. How do I do that? Extract min. i equals Z dot extract min. And then I want to insert the children in the horizon. Right? How do I do that? 2i and 2i plus one point OK so this is if I know the index, right? When I am putting things in the heap the keys are going to be the values, so that I can take out the minimum. heap first and then inserted H Y. Yeah, OK. This is empty. And this is the input. OK so I need to use the numbers as the keys. So when I extract something out of the heap, so when I extract the first element it is going to say 2, it is not going to say one point If I want to Why would not Z dot extract because So this will give me the next key in the horizon. But oh I see, you are starting out with just the first one. Yeah. Oh and then you want to add in the next. So at the end of this whole thing, if I am extracting them right, I can return this variable here. Because after K durations this is going to be the Kth element. So I return it and I am done. The problem is I want this guy is index too, right? So I ca not just store the key in the heap. I have to augment the heap to let me store values. And I have to store the index. So for this guy would have Z insert H of 1, and then it is index one point Then when I get out the ith element I will also get out it is index. A variable name for that? j. j. OK why would you name your variables like this? In the previous section I had a similar suggestion, i, i. So why would you name your variables like this? . Job security. All right. So it is OK here. Try to not to do that when doing an exam or an interview, because it reflects poorly on you. For an interview and for an exam you will get us upset and we might be less lenient. Or at least explain what you are doing. So extract min is going to give us the key. And it is going to give us index in the heap. What do we do afterwards? We add to H of All right so when we take out two so we start out with an horizon of two point When we take it out 2 is the only thing that is in the horizon first. Then we take it out and its two children get in the horizon. Then we take out one of the children and put its children in the horizon. So when we take out a node we want to put its children in the horizon. So we are going to say Z dot Insert. Insert. What do I insert? H of I times two point j times two point See? It is working already. The job security thing is working. And? 2j plus one point You have to do two lines. OK, sweet. OK. Does this work? I mean does this do what we wanted it to do earlier? Wait, we are extracting oh All right first nod. I mean if K is small enough. Eventually you will ask for something that is out of range. Oh so you are thinking that eventually these will run out of range. If you have your really lopsided array eventually you will ask for something that is. OK what would we want to do in that case? Just want to check to make sure that the. Yeah, but otherwise move on, right? If an element does not have kids, we do not add on to the horizon. So we need some bounce checks, exception checking, things like that in here. And I wo not add that because that will make it look long and ugly. So this is the idea. OK what is the running time for this? . Cool. So creating heaps, initializing, all order 1, insertion, this heap is almost empty now. So this is order one point Then these happen K times. And these are all operations on the heap Z. And the heap for the heap Z, it has some number of elements. And it is not always going to have one element, because every time I am extracting one element I am adding two. So well how many elements is it going to have at most? K. OK why is that? Because each time you add it it is one element. So I extract one for sure. And then I add at most two elements. So the heap size grows by at most one in every iteration. So the heap size Z will have at most K elements. So now I know the running for all these operations. What is it? Log K. Cool. So it is K times log K. And the reason that it works, it is a bit harder to see. You have to convince yourself maybe using this bigger tree, that whenever you are spending expanding the horizon you are expanding it the right way. So the idea is again that whatever path you take down you are going to see ascending numbers. So when you are increasing the horizon you are always pushing it down in such a way that your invariant is that all the numbers in the horizon are smaller then their children. And so on and so forth. So the horizon is always guaranteed to have the smallest number that you have not extracted yet. And that is really the only thing you need. OK does this make some sense? It never would have occurred to me on an exam. Yeah exactly. This would not occur on an exam unless you think a lot, you are super inspired, all that. If it does not occur to you what do you do? Go with the N log K solution. OK, very good. Wait. K log N. OK, K log N or N log K, which one? K log N. Why? Two reasons. K log N is so two reasons, faster and simpler. So you write this down. And you get half score or 34 of the score and you are done. It is better than nothing, anything, and getting a 0, right? I mean 34 of a score for two lines of pseudocode is reasonable, right? Two or three lines. This is three lines probably. Also on most exams we are humans, right? We might mess them up, we might make them too long. If we make them too long, you want to get the most number of points. You will have time to figure out one or two problems at that level. But if we give you too many, for the rest of them you want to have something simple that gives you some of the points. Same for an interview. For most interviews most people do not really have a clue how many problems you can solve, how many problems are reasonable. So you want, for every problem you want to show some solution reasonably fast. And then see if they are happy. And if they are happy move on to the next problem. And if they are not happy only then spend more time. So this is as important as that. If you look at the recitation notes we will have some problems and we will have some solutions. What are going to do, memorize the solutions? Yay, you know how to solve more problems. There are probably a million problems in total. That does not get you very far. So what you want is to understand this process that we went through. So every time we tried something we got from some point to some point with a better running time. Well except for here. And where we had more insight on the problem. So this is the important part. And I am going to show you one more problem, really quickly. We are probably not going to be able to solve it, because it is hard. But we are going to talk about it and see if we can get some insight. Let is see, what do I want to erase? This. I like that. All right, so we have an array random numbers, 7, 2, five this time there is no order in it 8, 9, four point And we tell you that the array has two to the N numbers, to make the problem easier. 1, 2, 3, 4, 5, 6, seven point six point So you have this array. And we want to answer queries of this shape. Say this array is E, and it has N elements, and you know that N is some two to the K. Minimum of all the elements from i to j. So you have two phases, just like we had on a problem on the exam. You have a pre processing stage where you get the array, you do some computation, you save some information. And then you have a querying phase, where you have to answer these as fast as possible. I see most people have unhappy faces. Bad memories, huh? OK let is not worry about that problem. Let is look at this one. So assuming you have as much time as you want to do the pre processing, what is the fastest way you could answer these? Yes? If you had as much time for pre processing memorize it. All right. So if we compute the answers to all possible solutions, right? How would I store that? So I want to do this in order one point So how would I store these answers? Just sort your array. OK so I sort my array. Then you want the minimum from i to j, so look at the ith element and that is your. OK so figure it out? Well I mean if I can sort it I can also say hey, why do not we use this array instead? And then I will answer the queries. You can go off a tangent trying to sort the elements and keep their keys. The important thing is if you think about it for awhile and you see that things stop making sense, back out. Look somewhere else. We spent some time trying to find a solution based on sorting in my last section. It is not going to work. So Ca not you just take the from i to j? OK let is get to that in a bit. So let is keep that in mind. Because that is another point on the trade off curve. So if I want to serve my queries in order 1, then the way I do that is I will have a hash of all the arrays that look like i, j. So all the possible intervals. And I will store the answer here. The minimum the elements from i to j. And I can do a hash lookup in order one and get the answer and return the answer. How many elements so I have here? So how much storage do I have to use for this? O of N squared. OK N values for this, N values for this, so roughly N squared. What is the time for computing this? Brute force, let is not think. What is the time for computing this? N cubed. N cubed. You are thinking. So I have unsquared elements here. For every element I have to compute the minimum of potentially order N elements, right? So this is N cubed. I could reduce it to N squared by noticing that if I have the minimum of these elements, and I want to compute the minimum of these elements, really all I have to do is compute, compare this minimum with this element. So every time I start with an interval of size one and then I expand it by one point So I have my two for loops here. And I keep growing my minimum. So I could get down to order of N squared times. So I have one solution that has order of N squared time and space, and then answers the queries in order one point You had a solution you said where, what you do is, when you get a query you compute this, right? You were suggesting sorting the array. That would be N log N. I would suggest not sorting it. Do the splicing, you look through all the elements, and you find the minimum. I was saying that if the original E spans i to j and started at the So when you get a query the i is and j is change for every query. Otherwise we could compute the answer. So we have one answer where we take order N time to answer a query. And what do we do for pre processing? Nothing. Order one point So these are two ends of a trade off, right? One possible extreme is that you pre compute all your answers. The other possible extreme is that you do not do anything and you brute force every answer. And now we want to find a point somewhere on this line between the extremes. So the answer that we are going to show in the solutions uses order N log N space. And it answers the query by using order one elements in this order N log N data structure. So I have order N log N partial minima. And I will only use two of them. So the total running time is not actually order one point But we only use order one elements. Let is start thinking very quickly. Let is think for about a minute, and then we will go through the solution. And there are multiple solutions. All of them are interesting in different ways. And there are other solutions that are equally fun and applicable with not the same running time. Let me make some space here. So like I said, thinking is a useful process on its own. So you are getting better just by doing this. using more than one space total? We are using N log N space. Oh and it takes constant time It will only look at two elements. It is actually not constant time. We are not going to worry too much about time. It turns out being log. Ok, what was the order one then? You only access order one elements. Order one partial minimum. Oh, OK. Does it have to do with two different K? Maybe. I do not know what to do with that. There is probably some sort of tree involved. So you are going to want to split things, right? Into halves. And you are going to want to be able to do this all the time. And we say two to the K so we do not have to worry about, oh my God what happens if the halves are not equal? You can usually solve this when you implement the problem. But it is useful to not worry about that when you come up with your first algorithm. If you are going to start dividing in halves. . Um. . So that leads to another useful solution. That leads to a solution that takes that has N log N storage and it will run in N log N time with N log N element axes. So what you thinking of is you are going to have your array of elements, right? And say you want to find the minimum from here to here. You are going to have your array split in half. So you are going to find the minimum of this, and the minimum of this. But to do that you will have to recurse. So this is also say split in half. So you will have to find so it turns out that if you do this, in the end you will have log N minima that you have to look at. But this is more, this is a cooler and more useful thing, so I will try to put it on a PSet or something to make you think about it. So this is do not tell people yet. You might have a solution to a problem. . OK. So what we thought of, or the way we thought of doing it, is 6, 7, 2, 5, 3, 8, 9, four point So we compute these partial minima. We split the array into two. And these are the minima that we compute. Sorry, this is like this, this is like this. So everything, so all the left half then these guys, then these guys, then this guy. Everything here, then these guys, then these guys, then this guy. So if your i and j are on different sides of the middle, then you do two lookups, you are done. If they are in the same half, then you have a problem that is half the size. So you are going to have to take this array that is half the size, 2, five point Split it into halves and do the same thing. And then we are going to have to do the same to this other one. 3, 8, 9, 4, split it into halves and do the same thing. So in the end you will end up in someplace where your interval ages are on different sides of the middle. And you look at two elements and you are done. Let is see how much space this takes. Can someone tell me a recursion for how much space, for how many minimums I would need to keep? So space for an elements is? The first level you have eight point So go down by an order of two point So what is the first level? Of eight N. So order N plus? N over 2? t of N over 2? OK S because it is space. N over two point OK. And? . You are missing something. Look at this picture. So this is the whole thing. Then I have a half. And then what else do I have? two point The other half. Oh, two point OK so the difference between these two is that one of them gives you order N, the other one gives you N log N. So I gave you the answer, so I ca not ask you for the answer now. But where did we see this before? Pretend these are t is. . Sorry? So these are t is, this is the recursion for? more sort?. So once you put it up you do not draw the recursion tree and solve it. You say this is what we saw in? more sort.? Therefore, the solution is N log N. So this is how you show you have N log N space, and it is pretty clear that you are only going to access two elements. I do not understand how. How it works? So you have your i and you have your j. Let is make that one i here. If you want to find the minimum, if i and j are on different sides of the half, you have this and this. And these two partial minima cover your entire interval. Now if they are on the same side of the half then you recurse to a smaller problem. Well you do not have to there because you already have the minimum of that section. Yeah. It would not work if you had six and 2, right? Or that. Yeah. Well why not just take seven and two then? Why do you have to break up the entire panel? Assume there is more things there. Oh I see. So if you have this, now it is no longer true, right? So wherever they are here, you do that. And remember your pseudocode has to be as simple as possible to reduce the probability of bugs. So you want to do the simplest possible thing, not have special cases. OK. By the way there is a study that shows that for good or bad programmers, if you have 1,000 lines of code, there is a constant probability of a bug. And the constants are different for good versus bad programmers, but it is still a constant. So how many mistakes you make is directly proportional to how much you write. This is why we like simple solutions. OK, any questions on this? So we have four problems. We did not cover one. Look at the other one, look at the solution. Ideally look at the problem, think for at least half an hour, then look at the solution. What I want you to take away is not just oh, here are three problems, let is memorize how we solve them. But the whole process thing, and how we played with data structures and how we used all the hints that we possibly could to build more insights into the problem. OK, cool. 
</body>
</html>