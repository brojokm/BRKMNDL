<html>
<body>
Today is our last lecture on dynamic programming, the grand finale. And we have a bunch of fun examples today on piano, guitar, Tetris and Super Mario Brothers. What could be better? We are, again, going to follow this five step plan to dynamic programming, define sub problems, guess something in order to solve a sub problem, write a recurrence that uses that guessing to relate different sub problems, then build your dynamic programming either by just implementing as a recursive algorithm and memorizing or building it bottom up. For the first, you need to check with the recurrence is acyclic. For the second, you need an actual topological order. These are, of course, equivalent constraints. Personally, I like to write down on topological order because that proves to me that it is acyclic, if I think about it. But either way is fine. Then we get that the total running time is number of sub problems times time per sub problems, and then we need to solve our original problem. Usually it is just one of the sub problems, but sometimes we have to look at a few of them. So that is what we are going to do. And we have one new concept today that all these examples will illustrate, which is a kind of second kind of guessing. We have talked about guessing in part two here in which we saw the obvious thing. In the recurrence, we usually take the min of a bunch of options or the max of a bunch of options. And those options correspond to a guessed feature. We do not know whether the go left or go right, so we try them both. That is guessing. But there is another way to guess. So two kinds of guessing. So you can do it in step two. Let is see what I have to say about these. In step two and three, you are guessing usually which sub problems to use in order to solve your bigger sub problem. So that is what we have seen many, many times by now. Every DP that we have covered except for Fibonacci numbers has used this kind of guessing. And it is sort of the most common, I guess you might say. But there is a higher level of guessing that you can use, which we have sort of seen in the knapsack dynamic programming, dynamic program, which is when you define your sub problems, you can add more. Add more sub problems to guess or you can think of it as remembering more features of the solution. And we just leave it at that. Essentially what this does so remember with knapsack, we had a sequence of items. They had values and sizes. And we had some target knapsack, some capacity. We wanted to pack those items into that knapsack. And the obvious sub problems were suffixes of the items. Because we always know suffixes, prefixes, substrings, those are the obvious things to try. But suffixes was not quite enough. Because if we looked at a suffix, we did not know of the prefix that we have skipped over how many of those items were in and in particular, how much of the capacity we had used up. And so we needed to add more sub problems to remember how much capacity had we used up in the prefix. We did that by multiplying every sub problem by s different choices, which is how many units of the knapsack still remain. So in some sense, we are remembering more about the prefix. You can also think of it as in the more forward direction, we have the suffix problem. I am going to solve it s different times, or s plus one different times. I am going to solve it. What if I had a big knapsack? What if I had a smaller knapsack? What if I had a zero size knapsack? All of those different versions of the problem. In some sense, you were solving more sub problems. You are, in some, sense finding more solutions to that sub problem. You are looking at a suffix. And I want to know all these different solutions that use different amounts of the knapsack. So in that sense, you are just adding more sub problems. But from a guessing perspective, you are remembering more about the past. We are going to see a bunch of examples of this type today. We will always use this type, but we will see more of this where the obvious sub problems do not work and we need to add more. So the first example is piano and guitar fingering. This is a practical problem for any musicians in the audience. How many people here play piano, or have played piano? OK, about a quarter. How many people have played guitar? A few, all right. I brought my guitar. I have been learning this semester. I am not very good yet, but we will fool around with it a little bit. So the general idea is you are given some musical piece that you want to play. And on a piano, there is a bunch of keys. You have all these keyboards, so you know what a piano looks like, more or less. It is just like a keyboard, but only row. It is crazy. Each key that you press makes a note, and every key has a different note. So it is very simple from a computer scientist is perspective. You want to play a note, you push the key. But you could push it with any one of these fingers. Humans have ten fingers. Most humans. I guess a few have more. But you want to know, which finger should I use to play each note? It may not seem like a big deal. And if you are only playing one note, it is not a big deal. But if you are going to play a long sequence of notes, some transitions are easier than others. So let is say we are given a sequence of n notes we want to play. And we want to find a fingering for each note. So fingering, so let is say there are I am going to label the fingers on your hand, one up to f. For humans, f is five or 10, depending on if you are doing one hand or two hand stuff. I think to keep it simple, let is think about piano, right hand only, and just you are playing one note at the time, OK? We are going to make it more complicated later. But let is just think of a note as being a single note. OK, or you can think of guitar, single note, left hand is playing things. You want to assign one of these fingers to each node. And then you have a difficulty measure, d. And this you need to think about for awhile musically, or anatomically, how to define. If we have some note p and we are on finger f and we want to transition to note q using figure g, how hard is that? So this is the p and q are notes to play. I guess p stands for pitch. And f and g are fingers. So this is how hard is it to transition from f on p to g on q. There is a huge literature on for piano. There are a lot of rules like, well, if p is much smaller than q, unless they are stretched, then that becomes hard. And if you want to stretch, you probably need to use fingers that are far away from each other. If your playing legato so you have to smoothly go from one note the other you ca not use the same finger on both keys. So if f equals g and you are playing legato, then p better be the same as q sort of thing. There is a weak finger rule. You tend to avoid fingers four and five, these two. Apparently going from I am not much of a pianist so going from between three and four, which I can barely hold them up, it is kind of difficult, is annoying. That is what I wrote down. So between three and four transitions you try and avoid. And so you can encode into this function. It is a giant table. You can just put in whatever values you want that you are most comfortable with. And music theorists work a lot on trying to define these function so. So you can do that. And for guitar, maybe I should do a little example. Get this out. I ca not play much, so bear with me. Bet you did not think this would happen in six point  So let is see. So let is say you are trying to play your favorite song. STRUMS SUPER MARIO BROTHERS THEME  OK. So when I am playing that, I have to think about the fingering. Which finger is going to go where to play each note? OK, so the first notes are actually open, so it is really easy. And then I go up to holding the first fret on the fifth string. OK, and I am using my index finger because everyone loves to use their index finger. And in particular because the very next note I am going to play well, actually it is down here. Then the next note is going to be this one. So I am holding on the third fret of the bottom string. And then I have got to transition over here. And actually, usually I do it with my middle finger. I do not know quite why I find that easier, but I do. OK, and so I have actually played that opening a zillion times with lots of different things. This is the one I found to be the most comfortable. And there is this issue, right? If your pinky is here, where can I reach with this finger? Where can I reach with this finger? It gets difficult. And in particular, it is very hard for me to reach down here when my pink is there. And so you can encode that in this d function however you want. You get the idea. APPLAUSE Thanks. I will skip to our lessons.? We are?? worth? ? it.? So let is solve this with dynamic programming, OK? That is the cool thing. So we can do it. And we follow our five step procedure. So the first thing is to define sub problems. What are the sub problems for a set up like this? What are the three obvious candidates? Do you remember last lecture? How many people know the answer? Just checking. One person. Go for it. Prefixes, suffixes, and substrings. Right. Prefixes, suffixes, and substrings. We have a sequence of notes. We are not going to worry about the sequence of fingers. I do not think that is too big a deal. That is what we are finding. What we are given is a sequence of notes, so we should try suffixes, prefixes, or substrings. I will just tell you, suffixes are fine. Kind of. So a sub problem will be suffixes, so how to play notes from i onwards. Intuitively, we want to figure out, how should we play the first note? And then we go on to the second note and so on. So we are applying them one by one from left to right from the prefix side. And so we will always be left with a suffix. OK, then we need to guess something. What is the obvious thing to guess, given I need to play notes i onward? Think little harder. This one you should not have to think. That is what I tell you. Try suffixes, try prefixes, try substrings. Yeah? Maybe which finger to just put around i? Yeah, which we are going to use for note i. Our whole point is to assign fingering. The first note here is i. So let is think about i, what could you do for i? We will try all the possibilities. Which finger to use for note i? OK, now the really hard part because it is impossible is to write a recurrence. This is wrong, by the way, but it is the first thing to try. So this is what I want to ask you to do because it is not possible. But intuitively, what we might try to do is we are trying to solve DP for i. And we want to find this is difficulty, so you want to minimize difficulty. So we will take a min over all of our guesses of what it would take to solve the rest of the notes, to play the rest of the notes, plus somehow the cost of playing the first note. So what is the cost of playing the first note? And then is going to be a for loop over fingers. OK, that is going to be the min. We want to try all possible fingers for note i. Then we have to play all the remaining notes. And then there is this transition cost where you are going from note i to i plus one point So it is going to be something like d of if we know that we use finger f to play i then we have to go to note i plus one point But then the problem is we have no idea what to write here, because we do not know what finger we are going to guess for note i plus one point So this cannot be known. OK, but it is the first thing you should try, because often this works. For simple DPs, that is enough for sub problems. But we need to know more information about what we are going to do next. And this seems very worrisome, maybe now we have to guess two things. Do we have to guess more than two things? Turns out two things is enough. But we cannot use this type of guessing. We need to use we need to add more sub problems. More sub problem, more power. So any guesses what we could do for sub problem? A couple of right answers here. Yeah? Maybe like all the suffixes like the i, for all written i is, like all the possible fingers for i? All the possible fingers for i in the sub problem. Yeah, good. How to play it is still about the suffixes. We are still going to use that. But we are going to suppose we already know what finger to use for the first note, note i. OK, this is a little weird, because we were guessing that before. Now we are just supposing someone tells us, use finger f for that note. This will work. That is the one I had in mind. But the question becomes, what should we guess? Anyone else? You clearly get? a pillow.? I do not know how many you have by now. Have another one. That is tough. This is not easy to figure out. Now, given that that is our sub problem, what is the next thing to guess? Do you have an idea? I got an idea to define it. Like either the next or previous finger for the The next or previous finger. Well, I am looking at suffixes. So I only care about the next one. Yeah. I see what you mean by next or previous. But what we mean is note i plus 1, that is the next thing we do not know about. So we are going to guess finger we will call it g for note i plus one point And now magically, this recurrence becomes easy to write. So it is almost the same thing. I wish I could just copy and paste this over, but I ca not. It is not a digital blackboard. Are there digital blackboards? That would be cool. Someone should make that. I do not know why switched from open parens to square brackets, but I did. Then we have I think it is just the obvious thing, if i plus one g. Ahh, this is a slightly wrong, though. It is a copy paste error. This should really be DP of i comma f, because now sub problem consists of two things which suffix am I in, and what is my finger for note I? And so when I call DP, I also have to provide two arguments. It is going to be DP of i plus one comma g. And then I am looping over g. I am trying all possibilities for g. That is the recurrence. So if I want starting with finger f on note i, how do I solve the suffix from i? Well, I guess what finger am I going to use for the very next note. Then I have to pay this transition cost for f on i to g on i plus one point Yeah, OK. So slightly, I am cheating the notation here. This probably should be the note, what is note i, and this thing should be what is note i plus one point If you think of this d function just being given notes, pitches that you need to play, instead of indices into the array. It does not really matter, but that is how I defined it before. OK, so I have to pay this transition cost. What does it take to make that transition from i to i plus 1? And then what does it take to do the rest of the notes, given that now my finger is or now finger g is playing the note i plus 1? So we transition from f to g, and that is now kept track of in the sub problem. This is the magic of defining more sub problem. We needed to know where our finger used to be. And now we are telling it, oh, your finger right now is finger f. Finger f is the one that is currently playing the note. And then afterwards, g is the finger that is currently playing the note, and we can keep track of that. You could also define this to say, oh, f was the finger that was used for the previous note, note i minus one point But it is just a shifting of the indices here. You can do i minus one to i instead of i to i plus one point But this is, I think, slightly cleaner. OK, and then we have a DP, right? We have just memoized that recurrence. We get a recursive DP, or you could build it bottom up. If you were building it bottom up, you had want to know a topological order. And this requires a little bit of care because there is two parameters. And so it is going to be a for loop over those two parameters in some order. And I believe the right order is for i has to go from right to left because this is suffixes. So I would write reversed range n python if there are n notes. And then within that loop, I would do a for loop over f. If you reverse the order of these for loops, it would not be in the right order, I am pretty sure. But this one will work. You can check it. And then to solve our original problem, here we require a little more work because none of these sub problems are what we want to solve because we do not know what the first finger is. We know what the first note is. That is note zero point But what finger goes there? I do not know. And DP of zero requires us to give it a finger. Give it the finger, ha. Give it the finger for whatever is the first note. So this is pretty easy though. We just take a min over those choices. Which finger should we give it? That should do it. So we do not know what finger to start with. Just try them all, take the min. This is just like the guessing that we did here, just a slightly simpler version. There is no transition cost because there is no transition. We were not anywhere before. Just what finger do you start with? I do not care what finger I start with. It is how I transition from one note to the next that is hard. OK, done. That is the DP. Now, if this is not obvious or not clear, I think it is easier to think about it in the DAG form. So let is draw all the sub problems. We have here a two dimensional matrix of sub problems. We have the different suffixes on the one hand. So this is it, it stats a 9, goes to n minus one point And then in the other dimension, we have what finger to use from one to f. And so in each of these positions, there a note. There is a sub problem. Race. I wanted to get five rows because there are five fingers. And then our transitions basically look if we are at finger one on this note, we can go to finger one on the next note. Or we can go, if we are not legato, or we can go to finger two on the next note, or finger three or finger four or finger five. And then if we are starting with finger two, we could go to any one of these. So you get a complete bipartite graph, which you usually draw like this. That is how graph theorists draw complete bipartite graphs. OK, but I tried to draw a little more explicitly here. It is just any possible transition. And for each of these, the point is you can compute the D cost, because you know what figure you were at. You know what finger you are going to and what note you are starting from and what note you are going to. Those are the four arguments you need for D. So you put those weights on, and then you solve shortest paths on this DAG. And that is exactly what this DP is doing, OK? Except there is no single source here, which is kind of annoying. And so you need to take this min over what is the shortest path from here, what is the shortest path from here, from here, from here, from here. Of course, you do not actually need to do that by running single source shortest paths f times. If you are a clever shortest paths person, you would add an extra source note, connect that with zero weight to all of these sources. So put 0s on there. And then do single shortest paths from here. And you will find the best way. You do not really care where you started, so this is trying all the options. That is exactly what we are doing here. But here I am doing it with the shortest paths trick, here I am doing it with guessing and taking a min like DP style. OK, so that is how to do piano figuring and guitar fingering for single hand, one note at time. Questions? And this even worse for aliens if you have arbitrarily many fingers on your hand. I guess we should figure out what is the running time. So we have sub problems. We see how many sub problems there are here. There is n times f sub problems. How much time, or how many choices are there for our guess? Well there is f different choices for what finger we use. And when we do this min, we spend theta F time. Because there is a for loop over F, we are doing constant work assuming D lookups take constant time. This is theta F time. So we multiply those two things together, and we get the total time, the number of sub problems which is n times F, and we multiply them by theta F for each sub problem. So this is nF squared. And given F is usually pretty small, it is almost linear time. So that is a pretty good algorithm. But in reality, you tend to play multiple notes at the same time. In music, typically you are playing a chord. With piano, you are playing several notes with one hand, maybe several notes with another hand. Two handed piano, it is crazy. You could do four handed piano, make it a little more exciting. With the guitar, play I do not know very many chords, but I know at least one. You play, I do not know. This looks like something. That is a G chord. Do I know any others? And that is an E chord. All right, you get the idea. I mean, for each of these chords, different people use different fingers, even for a single cord. So it is sort of a personal taste how you are going to define your difficulty measure. But I could play an E like this, or I could I do not know, play it like this. Or I could play like this. And there is lots of crazy ways to put your finger here and your finger here and your finger here. And for each of them, you could define some difficulty. And then, of course, is a transition from one chord to another. And because there is different ways to play different chords, that was not a very good example because they all look pretty bad. Well, this one for example, this is the G again. I could use my one, two, three, four fourth finger here, or I could use my fifth finger. My instructor says we should use our pinky because people tend not to use their pinky. But it makes a difference what I am going to transition to next. Maybe my pinky really needs to go over here next and I should free it up for later, or maybe it is better if this one is freed because then I can move it somewhere else. So that is what we had like to capture in a generalized form or this dynamic program, and we can do it. So I will try to do it quickly so we can get on to the other examples. All right, other fun stuff. Actually, there is another fun thing with guitar, which is that there is more than one way to play each note. There are six strings here. And you could play like this note for the Super Mario Brothers. I could also play that doing the fifth thing here. It is slightly out of tune, but those sound almost the same. Or I could play on the 10th fret on the third string. That is the same as bottom one. So a lot of options, so you also like to capture that. This is actually not too hard. You just need to generalize the notion of finger to what finger you are using and what string you are using. So there are f different choices for what finger you are using. If you use a generalized guitar, there is s choices for what string you are playing. There is a lot of different guitars with various numbers of strings, so we can just generalize that. And now it is not only, which finger am I going to use, but what sting will I play it on? And then you can still define a difficulty measure like this for this set up, depending both on the finger and the string. And then the running time grows slightly. It is now n times F squared S squared, because now I have to take the product of F and S. OK, so that is first thing. But then if I wanted to do multiple notes, well, you can imagine it is a similar type of deal. It is going to get harder though. First thing we need to generalize is the input. Before the input was a sequence of notes. Now it is going to be a sequence of multi notes. So notes of i is now going to be, let is say, a list of notes that all need to be played at once. And conveniently, it is probably going to be, at most, F notes, because you really can only play one note with each finger pretty much. I guess you could try to play two notes at once on a piano with a finger, but eh. It sounds difficult. For a guitar, it is at most s notes. You can only play one note per string, more or less. So that is our input. And now we need to adjust the dynamic program. And I think I will tell you how to do this. Basically, now you need to know where all your fingers are. So you go from one pose to another pose, from one chord to another. Different ways to finger that. Which fingers are and which strings and which frets on the guitar, which fingers are on which keys on the keyboard. But you just need to know all that. And all your fingers might be doing something, and you have got to know for each finger what note is it on, or is it not being used at all. So how many different ways to do such a mapping are there? I mean, this is just a function. So it is the number of targets of the function. So how many of these are there. Gosh, well, I guess we said there are, at most, f notes. So f plus one is the maximum number of possible things each finger can do. And we raise that to the power of the number of fingers. That is the possible mappings of what all of my fingers could be doing. It is exponential in f, not so great. But if f is 5, it is all right. And then well, then you just generalize the rest. I do not think I will write it down in detail. But our sub problems now are going to be let me switch boards here. How do we play these multi notes from i onwards, given that we are going to use that pose or I called it the state of all my fingers for the first notes of i is now a whole bunch of notes. So given I am now going to play those notes with this particular finger assignment, how do I play the rest? And then what we will guess is the entire finger assignment for the next set of notes, i plus one the next chord, if you will. And that guessing involves now F plus one to the F time. And then we just write the recurrence in the same way. So we are basically generalizing here we call the finger, now it is an entire pose for your hand. Instead of F, you might write H for hand or something. And so the running time in this situation is going to go up to something like n times F of plus one to the F. Did I miss anything? Probably have to square that. 2F. Before it was F squared, now it is just F plus one to the F squared. So if F is small, this is all right. Otherwise, not so great. This is the best algorithm I know for chord fingering. Questions? Just trying to make it practical, solve the real life problem. I would love, I think I do not know if this has been implemented, but someone should implement this in some I do not know, score program, musical score program. I would love as learning guitar, it had be great for someone to just tell me how to finger things. Then I can retroactively figure out why using the dynamic program. All right, let is move on to Tetris. All these problems are going to have the same flavor. You can solve them with basically the same dynamic program. It is all about figuring out what should the sub problems be. So let me does anyone here not know Tetris? OK, good. No one is willing to admit it. So you have got these blocks falling. But I am going to make several artificial constraints. First of all, I tell you the entire sequence of pieces that are going to come. This is more like a Tetris puzzle. OK, we are given sequence of n pieces that will fall. For each of them, we must drop the piece from the top. OK, and if you are a fancy Tetris player, you can let a piece fall and then rotate it at very end to do some clever, clever thing. I disallow that. You always have to push the drop button. So the piece starts here, it goes instantly to the ground. This will be necessary. I do not know how to solve the problem without this constraint. OK, and then the other weird thing this is very weird for Tetris full rows normally clear, but now they do not clear. This is like hardcore Tetris. You are guaranteed to die eventually. The question is, can you survive these n pieces? That is the question. Can you survive? Oh, I have got one other constraint. This is actually kind of natural. The width of the board is small, relatively small, because we are going to be exponential in w. In real life it is 12, I think? Ten. Ten, sorry. It is been a while since I wrote my Tetris paper. So all right, these are all kind of weird constraints. If you do not make all of these constraints oh, also the board is initially empty. That is like level one of Tetris. If all of these things are not the case, which is regular Tetris, if you just have the first thing then this problem is called NP complete. We will be defining that next class. So it is computationally intractable. But if you make all of these assumptions, the problem becomes easy, and you can do it by dynamic programming. So how do we do it? We define sub problems just like before. The obvious thing to try is suffixes. How do we play a suffix of pieces i onwards? How to play those guys. And just like fingering, this is not enough information, right? Because if we are going to play from pieces i onward, what we need to now is what the board currently looks like. I said here the board is initially empty. That is not going to be the case after you place the very first piece. So in general, after we have placed the first i pieces, we need to know what the board looks like. And here is where I am going to use all of these assumptions. If you always drop things from the top and rows do not clear, then all you really care about is how high each column is. This is what you might call the skyline of the board. OK, now in reality, there might be holes here because you drop things in silly ways. Maybe you drop a piece like this. And then I claim, because I am dropping things from zero from the sky, I really do not care about that there is a whole here. I can just fill that in and say, OK, that is my new skyline. Because if you ca not do these last minute twists and if lines never clear, that is going to be gone. That material is wasted. OK, so all I need to remember is how high is each column. So I should say given the board skyline. Now, how many choices are there for that? It is quite similar to this function, the fingering. Let is see. There is the height of the board, different choices. It is going to be h. For each column it could be anywhere between zero and h, so I guess h plus one if you want to get technical. And then we raise it to the power w, because there is w different columns and each of them is independent choice. So this is going to n times that different sub problems. And here is what I need the is small because this is exponential in w. So it is reasonable in h, but exponential in w. OK, then what do I guess? Any suggestions what to guess? So where the new piece falls, as in? Yeah. What should I do with piece i? There is not that many choices. I can rotate it zero, one, two, or three times. I can choose someplace to drop it, but those are my only choices. So it is just how to play piece i. And given that guess, you can figure out how the skyline updates, like I did here. If I drop that piece like that, then I fill in this part and recompute my new skyline. So it is going to be something like four times w different choices, roughly four for the rotation, w for the x coordinate. And so the running time is just going to be the product of these. n times w times h plus one to the w. Open problem, if I drop any one of these assumptions, can you get a dynamic program that is reasonable? Could you do it if w is large? I do not know. Could you do if rows do clear? That is the least natural constraint here. I do not know. Puzzle for you to think about. I had love to know the answer. You can obviously do the rest of the steps, right? You can write down the recurrence. It is the same thing. You take the min over all guesses. What are we minimizing? Hmm. I guess here the question is survival. Can you survive? So this is one of the first examples where the answer is a Boolean value, true or false. But if you think of true or false as zero and 1, then it is still a maximization problem. You want to maximize. You want one if possible. Otherwise, you will get zero when you maximize. So you can write the recurrence using max. And in the base case, you have truth values, true or false. And you will see, did I survive? Did I die? That sort of thing. I want to go on to Super Mario Brothers, because everyone loves Super Mario Brothers. has? Anyone not played NES Super Mario Brothers 1? Aww, you got to play it, man. You are the only one. You can play it on an emulator. Maybe not legally, but you can play it on an emulator and just see how it is. So what I am going to talk about next, in theory, works for many different platform games, side scrolling platform games. But Super Mario Brothers one has some nice features. In particular, a nice feature is that whenever anything moves off of the screen, it disappears from the world. So the monster moves off, it is gone. You can think of there is a static level there. When the level comes into screen, when a monster comes on screen, then it starts acting. But as soon as you move the screen you ca not actually move backwards in Super Mario 1, but as soon as you move forwards and that character is offscreen, it is gone. So in a sense, that part of the level reset to its initial state. Now, as long as your screen is not too big and thankfully, on NES screens were not very big. It is 320p, or whatever. This will work. If you are given the entire level so let is say there is n bits of information there and you have a small screen, w by h screen, w and h are not too big. Then I claim we can solve Super Mario Brothers by dynamic programming. So let is say we want to maximize our score. Want to run through the level and maximize your score, or you want to minimize the amount of time you use. You are doing level runs. Pick your favorite measure, all of those can be solved. And the way to do it, this sort of general approach to all these DPs is we need to write down what do I need to know about the game state. I will call that a configuration. What can we care about for Super Mario Brothers? Well, I guess everything on screen. This is a bit tricky, but there is stuff on screen. There are monsters and objects. For the monsters, I need to know their current position. For the objects, I need to know like, is there a question mark box? Did I hit it already? Did I already get the coin or did I already get the mushroom? So for each of those things, there is some amount of information you need to store. How much information? I think something like constant to the w times h should do. That is saying for every pixel on the screen or for every square on the screen, however you whatever you define the resolution here to be. Let is say for every little unit square in Mario land, is it a brick? Is it a hard brick, or has it been a destroyed brick? Is a monster there right now? Is Mario there right now? All these kinds of information. OK, so there is a cost number of choices for each pixel. You can write them all down. You might also want Mario is velocity. I had to play it again just to check that there is indeed velocity. Turning around is slower than going forward. You do accelerate a little bit. So you have got to remember that. There is probably only a constant number of choices for what your velocity is. What else? Ah, I want to remember the score. You want to maximize score. And let is say you also how much time is left. There is a time counter. If it hits zero, you die. Now, these are kind of annoying, because they are integers. They could be kind of large. So I am going to say the score could be capital S big, and time could be capital T big. So this will be a pseudopolynomial algorithm. The number of configurations in total here is the product of these things. It is exponential in w and h. And then multiply by S and T. So that is the number of configurations. And that is also going to be our sub problem. I guess we should also write down where is the screen relative to the level. OK, how far to the right have you gone? That is another w. That is not a big deal. OK, given this information, you know everything you need to know about playing from here on. And the time counter is always going to keep ticking. So you can draw a graph of all configurations, just enumerate all of these things. It is this many of them. And then draw, for every configuration, what are the possible things I can do? I could push this button. I can push the A button, I can release the A button. I can push the B button, I can release the B button. I can push the up arrow. Those are all the things you could do. It is a constant number of choices. So each vertex will have constant out degree. If you did this, what configuration would I reach? Just draw that whole graph. Do shortest paths. Or dynamic programming, these are your sub problems. There are no suffixes here. These are your sub problem. And then you take a max, if you are trying to maximize score or max if you are trying to maximize time, minimize the time you use. This is time remaining. And you can relate each sub problem to a constant number of other sub problems. So your running time will be this, because you only pay constant time per sub problem. And now you can solve Super Mario Brothers optimally, as long as your screen is not too big and as long as your scores and times do not get too big either, because we are only pseudopolynomial with respect to S and T. Questions? All right. That is yeah? So are we going to be trying to memoize all of these possible configurations? If you do the recursive version, you will end up memoizing all of these configuration values. Well, anyone that is reachable from the initial state. Some configurations might not be reachable, but the ones that are reachable you are going to start doing them. When you finish doing them, you will memoize the result. 
</body>
</html>